/**************************************************************************
* Copyright 2016 Observational Health Data Sciences and Informatics (OHDSI)
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
* Authors: Anna Ostropolets, Timur Vakhitov
* Date: 2018
**************************************************************************/

Prerequisites:
1. Get the latest file from source, name it class_drugs_scraper. The file should contain class code, class name, additional information.
For example, for ATC the file will be created in the following manner:
select id, atc_code as class_code, atc_name as class_name, ddd, u, adm_r, note, description, ddd_description
from atc_drug_scraper;
2. Prepare input tables (drug_concept_stage, internal_relationship_stage, relationship_to_concept)
according to the general rules for drug vocabularies
3. Prepare the following tables:
- reference (represents the original code and concantinated code and its drug forms in RxNorm format)
- class_to_drug_manual (stores manual mappings, i.g. Insulins)

-- 1. Update latest_update field to new date 
DO $_$
BEGIN
	PERFORM VOCABULARY_PACK.SetLatestUpdate(
	pVocabularyName			=> 'ATC',
	pVocabularyDate			=> (SELECT vocabulary_date FROM sources.rxnatomarchive LIMIT 1),
	pVocabularyVersion		=> (SELECT vocabulary_version FROM sources.rxnatomarchive LIMIT 1),
	pVocabularyDevSchema	=> 'DEV_ATC'
);
END $_$;

-- 2. Truncate all working tables and remove indices
TRUNCATE TABLE concept_stage;
TRUNCATE TABLE concept_relationship_stage;
TRUNCATE TABLE concept_synonym_stage;
TRUNCATE TABLE pack_content_stage;
TRUNCATE TABLE drug_strength_stage;

-- 3. Preliminary work
-- 3.1 create table with combo drugs to be used later
drop table if exists class_1_comb;
create table class_1_comb as
select * from class_drug_scraper
where class_name ~ 'comb| and |diphtheria-|meningococcus|excl|derivate|other|with'
and length (class_code) = 7
and not class_name ~ 'decarboxylase inhibitor';

 -- 3.2 create a table with aggregated RxNorm/RxE ingredients
drop table if exists rx_combo;
create table rx_combo as
select drug_concept_id, 
  string_agg(ingredient_concept_id::varchar, '-' order by ingredient_concept_id) as i_combo
from drug_strength
join concept on concept_id = drug_concept_id and concept_class_id in ('Clinical Drug Form') -- 'Clinical Drug Comp' doesn exist
group by drug_concept_id
;

-- 3.3 Precise combos (and)
drop table if exists simple_comb;
create table simple_comb as
with ing as
(select i.concept_code_1,i.concept_code_2, class_name,precedence,rtc.concept_id_2 as ing 
from class_1_comb
left join reference using (class_code)
join internal_relationship_stage i on coalesce (concept_code,class_code) = concept_code_1
join drug_concept_stage d on d.concept_code = concept_code_2 and concept_class_id = 'Ingredient'
join relationship_to_concept rtc on rtc.concept_code_1 = d.concept_code
 where  class_name ~ ' and ' and not class_name ~ 'excl|combinations of|derivate|other|with'
),
form as
(select i.concept_code_1,rtc.concept_id_2 as form  
from class_1_comb
left join reference using (class_code)
join internal_relationship_stage i on coalesce (concept_code,class_code) = concept_code_1
join drug_concept_stage d on d.concept_code = concept_code_2 and concept_class_id = 'Dose Form'
join relationship_to_concept rtc on rtc.concept_code_1 = d.concept_code
 where  class_name ~ ' and ' and not class_name ~ 'excl|combinations of|derivate|other|with'
)
select distinct i.concept_code_1,i.concept_code_2, class_name, ing,form,precedence
from ing i
left join form f on i.concept_code_1=f.concept_code_1;

-- 3.4 mapping 1 to 1, use drugs where 2 ingredient_id occur
drop table if exists class_combo;
create table class_combo as
select concept_code_1, 
  string_agg(ing::varchar, '-' order by ing) as i_combo
from simple_comb
where concept_code_1 in 
(select concept_code_1 from simple_comb
where concept_code_2 in
(select concept_code_2 from (select distinct concept_code_2, ing from simple_comb) s
group by concept_code_2 having count(1)=1)
group by concept_code_1 having count(1)=2) 
group by concept_code_1
;

drop table if exists class_to_drug_1;
create table class_to_drug_1 as
select concept_code_1, class_name, c2.concept_id, c2.concept_name, c2.concept_class_id 
from class_combo
join simple_comb using (concept_code_1)
join rx_combo using (i_combo)
join concept c on c.concept_id=drug_concept_id
join concept_relationship cr on concept_id_1 = c.concept_id and cr.invalid_reason is null and relationship_id = 'RxNorm has dose form' 
and concept_id_2 = form
join concept c2 on concept_id_1 = c2.concept_id
;
insert into class_to_drug_1
select concept_code_1, class_name, c.concept_id, c.concept_name, c.concept_class_id
from class_combo
join simple_comb using (concept_code_1)
join rx_combo using (i_combo)
join concept c on c.concept_id=drug_concept_id
where concept_code_1 not in (select concept_code_1 from class_to_drug_1) and concept_code_1 not like '% %' --w/o forms
;

delete from class_to_drug_1
where class_name like '%,%,%and%'
and not class_name ~* 'comb|other|whole root|selective'
and concept_name not like '%/%/%/%';

delete from class_to_drug_1
where class_name like '%,%and%'
and class_name not like '%,%,%and%'
and not class_name ~* 'comb|other|whole root|selective'
and concept_name not like '% / % / %';

-- introducing precedence
insert into class_to_drug_1
with class_comb as
(with hold as (select *
from  simple_comb s
where
not exists (select 1 from simple_comb s2 where s2.concept_code_2=s.concept_code_2 and s2.precedence>1) -- we hold
)
select h.concept_code_1, s.class_name, case when h.ing>s.ing then s.ing||'-'||h.ing else h.ing||'-'||s.ing end as i_combo, h.form
from hold h
join simple_comb s on h.concept_code_1=s.concept_code_1 and h.ing!=s.ing
where h.concept_code_1 not in (select concept_code_1 from class_to_drug_1))
select concept_code_1, class_name, c.concept_id, c.concept_name, c.concept_class_id
from class_comb
join rx_combo using (i_combo)
join concept c on c.concept_id=drug_concept_id
join concept_relationship cr on concept_id_1 = c.concept_id and cr.invalid_reason is null and relationship_id = 'RxNorm has dose form'
and concept_id_2 = form
join concept c2 on concept_id_2 = c2.concept_id
;
insert into class_to_drug_1
with class_comb as
(with hold as (select *
from  simple_comb s
where
not exists (select 1 from simple_comb s2 where s2.concept_code_2=s.concept_code_2 and s2.precedence>1) -- we hold
)
select h.concept_code_1, s.class_name, case when h.ing>s.ing then s.ing||'-'||h.ing else h.ing||'-'||s.ing end as i_combo, h.form
from hold h
join simple_comb s on h.concept_code_1=s.concept_code_1 and h.ing!=s.ing
where h.concept_code_1 not in (select concept_code_1 from class_to_drug_1))
select concept_code_1, class_name, c.concept_id, c.concept_name, c.concept_class_id
from class_comb
join rx_combo using (i_combo)
join concept c on c.concept_id=drug_concept_id
where concept_code_1 not like '% %' --w/o forms
;
-- 3.5 2nd usual combos
drop table verysimple_comb;
create table verysimple_comb as
with ing as
(select i.concept_code_1,i.concept_code_2, class_name,rtc.concept_id_2 as ing, 'ing' as flag
from class_1_comb
left join reference using (class_code)
join internal_relationship_stage i  on coalesce (concept_code,class_code) = concept_code_1
join drug_concept_stage d on d.concept_code = concept_code_2 and concept_class_id = 'Ingredient'
join relationship_to_concept rtc on rtc.concept_code_1 = d.concept_code
 where  class_name ~ 'comb' and not class_name ~ 'excl| and |combinations of|derivate|other|with'
),
form as
(select i.concept_code_1,rtc.concept_id_2 as form  
from class_1_comb
left join reference using (class_code)
join internal_relationship_stage i on coalesce (concept_code,class_code) = concept_code_1
join drug_concept_stage d on d.concept_code = concept_code_2 and concept_class_id = 'Dose Form'
join relationship_to_concept rtc on rtc.concept_code_1 = d.concept_code
 where  class_name ~ 'comb' and not class_name ~ 'excl| and |combinations of|derivate|other|with'
),
addit as
(select i.concept_code_1, i.concept_code_2, class_name, rtc.concept_id_2 as ing, 'with' as flag
from class_1_comb a
left join reference r using (class_code)
join concept c on regexp_replace(c.concept_code,'..$','') = regexp_replace (a.class_code,'..$','') and c.concept_class_id = 'ATC 5th'
join internal_relationship_stage i  on coalesce (r.concept_code,class_code) = concept_code_1
join drug_concept_stage d on d.concept_code = concept_code_2 and d.concept_class_id = 'Ingredient'
join relationship_to_concept rtc on rtc.concept_code_1 = d.concept_code
	)

select distinct i.concept_code_1,i.concept_code_2, class_name, ing,form, flag
from
	( select * from ing
	 union all
	 select * from addit )i
left join form f on i.concept_code_1=f.concept_code_1
order by i.concept_code_1;

drop table if exists class_to_drug_2;
create table class_to_drug_2 as 
with secondary_table as (
select a.concept_id, a.concept_name ,a.concept_class_id,a.vocabulary_id, c.concept_id_2,r.i_combo
 from rx_combo r
join concept a on r.drug_concept_id = a.concept_id
 join concept_relationship c  on c.concept_id_1 = a.concept_id
 where a.concept_class_id = 'Clinical Drug Form'
 and a.vocabulary_id like 'RxNorm'--temporary remove RXE
 and a.invalid_reason is null
 and relationship_id = 'RxNorm has dose form'
 and c.invalid_reason is null
),
	primary_table as (
			select v.concept_code_1, v.form, v.class_name, case when v.ing>v2.ing then cast(v2.ing as varchar)||'-'||cast(v.ing as varchar)
																		  else cast(v.ing as varchar)||'-'||cast(v2.ing as varchar) end as class_combo
from verysimple_comb v
join verysimple_comb v2 on v.concept_code_1 = v2.concept_code_1 and v.flag = 'ing' and v2.flag = 'with'
where v.ing!=v2.ing)
select distinct p.concept_code_1, class_name, s.concept_id, s.concept_name, s.concept_class_id
from primary_table p
	join secondary_table s
on s.concept_id_2 = p.form
and s.i_combo = p.class_combo
;

insert into class_to_drug_2
with primary_table as (
			select v.concept_code_1, v.form, v.class_name, case when v.ing>v2.ing then cast(v2.ing as varchar)||'-'||cast(v.ing as varchar)
																		  else cast(v.ing as varchar)||'-'||cast(v2.ing as varchar) end as class_combo
from verysimple_comb v
join verysimple_comb v2 on v.concept_code_1 = v2.concept_code_1 and v.flag = 'ing' and v2.flag = 'with'
where v.ing!=v2.ing)
select distinct p.concept_code_1, class_name, c.concept_id, c.concept_name, c.concept_class_id
from primary_table p
join rx_combo r on p.class_combo = r.i_combo
join concept c on c.concept_id = r.drug_concept_id  and c.concept_class_id = 'Clinical Drug Form' and c.vocabulary_id = 'RxNorm'
where p.concept_code_1 not like '% %'--exclude classes with known forms
;

-- 3.6 class concepts that represent combos with exclusions
drop table if exists compl_combo;
create table compl_combo as
with hold as (
select *  from ambiguous_class_ingredient d
join relationship_to_concept on concept_code_1 = ing and flag = 'ing' --we hold
where not exists (select 1 from ambiguous_class_ingredient d2 where d.class_code = d2.class_code and d.ing = d2.ing and precedence>1) -- we hold, exclude multiple for now
),
excl as (
select * from ambiguous_class_ingredient d
join relationship_to_concept on concept_code_1 = ing and flag = 'excl' --we exclude
),
additional as (
select * from ambiguous_class_ingredient d
join relationship_to_concept on concept_code_1 = ing and flag = 'with' --we add
)

select distinct r.concept_code as concept_code_1, h. class_name, drug_concept_id as concept_id, concept_name,concept_class_id
from hold h
join reference r on r.class_code = h.class_code
left join additional a on h.class_code=a.class_code
left join excl e on h.class_code=e.class_code
join rx_combo on i_combo ~ cast(h.concept_id_2 as varchar) and i_combo like '%-%'
join concept c on c.concept_id = drug_concept_id
where (a.class_code is not null and i_combo ~ cast(a.concept_id_2 as varchar))
or (e.class_code is not null and not i_combo ~ cast(e.concept_id_2 as varchar))
;

--with no excluded
insert into compl_combo
with hold as (
select *  from ambiguous_class_ingredient d
join relationship_to_concept on concept_code_1 = ing and flag = 'ing' --we hold
where not exists (select 1 from ambiguous_class_ingredient d2 where d.class_code = d2.class_code and d.ing = d2.ing and precedence>1) -- we hold, exclude multiple for now
),
excl as (
select * from ambiguous_class_ingredient d
join relationship_to_concept on concept_code_1 = ing and flag = 'excl' --we exclude
),
additional as (
select * from ambiguous_class_ingredient d
join relationship_to_concept on concept_code_1 = ing and flag = 'with' --we add
)

select distinct r.concept_code as concept_code_1, h. class_name, drug_concept_id as concept_id, concept_name,concept_class_id
from hold h
join reference r on r.class_code = h.class_code
join additional a on h.class_code=a.class_code
left join excl e on e.class_code = h.class_code 
join rx_combo on i_combo ~ cast(h.concept_id_2 as varchar) and i_combo ~ cast(a.concept_id_2 as varchar) and i_combo like '%-%'
join concept c on c.concept_id = drug_concept_id
where e.class_name is null
;
--with
drop table if exists class_to_drug_3;
create table class_to_drug_3 as
select c.* 
from compl_combo c
join internal_relationship_stage i on i.concept_code_1=c.concept_code_1
join relationship_to_concept rtc on rtc.concept_code_1 = i.concept_code_2
join concept_relationship cr  on cr.concept_id_1 = c.concept_id
and relationship_id = 'RxNorm has dose form'  and cr.invalid_reason is null
where cr.concept_id_2 = rtc.concept_id_2
and class_name like '%with%'
;
--inserting everything that goes without a form
insert into class_to_drug_3
select * from compl_combo
where concept_code_1 not like '% %' and class_name like '%with%';

--start removing falsly assign combo based on WHO rank

-- zero rank
delete from class_to_drug_3
where concept_code_1 ~ 'M03BA73|M03BA72|N02AC74|M03BB72|N02BB52|M03BB73|M09AA72|N02AB72|N02BB72|N02BA77' 
and concept_name ~* 'Salicylamide|Phenazone|Aspirin|Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin|Methadone|etamizole|Ergotamine'
;
--starts the official rank
delete from class_to_drug_3
where concept_code_1 ~ 'N02BB74' and concept_name ~* 'Salicylamide|Phenazone|Aspirin|Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin'
;
delete from class_to_drug_3
where concept_code_1 ~ 'N02BB51' and concept_name ~* 'Salicylamide|Aspirin|Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin'
;
delete from class_to_drug_3
where concept_code_1 ~ 'N02BA75' and concept_name ~* 'Phenazone|Aspirin|Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin'
;
delete from class_to_drug_3
where concept_code_1 ~ 'N02BB71' and concept_name ~* 'Aspirin|Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin'
;
delete from class_to_drug_3
where concept_code_1 ~ 'N02BA71' and concept_name ~* 'Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin'
;
delete from class_to_drug_3
where concept_code_1 ~ 'N02BE71' and concept_name ~* 'Dipyrocetyl|Bucetin|Phenacetin'
;
delete from  class_to_drug_3
where concept_code_1 ~ 'N02' and concept_name ~ 'Codeine' and not class_name ~ 'codeine';

delete from class_to_drug_3 where  concept_id in --removing duplicates 
(select concept_id from class_to_drug_1);

-- 3.7 class codes of type a+b excl. c
drop table if exists class_to_drug_4;
create table class_to_drug_4 as
select c.* from compl_combo c
join internal_relationship_stage i on i.concept_code_1=c.concept_code_1
join relationship_to_concept rtc on rtc.concept_code_1 = i.concept_code_2
join concept_relationship cr  on cr.concept_id_1 = c.concept_id
and relationship_id = 'RxNorm has dose form'  and cr.invalid_reason is null
where cr.concept_id_2 = rtc.concept_id_2
and class_name not like '%with%'

;
--inserting everything that goes without a form
insert into class_to_drug_4
select * from compl_combo
where concept_code_1 not like '% %' and class_name not like '%with%';

-- zero rank
delete from class_to_drug_4
where concept_code_1 ~ 'M03BA53|M03BA52|N02AC54|M03BB52|M03BB53|N02AB52|N02BB52|N02CA52|N02BA57' 
and concept_name ~* 'Salicylamide|Phenazone|Aspirin|Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin|Methadone'
;
--starts the official rank
delete from class_to_drug_4
where concept_code_1 ~ 'N02BB54|N02BB52|M03BB52' and concept_name ~* 'Salicylamide|Phenazone|Aspirin|Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin|Ergotamine|Dipyrone'
;
delete from class_to_drug_4
where concept_code_1 ~ 'N02BA55' and concept_name ~* 'Phenazone|Aspirin|Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin|Ergotamine|Metamizole'
;
delete from class_to_drug_4
where concept_code_1 ~ 'N02BB51' and concept_name ~* 'Aspirin|Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin|Ergotamine|Metamizole'
;
delete from class_to_drug_4
where concept_code_1 ~ 'N02BA51' and concept_name ~* 'Acetaminophen|Dipyrocetyl|Bucetin|Phenacetin|Ergotamine|Metamizole'
;
delete from class_to_drug_4
where concept_code_1 ~ 'N02BE51|N02BB53' and concept_name ~* 'Dipyrocetyl|Bucetin|Phenacetin|Ergotamine|Metamizole'
;
delete from class_to_drug_4
where concept_code_1 ~ 'N02AC54' and concept_name ~* 'Dipyrone';

delete from  class_to_drug_4
where concept_code_1 ~ 'N02' and concept_name ~ 'Codeine' and not class_name ~ 'codeine';

delete from class_to_drug_4 where  concept_id in --removing duplicates 
(select concept_id from class_to_drug_1);

--atenolol and other diuretics, combinations, one of a kind
delete from class_to_drug_4
where concept_code_1 ~ 'C07CB53|C07DB01' and concept_name not like '%/%/%';
delete from class_to_drug_4
where concept_code_1 ~ 'C07CB03|C07CB53' and concept_name  like '%/%/%';

-- PPI and aspirin
delete from class_to_drug_4
where concept_code_1 ~ 'N02BA51' and concept_name ~* 'Omeprazole|Pantoprazole|Rabeprazol';

-- 3.8  Simlpe class codes that have dose forms
drop table if exists primary_table;
create table primary_table as
with ing as
(select i.concept_code_1,class_name,rtc.concept_id_2 as ing 
from class_1
left join reference using (class_code)
join internal_relationship_stage i  on coalesce (concept_code,class_code) = concept_code_1
join drug_concept_stage d on d.concept_code = concept_code_2 and concept_class_id = 'Ingredient'
join relationship_to_concept rtc on rtc.concept_code_1 = d.concept_code
),
form as
(select i.concept_code_1,rtc.concept_id_2 as form  
from class_1
left join reference using (class_code)
join internal_relationship_stage i on coalesce (concept_code,class_code) = concept_code_1
join drug_concept_stage d on d.concept_code = concept_code_2 and concept_class_id = 'Dose Form'
join relationship_to_concept rtc on rtc.concept_code_1 = d.concept_code
)
select distinct i.concept_code_1, class_name, ing,form
from ing i
left join form f on i.concept_code_1=f.concept_code_1;

drop table if exists class_to_drug_5;
create table class_to_drug_5 as
with secondary_table as (
select a.concept_id, a.concept_name ,a.concept_class_id,a.vocabulary_id,c.concept_id_2 as sform, b.ingredient_concept_id as sing 
 from concept a
 join drug_strength b on b.drug_concept_id = a.concept_id
 join concept_relationship c on c.concept_id_1 = a.concept_id
 where a.concept_class_id = 'Clinical Drug Form'
 and a.vocabulary_id = 'RxNorm'--temporary remove RXE
 and a.invalid_reason is null and relationship_id = 'RxNorm has dose form'
 and c.invalid_reason is null
 and not exists (select 1 from drug_strength d 
 where d.drug_concept_id = b.drug_concept_id and d.ingredient_concept_id!=b.ingredient_concept_id) -- excluding combos
)
select distinct p.concept_code_1, class_name, s.concept_id, s.concept_name, s.concept_class_id 
from primary_table p, secondary_table s
where s.sform = p.form
and s.sing = p.ing
;
--manually excluded drugs based on Precise Ingredients
insert into class_to_drug_5
select 'B02BD11','catridecacog', concept_id, concept_name, concept_class_id
	from concept where vocabulary_id = 'RxNorm' and concept_name like 'coagulation factor XIII a-subunit (recombinant)%' and standard_concept='S'
or concept_id = 35603348 -- the whole hierarchy
;

insert into class_to_drug_5
select 'B02BD14','susoctocog alfa', concept_id, concept_name, concept_class_id
from concept where vocabulary_id like 'RxNorm%' and concept_name like 'antihemophilic factor, porcine B-domain truncated recombinant%' and standard_concept='S'
or concept_id in (35603348,44109089) -- the whole hierarchy
;
delete from class_to_drug_5
where concept_code_1 = 'B02BD14' and concept_name like '%Tretten%' --catridecacog
;
delete from class_to_drug_5
where class_name = 'amino acids';

-- 3.9 Class codes that do not have forms (ingredients only)
drop table if exists class_to_drug_6;
create table class_to_drug_6 as
with secondary_table as (
 select a.concept_id, a.concept_name ,a.concept_class_id,a.vocabulary_id, b.ingredient_concept_id as sing 
 from concept a
 join drug_strength b
 on b.drug_concept_id = a.concept_id
 where a.concept_class_id = 'Ingredient' and a.invalid_reason is null
 and a.vocabulary_id = 'RxNorm'--temporary remove RXE
and not exists (select 1 from drug_strength d where d.drug_concept_id = b.drug_concept_id and d.ingredient_concept_id!=b.ingredient_concept_id) -- excluding combos
)
select distinct p.concept_code_1, class_name, s.concept_id, s.concept_name, s.concept_class_id 
from primary_table p, secondary_table s
where s.sing = p.ing
and p.form is null
and p.concept_code_1 not in (select concept_code from reference where concept_code!=class_code)-- exclude drugs that should have forms (will remain unmapped)
;


-- 4. Start final assembly
--TODO: G03FB|G03AB 

drop table if exists сlass_to_rx_descendant;
create table сlass_to_rx_descendant
as
select  distinct substring (concept_code_1,'\w+') as class_code, class_name, c.concept_id, c.concept_name,  c.concept_code, c.concept_class_id, '1' as order
from class_to_drug_1 a
join devv5.concept_ancestor on ancestor_concept_id = a.concept_id
join concept c on c.concept_id = descendant_concept_id and vocabulary_id like 'RxNorm%' and c.standard_concept = 'S'
 ;
delete from сlass_to_rx_descendant
where class_code ~ 'G03FB|G03AB' and concept_class_id not like '%Pack%';

insert into сlass_to_rx_descendant
select  distinct substring (concept_code_1,'\w+'),class_name, c.concept_id, c.concept_name,  c.concept_code, c.concept_class_id, '2' as order
from class_to_drug_2 a
join devv5.concept_ancestor on ancestor_concept_id = a.concept_id
join concept c on c.concept_id = descendant_concept_id  and c.vocabulary_id like 'RxNorm%' and c.standard_concept = 'S'
where descendant_concept_id not in (select concept_id from сlass_to_rx_descendant)
;

insert into сlass_to_rx_descendant
select  distinct substring (concept_code_1,'\w+'), class_name,c.concept_id, c.concept_name, c.concept_code, c.concept_class_id, '3' as order
from class_to_drug_3 a
join devv5.concept_ancestor on ancestor_concept_id = a.concept_id
join concept c on c.concept_id = descendant_concept_id  and c.vocabulary_id like 'RxNorm%' and c.standard_concept = 'S'
where descendant_concept_id not in (select concept_id from сlass_to_rx_descendant)
;
insert into сlass_to_rx_descendant
select  distinct substring (concept_code_1,'\w+'), c.concept_id, c.concept_name, c.concept_code, c.concept_class_id, '4' as order
from class_to_drug_4 a
join devv5.concept_ancestor on ancestor_concept_id = a.concept_id
join concept c on c.concept_id = descendant_concept_id  and c.vocabulary_id like 'RxNorm%' and c.standard_concept = 'S'
where descendant_concept_id not in (select concept_id from сlass_to_rx_descendant)
;

insert into сlass_to_rx_descendant
select  distinct substring (concept_code_1,'\w+'), class_name,c.concept_id, c.concept_name, c.concept_code, c.concept_class_id, '5' as order
from class_to_drug_5 a
join devv5.concept_ancestor on ancestor_concept_id = a.concept_id
join concept c on c.concept_id = descendant_concept_id  and c.vocabulary_id like 'RxNorm%' and c.standard_concept = 'S'
join drug_strength d on d.drug_concept_id = c.concept_id
where descendant_concept_id not in (select concept_id from сlass_to_rx_descendant)
and not exists
	(select 1 from concept c2 join devv5.concept_ancestor ca2
	 on ca2.ancestor_concept_id = c2.concept_id and c2.concept_class_id = 'Ingredient'
	 where ca2.descendant_concept_id = d.drug_concept_id and c2.concept_id!=d.ingredient_concept_id) -- excluding combos
;
--working with packs
with a as (
		select distinct
			a.*,
			c.concept_id as pack_id,
			d.drug_concept_id,
			d.ingredient_concept_id
		from class_to_drug_5 a
			join devv5.concept_ancestor on ancestor_concept_id = a.concept_id
			join concept c on c.concept_id = descendant_concept_id and c.vocabulary_id like 'RxNorm%'
												and c.standard_concept = 'S' and c.concept_class_id in ('Clinical Pack ', 'Branded Pack')
			join concept_relationship cr
				on cr.concept_id_1 = c.concept_id and cr.invalid_reason is null and cr.relationship_id = 'Contains'
			join drug_strength d on d.drug_concept_id = cr.concept_id_2
		where descendant_concept_id not in (select concept_id
																				from сlass_to_rx_descendant)
),
b as (
		select distinct concept_code_1,class_name,concept_id,concept_name,concept_class_id, pack_id,
			string_agg(ingredient_concept_id::varchar, '-' order by ingredient_concept_id) as i_combo
		from a
		group by concept_code_1,class_name,concept_id,concept_name,concept_class_id, pack_id
	),
c as (
		select distinct b.concept_code_1, b.class_name, b.concept_id, b.concept_name, b.concept_class_id, b.i_combo,pack_id,
			string_agg(ca.ancestor_concept_id:: varchar, '-' order by ca.ancestor_concept_id) as i_combo_2
		from b
			join devv5.concept_ancestor ca on b.concept_id = ca.descendant_concept_id
			join concept c on c.concept_id = ca.ancestor_concept_id and c.concept_class_id = 'Ingredient'
		group by b.concept_code_1, b.class_name, b.concept_id, b.concept_name, b.concept_class_id, b.i_combo, ca.descendant_concept_id,pack_id
)
insert into сlass_to_rx_descendant 
(class_code,class_name,concept_id,concept_name,concept_code,concept_class_id,"order")
select  distinct  substring (concept_code_1,'\w+'),pack_id,cc.concept_name,cc.concept_code,cc.concept_class_id, '5'
from c
join concept cc on cc.concept_id = pack_id
where i_combo = i_combo_2 or i_combo = i_combo_2||'-'||i_combo_2
;

insert into сlass_to_rx_descendant
select  distinct substring (concept_code_1,'\w+'), c.concept_id, c.concept_name, c.concept_code, c.concept_class_id, '6' as order
from class_to_drug_6 a
join devv5.concept_ancestor on ancestor_concept_id = a.concept_id
join concept c on c.concept_id = descendant_concept_id  and c.vocabulary_id like 'RxNorm%' and c.standard_concept = 'S'
join drug_strength d on d.drug_concept_id = c.concept_id
where descendant_concept_id not in (select concept_id from сlass_to_rx_descendant)
and not exists
	(select 1 from concept c2 join devv5.concept_ancestor ca2
	 on ca2.ancestor_concept_id = c2.concept_id and c2.concept_class_id = 'Ingredient'
	 where ca2.descendant_concept_id = d.drug_concept_id and c2.concept_id!=d.ingredient_concept_id) -- excluding combos
;

--working with packs
with a as (
		select distinct
			a.*,
			c.concept_id as pack_id,
			d.drug_concept_id,
			d.ingredient_concept_id
		from class_to_drug_6 a
			join devv5.concept_ancestor on ancestor_concept_id = a.concept_id
			join concept c on c.concept_id = descendant_concept_id and c.vocabulary_id like 'RxNorm%'
												and c.standard_concept = 'S' and c.concept_class_id in ('Clinical Pack ', 'Branded Pack')
			join concept_relationship cr
				on cr.concept_id_1 = c.concept_id and cr.invalid_reason is null and cr.relationship_id = 'Contains'
			join drug_strength d on d.drug_concept_id = cr.concept_id_2
		where descendant_concept_id not in (select concept_id
																				from сlass_to_rx_descendant)
),
b as (
		select distinct concept_code_1,class_name,concept_id,concept_name,concept_class_id, pack_id,
			string_agg(ingredient_concept_id::varchar, '-' order by ingredient_concept_id) as i_combo
		from a
		group by concept_code_1,class_name,concept_id,concept_name,concept_class_id, pack_id
	),
c as (
		select distinct b.concept_code_1, b.class_name, b.concept_id, b.concept_name, b.concept_class_id, b.i_combo,pack_id,
			string_agg(ca.ancestor_concept_id:: varchar, '-' order by ca.ancestor_concept_id) as i_combo_2
		from b
			join devv5.concept_ancestor ca on b.concept_id = ca.descendant_concept_id
			join concept c on c.concept_id = ca.ancestor_concept_id and c.concept_class_id = 'Ingredient'
		group by b.concept_code_1, b.class_name, b.concept_id, b.concept_name, b.concept_class_id, b.i_combo, ca.descendant_concept_id,pack_id
)
insert into сlass_to_rx_descendant 
(class_code,class_name,concept_id,concept_name,concept_code,concept_class_id,"order")
select distinct substring (concept_code_1,'\w+'),class_name,pack_id,cc.concept_name,cc.concept_code,cc.concept_class_id, '6'
from c
join concept cc on cc.concept_id = pack_id
where i_combo = i_combo_2 or i_combo = i_combo_2||'-'||i_combo_2
;

delete from сlass_to_rx_descendant where class_name like '%insulin%';
insert into сlass_to_rx_descendant
select distinct class_code, class_name,c.concept_id, c.concept_name, c.concept_code, c.concept_class_id, '7' as order
from class_to_drug_manual m
join devv5.concept_ancestor ca on ca.ancestor_concept_id = m.concept_id
join concept c on c.concept_id = ca.descendant_concept_id
join drug_strength d on d.drug_concept_id = c.concept_id
;

--- need  to  be fixed!
insert into сlass_to_rx_descendant
select distinct  class_code, class_name,c.concept_id, c.concept_name, c.concept_code, c.concept_class_id, f.order
from class_to_drug f
join devv5.concept_ancestor ca on ca.ancestor_concept_id = cast(f.concept_id as int)
join devv5.concept c on c.concept_id = descendant_concept_id and c.concept_class_id like '%Pack%'
where s.class_code ~ 'G03FB|G03AB'; -- packs

delete from сlass_to_rx_descendant
where class_code ~ 'G03FB|G03AB' and concept_class_id in ('Clinical Drug Form','Ingredient');

delete from  сlass_to_rx_descendant
where class_name like '%and estrogen%' -- if there are regular estiol/estradiol/EE
and concept_id in (select concept_id from сlass_to_rx_descendant group by concept_id having count(1)>1);

--temporary
delete from сlass_to_rx_descendant
where class_name like '%,%,%and%'
and not class_name ~* 'comb|other|whole root|selective'
and concept_name not like '%/%/%/%';

delete from сlass_to_rx_descendant
where class_name like '%,%and%'
and class_name not like '%,%,%and%'
and not class_name ~* 'comb|other|whole root|selective'
and concept_name not like '% / % / %';

--table w/o ancestor
drop table if exists class_to_drug;
create table class_to_drug
as
select  distinct substring (concept_code_1,'\w+'), a.class_name, a.concept_id, a.concept_name,  a.concept_code_1, a.concept_class_id, '1' as order
from class_to_drug_1 a
;
insert into class_to_drug
select  distinct substring (concept_code_1,'\w+'), a.class_name, a.concept_id, a.concept_name,  a.concept_code_1, a.concept_class_id, '2' as order
from class_to_drug_2 a
where class_code not in
(select class_code from class_to_drug)
and a.concept_id not in
(select concept_id from class_to_drug)
;
insert into class_to_drug
select  distinct substring (concept_code_1,'\w+'), a.class_name, a.concept_id, a.concept_name,  a.concept_code_1, a.concept_class_id, '3' as order
from class_to_drug_3 a
where class_code not in
(select class_code from class_to_drug)
;
insert into class_to_drug
select  distinct substring (concept_code_1,'\w+'),  a.class_name, a.concept_id, a.concept_name,  a.concept_code_1, a.concept_class_id, '4' as order
from class_to_drug_4 a
where class_code not in
(select class_code from class_to_drug);

insert into class_to_drug
select  distinct substring (concept_code_1,'\w+'),  a.class_name, a.concept_id, a.concept_name, a.concept_code_1, a.concept_class_id, '5' as order
from class_to_drug_5 a
where class_code not in
(select class_code from class_to_drug);

insert into class_to_drug
select  distinct substring (concept_code_1,'\w+'),  a.class_name, a.concept_id, a.concept_name, a.concept_code_1, a.concept_class_id, '6' as order
from class_to_drug_6 a
where class_code not in
(select class_code from class_to_drug);

delete from class_to_drug where class_name like '%insulin%';
insert into class_to_drug
select distinct class_code,m.class_name, m.concept_id, m.concept_name, c.concept_code, m.concept_class_id, '7' as order
from class_to_drug_manual m
join concept c using(concept_id)
;

insert into class_to_drug
select f.class_code, f.class_name, c.concept_id, c.concept_name, c.concept_code, c.concept_class_id, f.order
from class_to_drug f
join devv5.concept_ancestor ca
on ca.ancestor_concept_id = f.concept_id
join devv5.concept c on c.concept_id = descendant_concept_id and c.concept_class_id like '%Pack%'
where class_code ~ 'G03FB|G03AB'; -- packs
delete from class_to_drug
where class_code ~ 'G03FB|G03AB' and concept_class_id in ('Clinical Drug Form','Ingredient');

delete from  class_to_drug
where class_name like '%and estrogen%' -- if there are regular estiol/estradiol/EE
and concept_id in (select concept_id from class_to_drug group by concept_id having count(1)>1);


--TODO: 
--5. triggers




-- 6. Add ATC
-- create temporary table atc_tmp_table
DROP TABLE IF EXISTS atc_tmp_table;
CREATE UNLOGGED TABLE atc_tmp_table AS
SELECT rxcui,
	code,
	concept_name,
	'ATC' AS vocabulary_id,
	'C' AS standard_concept,
	concept_code,
	concept_class_id
FROM (
	SELECT DISTINCT rxcui,
		code,
		SUBSTR(str, 1, 255) AS concept_name,
		code AS concept_code,
		CASE 
			WHEN LENGTH(code) = 1
				THEN 'ATC 1st'
			WHEN LENGTH(code) = 3
				THEN 'ATC 2nd'
			WHEN LENGTH(code) = 4
				THEN 'ATC 3rd'
			WHEN LENGTH(code) = 5
				THEN 'ATC 4th'
			WHEN LENGTH(code) = 7
				THEN 'ATC 5th'
			END AS concept_class_id
	FROM sources.rxnconso
	WHERE sab = 'ATC'
		AND tty IN (
			'PT',
			'IN'
			)
		AND code != 'NOCODE'
	) AS s1;

CREATE INDEX idx_atc_code ON atc_tmp_table (code);
CREATE INDEX idx_atc_ccode ON atc_tmp_table (concept_code);
ANALYZE atc_tmp_table;

-- 7. Add atc_tmp_table to concept_stage
INSERT INTO concept_stage (
	concept_name,
	domain_id,
	vocabulary_id,
	concept_class_id,
	standard_concept,
	concept_code,
	valid_start_date,
	valid_end_date,
	invalid_reason
	)
SELECT concept_name,
	'Drug' AS domain_id,
	dv.vocabulary_id,
	concept_class_id,
	standard_concept,
	concept_code,
	v.latest_update AS valid_start_date,
	TO_DATE('20991231', 'yyyymmdd') AS valid_end_date,
	NULL AS invalid_reason
FROM atc_tmp_table dv,
	vocabulary v
WHERE v.vocabulary_id = dv.vocabulary_id;

-- 8. Create all sorts of relationships to self, RxNorm and SNOMED
INSERT INTO concept_relationship_stage (
	concept_code_1,
	concept_code_2,
	relationship_id,
	vocabulary_id_1,
	vocabulary_id_2,
	valid_start_date,
	valid_end_date,
	invalid_reason
	)
SELECT DISTINCT d.concept_code AS concept_code_1,
	e.concept_code AS concept_code_2,
	'VA Class to ATC eq' AS relationship_id,
	'VA Class' AS vocabulary_id_1,
	'ATC' AS vocabulary_id_2,
	v.latest_update AS valid_start_date,
	TO_DATE('20991231', 'yyyymmdd') AS valid_end_date,
	NULL AS invalid_reason
FROM atc_tmp_table d
JOIN sources.rxnconso r ON r.rxcui = d.rxcui
	AND r.code != 'NOCODE'
JOIN atc_tmp_table e ON r.rxcui = e.rxcui
	AND r.code = e.concept_code
JOIN vocabulary v ON v.vocabulary_id = d.vocabulary_id
WHERE d.concept_class_id LIKE 'VA Class'
	AND e.concept_class_id LIKE 'ATC%'

UNION ALL

-- Cross-link between drug class Chemical Structure AND ATC
SELECT DISTINCT d.concept_code AS concept_code_1,
	e.concept_code AS concept_code_2,
	'NDFRT to ATC eq' AS relationship_id,
	'NDFRT' AS vocabulary_id_1,
	'ATC' AS vocabulary_id_2,
	v.latest_update AS valid_start_date,
	TO_DATE('20991231', 'yyyymmdd') AS valid_end_date,
	NULL AS invalid_reason
FROM atc_tmp_table d
JOIN sources.rxnconso r ON r.rxcui = d.rxcui
	AND r.code != 'NOCODE'
JOIN atc_tmp_table e ON r.rxcui = e.rxcui
	AND r.code = e.concept_code
JOIN vocabulary v ON v.vocabulary_id = d.vocabulary_id
WHERE d.concept_class_id = 'Chemical Structure'
	AND e.concept_class_id IN (
		'ATC 1st',
		'ATC 2nd',
		'ATC 3rd',
		'ATC 4th'
		)

UNION ALL

-- Cross-link between drug class ATC AND Therapeutic Class
SELECT DISTINCT d.concept_code AS concept_code_1,
	e.concept_code AS concept_code_2,
	'NDFRT to ATC eq' AS relationship_id,
	'NDFRT' AS vocabulary_id_1,
	'ATC' AS vocabulary_id_2,
	v.latest_update AS valid_start_date,
	TO_DATE('20991231', 'yyyymmdd') AS valid_end_date,
	NULL AS invalid_reason
FROM atc_tmp_table d
JOIN sources.rxnconso r ON r.rxcui = d.rxcui
	AND r.code != 'NOCODE'
JOIN atc_tmp_table e ON r.rxcui = e.rxcui
	AND r.code = e.concept_code
JOIN vocabulary v ON v.vocabulary_id = d.vocabulary_id
WHERE d.concept_class_id LIKE 'Therapeutic Class'
	AND e.concept_class_id LIKE 'ATC%'

UNION ALL

-- Cross-link between drug class SNOMED AND ATC classes (not ATC 5th)
SELECT DISTINCT d.concept_code AS concept_code_1,
	e.concept_code AS concept_code_2,
	'SNOMED - ATC eq' AS relationship_id,
	'SNOMED' AS vocabulary_id_1,
	'ATC' AS vocabulary_id_2,
	d.valid_start_date,
	TO_DATE('20991231', 'yyyymmdd') AS valid_end_date,
	NULL AS invalid_reason
FROM concept d
JOIN sources.rxnconso r ON r.code = d.concept_code
	AND r.sab = 'SNOMEDCT_US'
	AND r.code != 'NOCODE'
JOIN sources.rxnconso r2 ON r.rxcui = r2.rxcui
	AND r2.sab = 'ATC'
	AND r2.code != 'NOCODE'
JOIN atc_tmp_table e ON r2.code = e.concept_code
	AND e.concept_class_id != 'ATC 5th' -- Ingredients only to RxNorm
WHERE d.vocabulary_id = 'SNOMED'
	AND d.invalid_reason IS NULL

UNION ALL

-- add ATC to RxNorm
SELECT DISTINCT d.concept_code AS concept_code_1,
	e.concept_code AS concept_code_2,
	'ATC - RxNorm' AS relationship_id, -- this is one to substitute "NDFRF has ing", is hierarchical AND defines ancestry.
	'ATC' AS vocabulary_id_1,
	'RxNorm' AS vocabulary_id_2,
	v.latest_update AS valid_start_date,
	TO_DATE('20991231', 'yyyymmdd') AS valid_end_date,
	NULL AS invalid_reason
FROM atc_tmp_table d
JOIN sources.rxnconso r ON r.rxcui = d.rxcui
	AND r.code != 'NOCODE'
JOIN vocabulary v ON v.vocabulary_id = d.vocabulary_id
JOIN concept e ON r.rxcui = e.concept_code
	AND e.vocabulary_id = 'RxNorm'
	AND e.invalid_reason IS NULL
WHERE d.vocabulary_id = 'ATC'
	AND d.concept_class_id = 'ATC 5th' -- there are some weird 4th level links, LIKE D11AC 'Medicated shampoos' to an RxNorm Dose Form
        AND e.concept_class_id not in ('Ingredient','Precise Ingredient')
UNION ALL

-- Hierarchy inside ATC
SELECT uppr.concept_code AS concept_code_1,
	lowr.concept_code AS concept_code_2,
	'Is a' AS relationship_id,
	'ATC' AS vocabulary_id_1,
	'ATC' AS vocabulary_id_2,
	v.latest_update AS valid_start_date,
	TO_DATE('20991231', 'yyyymmdd') AS valid_end_date,
	NULL AS invalid_reason
FROM concept_stage uppr,
	concept_stage lowr,
	vocabulary v
WHERE (
		(
			LENGTH(uppr.concept_code) IN (
				4,
				5
				)
			AND lowr.concept_code = SUBSTR(uppr.concept_code, 1, LENGTH(uppr.concept_code) - 1)
			)
		OR (
			LENGTH(uppr.concept_code) IN (
				3,
				7
				)
			AND lowr.concept_code = SUBSTR(uppr.concept_code, 1, LENGTH(uppr.concept_code) - 2)
			)
		)
	AND uppr.vocabulary_id = 'ATC'
	AND lowr.vocabulary_id = 'ATC'
	AND v.vocabulary_id = 'ATC';

-- 9. Add new relationships
INSERT INTO concept_relationship_stage (
	concept_code_1,
	concept_code_2,
	vocabulary_id_1,
	vocabulary_id_2,
	relationship_id,
	valid_start_date,
	valid_end_date,
	invalid_reason
	)
SELECT DISTINCT f.atc_code AS concept_code_1,
	f.concept_code AS concept_code_2,
	'ATC' AS vocabulary_id_1,
	c.vocabulary_id AS vocabulary_id_2,
	'ATC - RxNorm' AS relationship_id,
	CURRENT_DATE AS valid_start_date,
	TO_DATE('20991231', 'yyyymmdd') AS valid_end_date,
	NULL AS invalid_reason
FROM dev_atc.final_assembly f --manual source table
JOIN concept c ON c.concept_id = f.concept_id
WHERE NOT EXISTS (
		SELECT 1
		FROM concept_relationship_stage crs
		WHERE crs.concept_code_1 = f.atc_code
			AND crs.vocabulary_id_1 = 'ATC'
			AND crs.concept_code_2 = c.concept_code
			AND crs.vocabulary_id_2 = c.vocabulary_id
			AND crs.relationship_id = 'ATC - RxNorm'
		);

-- 10. Add relationships to ingredients excluding multiple-ingredient combos
INSERT INTO concept_relationship_stage (
	concept_code_1,
	concept_code_2,
	vocabulary_id_1,
	vocabulary_id_2,
	relationship_id,
	valid_start_date,
	valid_end_date,
	invalid_reason
	)
SELECT DISTINCT f.atc_code AS concept_code_1,
	c.concept_code AS concept_code_2,
	'ATC' AS vocabulary_id_1,
	c.vocabulary_id AS vocabulary_id_2,
	'ATC - RxNorm' AS relationship_id,
	CURRENT_DATE AS valid_start_date,
	TO_DATE('20991231', 'YYYYMMDD') AS valid_end_date,
	NULL AS invalid_reason
FROM dev_atc.final_assembly f
JOIN devv5.concept_ancestor ca ON ca.descendant_concept_id = f.concept_id
JOIN concept c ON c.concept_id = ca.ancestor_concept_id
	AND c.concept_class_id = 'Ingredient'
	AND c.vocabulary_id LIKE 'RxNorm%'
WHERE NOT f.atc_name ~ 'combination|agents|drugs|supplements|corticosteroids|compounds|sulfonylureas|preparations|thiazides|antacid|antiinfectives|calcium$|potassium$|sodium$|antiseptics|antibiotics|mydriatics|psycholeptic|other|diuretic|nitrates|analgesics'
	AND c.concept_name NOT IN ('Inert Ingredients') -- a component of contraceptive packs
	AND NOT EXISTS (
		SELECT 1
		FROM concept_relationship_stage crs
		WHERE crs.concept_code_1 = f.atc_code
			AND crs.vocabulary_id_1 = 'ATC'
			AND crs.concept_code_2 = c.concept_code
			AND crs.vocabulary_id_2 = c.vocabulary_id
			AND crs.relationship_id = 'ATC - RxNorm'
		);

-- 11. Add relationships to ingredients for combo drugs where possible
INSERT INTO concept_relationship_stage (
	concept_code_1,
	concept_code_2,
	vocabulary_id_1,
	vocabulary_id_2,
	relationship_id,
	valid_start_date,
	valid_end_date,
	invalid_reason
	)
SELECT atc.atc_code AS concept_code_1,
	atc.concept_code AS concept_code_2,
	'ATC' AS vocabulary_id_1,
	atc.vocabulary_id AS vocabulary_id_2,
	'ATC - RxNorm' AS relationship_id,
	CURRENT_DATE AS valid_start_date,
	TO_DATE('20991231', 'YYYYMMDD') AS valid_end_date,
	NULL AS invalid_reason
FROM (
	SELECT d.atc_code,
		c.concept_code,
		c.vocabulary_id
	FROM dev_atc.dev_combo_stage d
	JOIN dev_atc.relationship_to_concept rtc ON rtc.concept_code_1 = d.ing
	JOIN concept c ON rtc.concept_id_2 = c.concept_id
	WHERE d.flag = 'ing'
		AND NOT EXISTS (
			SELECT 1
			FROM dev_atc.dev_combo_stage d2
			WHERE d.atc_code = d2.atc_code
				AND d.ing = d2.ing
				AND rtc.precedence > 1
			)
	
	UNION
	
	SELECT a.atc_code,
		c.concept_code,
		c.vocabulary_id
	FROM dev_atc.atc_1_comb a
	LEFT JOIN dev_atc.reference r ON a.atc_code = r.atc_code
	JOIN dev_atc.internal_relationship_stage i ON coalesce(concept_code, a.atc_code) = i.concept_code_1
	JOIN dev_atc.drug_concept_stage d ON d.concept_code = i.concept_code_2
		AND d.concept_class_id = 'Ingredient'
	JOIN dev_atc.relationship_to_concept rtc ON rtc.concept_code_1 = d.concept_code
	JOIN concept c ON rtc.concept_id_2 = c.concept_id
	WHERE a.atc_name ~ 'comb| and '
		AND NOT EXISTS (
			SELECT 1
			FROM dev_atc.relationship_to_concept rtc2
			WHERE rtc.concept_code_1 = rtc2.concept_code_1
				AND rtc2.precedence > 1
			)
	) atc
WHERE NOT EXISTS (
		SELECT 1
		FROM concept_relationship_stage crs
		WHERE crs.concept_code_1 = atc.atc_code
			AND crs.vocabulary_id_1 = 'ATC'
			AND crs.concept_code_2 = atc.concept_code
			AND crs.vocabulary_id_2 = atc.vocabulary_id
			AND crs.relationship_id = 'ATC - RxNorm'
		);

-- 12. Add manual relationships
DO $_$
BEGIN
	PERFORM VOCABULARY_PACK.ProcessManualRelationships();
END $_$;

-- 13. Remove ATC's duplicates (AVOF-322)
-- diphtheria immunoglobulin
DELETE FROM concept_relationship_stage WHERE concept_code_1 = 'J06BB10' AND concept_code_2 = '3510' AND relationship_id = 'ATC - RxNorm';
-- hydroquinine
DELETE FROM concept_relationship_stage WHERE concept_code_1 = 'M09AA01' AND concept_code_2 = '27220' AND relationship_id = 'ATC - RxNorm';

-- 14. Deprecate relationships between multi ingredient drugs and a single ATC 5th, because it should have either an ATC for each ingredient or an ATC that is a combination of them
-- 14.1. Create temporary table drug_strength_ext (same code as in concept_ancestor, but we exclude ds for ingredients (because we use count(*)>1 and ds for ingredients having count(*)=1) and only for RxNorm)
DROP TABLE IF EXISTS drug_strength_ext;
CREATE UNLOGGED TABLE drug_strength_ext AS
SELECT *
FROM (
	WITH ingredient_unit AS (
			SELECT DISTINCT
				-- pick the most common unit for an ingredient. If there is a draw, pick always the same by sorting by unit_concept_id
				ingredient_concept_code,
				vocabulary_id,
				FIRST_VALUE(unit_concept_id) OVER (
					PARTITION BY ingredient_concept_code ORDER BY cnt DESC,
						unit_concept_id
					) AS unit_concept_id
			FROM (
				-- sum the counts coming from amount and numerator
				SELECT ingredient_concept_code,
					vocabulary_id,
					unit_concept_id,
					SUM(cnt) AS cnt
				FROM (
					-- count ingredients, their units and the frequency
					SELECT c2.concept_code AS ingredient_concept_code,
						c2.vocabulary_id,
						ds.amount_unit_concept_id AS unit_concept_id,
						COUNT(*) AS cnt
					FROM drug_strength ds
					JOIN concept c1 ON c1.concept_id = ds.drug_concept_id
						AND c1.vocabulary_id = 'RxNorm'
					JOIN concept c2 ON c2.concept_id = ds.ingredient_concept_id
						AND c2.vocabulary_id = 'RxNorm'
					WHERE ds.amount_value <> 0
					GROUP BY c2.concept_code,
						c2.vocabulary_id,
						ds.amount_unit_concept_id
					
					UNION
					
					SELECT c2.concept_code AS ingredient_concept_code,
						c2.vocabulary_id,
						ds.numerator_unit_concept_id AS unit_concept_id,
						COUNT(*) AS cnt
					FROM drug_strength ds
					JOIN concept c1 ON c1.concept_id = ds.drug_concept_id
						AND c1.vocabulary_id = 'RxNorm'
					JOIN concept c2 ON c2.concept_id = ds.ingredient_concept_id
						AND c2.vocabulary_id = 'RxNorm'
					WHERE ds.numerator_value <> 0
					GROUP BY c2.concept_code,
						c2.vocabulary_id,
						ds.numerator_unit_concept_id
					) AS s0
				GROUP BY ingredient_concept_code,
					vocabulary_id,
					unit_concept_id
				) AS s1
			)
	-- Create drug_strength for drug forms
	SELECT de.concept_code AS drug_concept_code,
		an.concept_code AS ingredient_concept_code
	FROM concept an
	JOIN devv5.concept_ancestor ca ON ca.ancestor_concept_id = an.concept_id
	JOIN concept de ON de.concept_id = ca.descendant_concept_id
	JOIN ingredient_unit iu ON iu.ingredient_concept_code = an.concept_code
		AND iu.vocabulary_id = an.vocabulary_id
	WHERE an.vocabulary_id = 'RxNorm'
		AND an.concept_class_id = 'Ingredient'
		AND de.vocabulary_id = 'RxNorm'
		AND de.concept_class_id IN (
			'Clinical Drug Form',
			'Branded Drug Form'
			)
	) AS s2;

-- 14.2. Do deprecation
DELETE
FROM concept_relationship_stage
WHERE ctid IN (
		SELECT drug2atc.row_id
		FROM (
			SELECT drug_concept_code
			FROM (
				SELECT c1.concept_code AS drug_concept_code,
					c2.concept_code
				FROM drug_strength ds
				JOIN concept c1 ON c1.concept_id = ds.drug_concept_id
					AND c1.vocabulary_id = 'RxNorm'
				JOIN concept c2 ON c2.concept_id = ds.ingredient_concept_id
				
				UNION
				
				SELECT drug_concept_code,
					ingredient_concept_code
				FROM drug_strength_ext
				) AS s0
			GROUP BY drug_concept_code
			HAVING count(*) > 1
			) all_drugs
		JOIN (
			SELECT *
			FROM (
				SELECT crs.ctid row_id,
					crs.concept_code_2,
					count(*) OVER (PARTITION BY crs.concept_code_2) cnt_atc
				FROM concept_relationship_stage crs
				JOIN concept_stage cs ON cs.concept_code = crs.concept_code_1
					AND cs.vocabulary_id = crs.vocabulary_id_1
					AND cs.vocabulary_id = 'ATC'
					AND cs.concept_class_id = 'ATC 5th'
					AND NOT cs.concept_name ~ 'preparations|virus|antigen|-|/|organisms|insulin|etc\.|influenza|human menopausal gonadotrophin|combination|amino acids|electrolytes| and |excl\.| with |others|various'
				JOIN concept c ON c.concept_code = crs.concept_code_2
					AND c.vocabulary_id = crs.vocabulary_id_2
					AND c.vocabulary_id = 'RxNorm'
				WHERE crs.relationship_id = 'ATC - RxNorm'
					AND crs.invalid_reason IS NULL
				) AS s1
			WHERE cnt_atc = 1
			) drug2atc ON drug2atc.concept_code_2 = all_drugs.drug_concept_code
		);

-- 15. Add synonyms to concept_synonym stage for each of the rxcui/code combinations in atc_tmp_table
INSERT INTO concept_synonym_stage (
	synonym_concept_code,
	synonym_name,
	synonym_vocabulary_id,
	language_concept_id
	)
SELECT DISTINCT dv.concept_code AS synonym_concept_code,
	SUBSTR(r.str, 1, 1000) AS synonym_name,
	dv.vocabulary_id AS synonym_vocabulary_id,
	4180186 AS language_concept_id
FROM atc_tmp_table dv
JOIN sources.rxnconso r ON dv.code = r.code
	AND dv.rxcui = r.rxcui
	AND r.code != 'NOCODE'
	AND r.lat = 'ENG';

-- 16. Working with replacement mappings
DO $_$
BEGIN
	PERFORM VOCABULARY_PACK.CheckReplacementMappings();
END $_$;

-- 17. Deprecate 'Maps to' mappings to deprecated and upgraded concepts
DO $_$
BEGIN
	PERFORM VOCABULARY_PACK.DeprecateWrongMAPSTO();
END $_$;

-- 18. Add mapping from deprecated to fresh concepts
DO $_$
BEGIN
	PERFORM VOCABULARY_PACK.AddFreshMAPSTO();
END $_$;

-- 19. Delete ambiguous 'Maps to' mappings
DO $_$
BEGIN
	PERFORM VOCABULARY_PACK.DeleteAmbiguousMAPSTO();
END $_$;

-- 20. Delete mappings between concepts that are not represented at the "latest_update" at this moment (e.g. SNOMED <-> RxNorm, but currently we are updating ATC)
--This is because we have SNOMED <-> ATC in concept_relationship_stage, but AddFreshMAPSTO adds SNOMED <-> RxNorm from concept_relationship
DELETE
FROM concept_relationship_stage crs_o
WHERE (
		crs_o.concept_code_1,
		crs_o.vocabulary_id_1,
		crs_o.concept_code_2,
		crs_o.vocabulary_id_2
		) IN (
		SELECT crs.concept_code_1,
			crs.vocabulary_id_1,
			crs.concept_code_2,
			crs.vocabulary_id_2
		FROM concept_relationship_stage crs
		LEFT JOIN vocabulary v1 ON v1.vocabulary_id = crs.vocabulary_id_1
			AND v1.latest_update IS NOT NULL
		LEFT JOIN vocabulary v2 ON v2.vocabulary_id = crs.vocabulary_id_2
			AND v2.latest_update IS NOT NULL
		WHERE coalesce(v1.latest_update, v2.latest_update) IS NULL
		);

-- 21. Clean up
DROP TABLE atc_tmp_table;
DROP TABLE drug_strength_ext;

-- At the end, the three tables concept_stage, concept_relationship_stage and concept_synonym_stage should be ready to be fed into the generic_update.sql script


