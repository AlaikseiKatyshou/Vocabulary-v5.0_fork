/**************************************************************************
* Copyright 2016 Observational Health Data Sciences and Informatics (OHDSI)
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
* Authors: Christian Reich
* Date: 2016-2017
**************************************************************************/

-- To do: Ingredient to Brand Name (has brand name), product to Brand Name (has tradename), possible excipient, mEq to mmol, other funny units
-- Put all "drops" to the end

/******************************************************************************
* This script creates a new drug vocabulary in the OMOP Standard Vocabularies *
* The new drug vocabulary must be provided in the format described in         *
* http://www.ohdsi.org/web/wiki/doku.php?id=documentation:international_drugs *
* The processing is also described there. The following tables are required:  *
* drug_concept_stage, internal_relationship_stage, relationship_to_concept,   *
* q_ds_stage. Records that have no concept_code in the source should            *
* receive autogenerated ones in the format 'OMOP' plus a running number.      *
* The tables concept, concept_relationship, concept_ancestor and              *
* drug_strength need to be locally availabe.                                  *
*******************************************************************************/

/** IMPORTANT **/
/* Add the latest_udpate and version information to the VOCABULARY table **/

drop index idx_dcs_concept_code;
create index idx_dcs_concept_code on drug_concept_stage (concept_code)
;
commit;

-- Add existing mappings from previous runs. 
drop view r_to_c;
create view r_to_c as
  select * from relationship_to_concept where concept_code_1 is not null
union
  select c1.concept_code as concept_code_1, c1.vocabulary_id as vocabulary_id_1, r.concept_id_2, 1, null
  from concept c1
  join concept_relationship r on r.concept_id_1=c1.concept_id and r.relationship_id in ('Maps to', 'Source - RxNorm eq') and r.invalid_reason is null
  join concept c2 on c2.concept_id=r.concept_id_2 and c2.standard_concept='S'
  where c1.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)
  and c2.vocabulary_id in ('RxNorm', 'RxNorm Extension') 
  and c2.concept_class_id in ('Ingredient', 'Dose Form', 'Brand Name', 'Supplier')
  and c1.concept_code not in (select concept_code_1 from relationship_to_concept where concept_code_1 is not null)
;

/*****************************************************************************************************************************************************
* 1. Prepare drug components for new vocabularies: Create unique list and for each drug enumerate. This allows to create a single row for each drug. *
*****************************************************************************************************************************************************/

-- Create temporary for uniqe strength recordsdrop sequence q_ds_seq;
drop sequence ds_seq;
create sequence ds_seq increment by 1 start with 1 nocycle cache 20 noorder;
-- Create sequence for temporary XXX concept codes
drop sequence xxx_seq;
create sequence xxx_seq increment by 1 start with 1 nocycle cache 20 noorder;
-- Create sequence for non-existing concept_ids for extension concepts 
drop sequence extension_id;
create sequence extension_id increment by -1 start with -1 nocycle cache 20 noorder;


/*****************************
* 2. Collect atributes for q *
*****************************/

-- Create table with all drug concept codes linked to the codes of the ingredients (rather than full dose components)
drop table q_ing purge;
create table q_ing nologging as
  select c.concept_code as concept_code, i.concept_code as i_code
  from drug_concept_stage c
  join internal_relationship_stage r on r.concept_code_1=c.concept_code
  join drug_concept_stage i on i.concept_code=r.concept_code_2 and i.concept_class_id='Ingredient'
  where c.concept_class_id='Drug Product' and c.domain_id='Drug' -- Drug Products
union
  select drug_concept_code as concept_code, ingredient_concept_code as i_code from ds_stage -- just in case, won't hurt if the internal_relationship table forgot something
;

-- Create distinct version of drug_strength in concentration notation (no quant). 
-- Replace nulls with 0 and ' '

-- Create a rounded version of ds_stage
drop table ds_rounded purge;
create table ds_rounded nologging as
select 
  drug_concept_code, ingredient_concept_code,
  case amount_value when 0 then 0 else round(amount_value, 3-floor(log(10, amount_value))-1) end as amount_value, amount_unit,
  case numerator_value when 0 then 0 else round(numerator_value, 3-floor(log(10, numerator_value))-1) end as numerator_value, numerator_unit, 
  denominator_unit
from (
  select drug_concept_code, ingredient_concept_code, 
    nvl(amount_value, 0) as amount_value, nvl(amount_unit, ' ') as amount_unit, 
    case 
      when concept_id_2 in (8554, 9325, 9324) then numerator_value -- % and homeopathics is already a fixed concentration, no need to adjust to volume
      when nvl(numerator_value, 0)=0 then 0 
      else numerator_value/nvl(denominator_value, 1) -- turn into concentration as basis for comparison.
    end as numerator_value, 
    nvl(numerator_unit, ' ') as numerator_unit, 
    case -- denominator unit should be undefined for % and the homeopathics
      when concept_id_2 in (8554, 9325, 9324) then null -- % and homeopathics is already a fixed concentration, no need to adjust to volume
      else nvl(denominator_unit, ' ') 
    end as denominator_unit
  from ds_stage left join r_to_c on numerator_unit=concept_code_1 and nvl(precedence, 1)=1 -- to get the q version of % and homeopathics
)
;

-- Create unique dose table
drop table q_uds purge;
create table q_uds (
  ds_code integer not null,
  ingredient_concept_code varchar2(50) not null,
  amount_value number,
  amount_unit varchar2(50),
  numerator_value number,
  numerator_unit varchar2(50),
  denominator_unit varchar2(50)
) nologging;

/*
-- Check validity of ds_stage and force error if conventions are violated. Won't be necessary if strong QA
insert into q_uds (ds_code) 
select null from ds_stage-- force error as ds_code is not nullable
where coalesce(amount_value, numerator_value, 0)=0 -- needs to have at least one value, zeros don't count
or coalesce(amount_unit, numerator_unit) is null -- needs to have at least one unit
or (amount_value is not null and amount_unit is null) -- if there is an amount record, there must be a unit
or (nvl(numerator_value, 0)!=0 and coalesce(numerator_unit, denominator_unit) is null) -- if there is a concentration record there must be a unit in both numerator and denominator
or amount_unit='%' -- % should be in the numerator_unit
;
*/

insert /*+ APPEND */ into q_uds
select ds_seq.nextval as ds_code, q_ds.* from (
  select distinct ingredient_concept_code, amount_value, amount_unit, numerator_value, numerator_unit, denominator_unit
  from ds_rounded
) q_ds
;
commit;

-- Create table with all drug concept codes linked to the above unique components 
drop table q_ds purge;
create table q_ds nologging as
select drug_concept_code as concept_code, ingredient_concept_code as i_code, ds_code, d as quant_unit
-- nvl denominator so null can be matched with null for % and homeopathics
from (select drug_concept_code, ingredient_concept_code, amount_value, amount_unit, numerator_value, numerator_unit, nvl(denominator_unit, 'null') as d from ds_rounded)
join (
  select ds_code, ingredient_concept_code, amount_value, amount_unit, numerator_value, numerator_unit, nvl(denominator_unit, 'null') as d from q_uds 
) using(ingredient_concept_code, amount_value, amount_unit, numerator_value, numerator_unit, d)
;
create index idx_q_ds_dscode on q_ds (ds_code);
create index idx_q_ds_concode on q_ds (concept_code);

-- Turn gases into percent if they are in mg/mg or mg/mL
update q_uds set
  numerator_value=numerator_value*100,
  numerator_unit=(select concept_code_1 from r_to_c where concept_id_2=8554 and precedence=1), -- set to percent
  denominator_unit=null
where ds_code in (
  select q_uds.ds_code
  from internal_relationship_stage r 
  join r_to_c rc on rc.concept_code_1=r.concept_code_2
  join q_ds on q_ds.concept_code=r.concept_code_1
  join q_uds on q_uds.ds_code=q_ds.ds_code
  join r_to_c rn on rn.concept_code_1=numerator_unit and rn.precedence=1 -- translate to Standard for numerator
  join r_to_c rd on rd.concept_code_1=denominator_unit and rd.precedence=1 -- translate to Standard for denominator
  where rc.concept_id_2 in (19082258, 40228366) -- Gas for Inhalation, Gas
  and rn.concept_id_2=8576 and rd.concept_id_2=8576 -- mg and mg
)
;

update q_uds set
  numerator_value=numerator_value/10,
  numerator_unit=(select concept_code_1 from r_to_c where concept_id_2=8554 and precedence=1), -- set to percent
  denominator_unit=null
where ds_code in (
  select q_uds.ds_code
  from internal_relationship_stage r 
  join r_to_c rc on rc.concept_code_1=r.concept_code_2
  join q_ds on q_ds.concept_code=r.concept_code_1
  join q_uds on q_uds.ds_code=q_ds.ds_code
  join r_to_c rn on rn.concept_code_1=numerator_unit and rn.precedence=1 -- translate to Standard for numerator
  join r_to_c rd on rd.concept_code_1=denominator_unit and rd.precedence=1 -- translate to Standard for denominator
  where rc.concept_id_2 in (19082258, 40228366) -- Gas for Inhalation, Gas
  and rn.concept_id_2=8576 and rd.concept_id_2=8587 -- mg and mL
)
;

-- Create table with the combination of components for each drug concept delimited by '-'
-- Contains both ingredient combos and ds combos. For Drug Comps d_combo=' '
drop table q_combo purge;
create table q_combo as
select distinct concept_code, 
  listagg(i_code, '-') within group (order by i_code) as i_combo,
  listagg(ds_code, '-') within group (order by ds_code) as d_combo
from q_ds
group by concept_code
;
commit;

-- Add Drug Forms, which have no entry in ds_stage. Shouldn't exist, unless there are singleton Drug Forms with no descendants.
insert /*+ APPEND */ into q_combo
select * from (
  select concept_code, 
    listagg(i_code, '-') within group (order by i_code) as i_combo,
    ' ' as d_combo
  from ( -- build the i_combos from scratch, no equivalent to q_ds
    select d.concept_code, i.concept_code as i_code
    from drug_concept_stage d
    join internal_relationship_stage r on r.concept_code_1=d.concept_code
    join drug_concept_stage i on i.concept_code=r.concept_code_2 and i.concept_class_id='Ingredient'
    where d.concept_code in (
      select concept_code from drug_concept_stage where domain_id='Drug' and concept_class_id='Drug Product'
      minus
      select drug_concept_code from ds_stage
    )
  )
  group by concept_code
)
where concept_code not in (select concept_code from q_combo)
;
create index idx_q_combo on q_combo (d_combo);
commit;

-- Create table with Quantity Factor information for each drug (if exists), not rounded
drop table q_quant purge;
create table q_quant nologging as
select distinct drug_concept_code as concept_code, 
  round(denominator_value, 3-floor(log(10, denominator_value))-1) as value, -- round quant value
  denominator_unit as unit
from ds_stage
where denominator_value is not null and denominator_value!=0 and numerator_value is not null and numerator_value!=0
;

-- Create table with Dose Form information for each drug (if exists)
drop table q_df purge;
create table q_df nologging as
select distinct ir.concept_code_1 as concept_code, f.concept_code as df_code -- distinct only because source may contain duplicated maps
from internal_relationship_stage ir
join drug_concept_stage f on f.concept_code=ir.concept_code_2 and f.concept_class_id='Dose Form' and f.domain_id='Drug' -- Dose Form of a drug
;

-- Create table with Brand Name information for each drug including packs (if exists)
drop table q_bn purge;
create table q_bn nologging as
select distinct ir.concept_code_1 as concept_code, b.concept_code as bn_code -- distinct only because source contains duplicated maps
from internal_relationship_stage ir
join drug_concept_stage b on b.concept_code=ir.concept_code_2 and b.concept_class_id='Brand Name' and b.domain_id='Drug' -- Brand Name of a drug
;

-- Create table with Suppliers (manufacturers) including packs
drop table q_mf purge;
create table q_mf nologging as
select irs.concept_code_1 as concept_code, irs.concept_code_2 as mf_code from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_2=dcs.concept_code
where dcs.concept_class_id='Supplier'
;

-- Create table with Box Size information 
drop table q_bs purge;
create table q_bs nologging as
select distinct drug_concept_code as concept_code, box_size as bs
from ds_stage where box_size is not null
;

/**************************************************************************
* 5. Create the list of all all existing q products in attribute notation * 
***************************************************************************/

-- Duplication rule 1: More than one definition per concept_code is illegal
-- Duplication rule 2: More than one concept_code per definition is allowed. 

-- Collect all input drugs and create master matrix, including assignment of concept_classes
drop table existing_q purge;
create table existing_q nologging as
-- Marketed Product
  select distinct 
    c.concept_code, nvl(q_quant.value,0) as quant_value, nvl(q_quant.unit, ' ') as quant_unit, c.i_combo, c.d_combo, nvl(q_df.df_code,' ') as df_code,
     nvl(q_bn.bn_code,' ') as bn_code, nvl(q_bs.bs,0) as bs, q_mf.mf_code as mf_code,
    'Marketed Product' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code 
  join q_mf q_mf on q_mf.concept_code=c.concept_code 
  left join q_quant on q_quant.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code
  where c.d_combo!=' '
union
-- Quant Branded Box
  select distinct 
    c.concept_code, q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, q_bs.bs, ' ' as mf_code,
    'Quant Branded Box' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where c.d_combo!=' ' and q_mf.mf_code is null
union
-- Quant Clinical Box
  select distinct 
    c.concept_code, q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, q_bs.bs, ' ' as mf_code,
    'Quant Clinical Box' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where c.d_combo!=' ' and q_bn.concept_code is null and q_mf.mf_code is null
union
-- Branded Drug Box
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, q_bs.bs, ' ' as mf_code,
    'Branded Drug Box' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where q_quant.concept_code is null and c.d_combo!=' ' and q_mf.mf_code is null
union
-- Clinical Drug Box
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, q_bs.bs, ' ' as mf_code,
    'Clinical Drug Box' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where q_quant.concept_code is null and c.d_combo!=' ' and q_bn.concept_code is null and q_mf.mf_code is null
union
-- Quant Branded Drug
  select distinct 
    c.concept_code, q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Quant Branded Drug' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where c.d_combo!=' ' and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Quant Clinical Drug
  select distinct 
    c.concept_code, q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Quant Clinical Drug' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where c.d_combo!=' ' and q_bn.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Branded Drug
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo!=' ' and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Clinical Drug
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo!=' ' and q_bn.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Branded Drug Form
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug Form' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo=' ' and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Clinical Drug Form
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug Form' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo=' ' and q_bn.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Branded Drug Component
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, ' ' as df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug Comp' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  left join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo!=' ' and q_df.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null -- denominator_value is ignored
union
-- Clinical Drug Component 
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, ' ' as df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug Comp' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  left join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo!=' ' and q_df.concept_code is null and q_bn.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null 
;

/************************************************************************************************
* 6. Write full corpus from q, whether existing in source or not from all possible combinations *
*************************************************************************************************/

/*
drop table complete_q purge;
create table complete_q nologging as
select 'XXX'||xxx_seq.nextval as concept_code, -- make sure xxx_seq is defined.
  c.*
from (
-- Marketed Product
  select distinct 
    nvl(q_quant.value, 0) as quant_value, nvl(q_quant.unit, ' ') as quant_unit, c.i_combo, c.d_combo, nvl(q_df.df_code, ' ') as df_code, 
      nvl(q_bn.bn_code, ' ') as bn_code, nvl(q_bs.bs, 0) as bs, q_mf.mf_code,
    'Marketed Product' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code 
  join q_mf q_mf on q_mf.concept_code=c.concept_code 
-- Marketed Product is the only one where these may or may not be defined, hence left joins
  left join q_quant on q_quant.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Quant Branded Box
  select distinct 
    q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, q_bs.bs, ' ' as mf_code,
    'Quant Branded Box' as concept_class_id
  from q_combo c 
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  where c.d_combo!=' ' 
union
-- Quant Clinical Box
  select distinct 
    q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, q_bs.bs, ' ' as mf_code,
    'Quant Clinical Box' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  where c.d_combo!=' ' 
union
-- Branded Drug Box
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, q_bs.bs, ' ' as mf_code,
    'Branded Drug Box' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  where c.d_combo!=' ' 
union
-- Clinical Drug Box
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, q_bs.bs, ' ' as mf_code,
    'Clinical Drug Box' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  where c.d_combo!=' ' 
union
-- Quant Branded Drug
  select distinct 
    q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Quant Branded Drug' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Quant Clinical Drug
  select distinct 
    q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Quant Clinical Drug' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Branded Drug
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Clinical Drug
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Branded Drug Form
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, ' ' as d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug Form' as concept_class_id
  from q_combo c -- i_combo is not unique, but the union will remove the duplicates because concept_code is not maintained
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
union
-- Clinical Drug Form
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, ' ' as d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug Form' as concept_class_id
  from q_combo c 
  join q_df on q_df.concept_code=c.concept_code
--  where c.d_combo=' ' -- XXXX check whether i_combos have to be separate from d_combos
union
-- Branded Drug Component
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, ' ' as df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug Comp' as concept_class_id
  from q_combo c
  join q_bn on q_bn.concept_code=c.concept_code
--  where c.d_combo!=' ' -- XXXX check whether i_combos have to be separate from d_combos
union
-- Clinical Drug Component - they are unique per ingredients
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.ingredient_concept_code as i_combo, cast(c.ds_code as varchar(20)) as d_combo, ' ' as df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug Comp' as concept_class_id
  from q_uds c
) c
;
create index idx_cq_concode on complete_q (concept_code);
create index idx_cq_d_combo on complete_q (d_combo);

-- Create equivalence between existing_q and future RxNorm Extension (complete_q)
drop table existing_to_complete purge;
create table existing_to_complete nologging as
select e.concept_code as e_code, c.concept_code as c_code
from existing_q e
join complete_q c using(quant_value, quant_unit, i_combo, d_combo, df_code, bn_code, bs, mf_code)
;
commit;
*/

/******************************
* 3. Collect atributes for r  *
******************************/
-- Create xxx-type codes for r ingredients, so we can add them
drop table ing_stage purge;
create table ing_stage as
select 'XXX'||xxx_seq.nextval as i_code, i_id from (
  select concept_id as i_id from concept where vocabulary_id in ('RxNorm', 'RxNorm Extension') and concept_class_id='Ingredient'
);

-- Create table with all drug concepts linked to the codes of the ingredients (rather than full dose components)
drop table r_ing purge;
create table r_ing nologging as
select * from (
  select de.concept_id as concept_id, an.concept_id as i_id
  from concept_ancestor a 
  join concept an on a.ancestor_concept_id=an.concept_id and an.vocabulary_id in ('RxNorm', 'RxNorm Extension') and an.concept_class_id='Ingredient'
  join concept de on de.concept_id=a.descendant_concept_id and de.vocabulary_id in ('RxNorm', 'RxNorm Extension') and de.concept_class_id not in ('Ingredient', 'Clinical Dose Group', 'Branded Dose Group')
union
  select drug_concept_id as concept_id, ingredient_concept_id as i_id from drug_strength -- just in case, won't hurt if the internal_relationship table forgot something
join concept r on r.concept_id=drug_concept_id and r.vocabulary_id in ('RxNorm', 'RxNorm Extension')
  where drug_concept_id!=ingredient_concept_id -- in future, ingredients will also have records, where drug and ingredient ids are the same
)
join ing_stage using(i_id)
;

-- Create table with unique dosages 
drop table r_uds purge;
create table r_uds nologging as
select ds_seq.nextval as ds_code, ds.* from ( -- reuse the same sequence for q_ds and r_ds
  select distinct
    i_code, -- use internal codes instead of concept id, so new ones can be added later.
    ingredient_concept_id, -- still keep it for faster creation of r_ds, but don't use it otherwise
    nvl(amount_value, 0) as amount_value, nvl(amount_unit_concept_id, 0) as amount_unit_concept_id,
    case -- turn into concentration mode
      when numerator_unit_concept_id in (8554, 9325, 9324) then nvl(numerator_value, 0) -- don't for % and homeopathic units C, X
      else nvl(numerator_value, 0)/nvl(denominator_value, 1)
    end as numerator_value, 
    nvl(numerator_unit_concept_id, 0) as numerator_unit_concept_id,
    case -- % and homeopathics should not have an undefined denominator_unit. r_quant will get it from ds_stage.
      when numerator_unit_concept_id in (8554, 9325, 9324) then null
      else nvl(denominator_unit_concept_id, 0) 
    end as denominator_unit_concept_id
  from drug_strength join ing_stage on ingredient_concept_id=i_id
join concept r on r.concept_id=drug_concept_id and r.vocabulary_id in ('RxNorm', 'RxNorm Extension')
) ds
;

-- Create table with all drug concept codes linked to the above unique components 
drop table r_ds purge;
create table r_ds nologging as 
select ds.drug_concept_id as concept_id, uds.i_code, uds.ds_code, uds.denominator_unit_concept_id as quant_unit_id
from (
  select drug_concept_id, ingredient_concept_id, i_code, nvl(amount_value, 0) as amount_value, nvl(amount_unit_concept_id, 0) as amount_unit_concept_id, 
    case -- turn into concentration mode
      when numerator_unit_concept_id in (8554, 9325, 9324) then nvl(numerator_value, 0) -- don't for % and homeopathic units C, X
      else nvl(numerator_value, 0)/nvl(denominator_value, 1)
    end as numerator_value, 
    nvl(numerator_unit_concept_id, 0) as numerator_unit_concept_id, 
    case -- % and homeopathics should not have an undefined denominator_unit. r_quant will get it from ds_stage.
      when numerator_unit_concept_id in (8554, 9325, 9324) then null
      else nvl(denominator_unit_concept_id, 0) 
    end as denominator_unit_concept_id
  from drug_strength join ing_stage on ingredient_concept_id=i_id
join concept r on r.concept_id=drug_concept_id and r.vocabulary_id in ('RxNorm', 'RxNorm Extension')
  and r.concept_class_id not in ('Ingredient', 'Clinical Drug Form', 'Branded Drug Form')
) ds 
join r_uds uds using(ingredient_concept_id, amount_value, amount_unit_concept_id, numerator_value, numerator_unit_concept_id)
where nvl(ds.denominator_unit_concept_id, -1)=nvl(uds.denominator_unit_concept_id, -1) -- match nulls for % and homeopathics
;
create index idx_r_ds_dscode on r_ds (ds_code);
create index idx_r_ds_concode on q_ds (concept_code);

-- Create table with the combination of ds components for each drug concept delimited by '-'
-- Add corresponding ingredient combos
drop table r_combo purge;
create table r_combo as
select distinct concept_id, 
  listagg(i_code, '-') within group (order by i_code) as i_combo,
  listagg(ds_code, '-') within group (order by ds_code) as d_combo
from r_ds
group by concept_id
;
commit;

-- Add Drug Forms, which have no entry in ds_stage. 
insert /*+ APPEND */ into r_combo
select * from (
  select distinct 
    concept_id, 
    listagg(i_code, '-') within group (order by i_code) as i_combo,
    ' ' as d_combo
  from r_ing
  group by concept_id
) i
where not exists (
  select 1 from r_combo r where r.concept_id=i.concept_id
)
;
create index idx_r_combo on r_combo (d_combo);
commit;

-- Create table with Quantity Factor information for each drug (if exists), not rounded
drop table r_quant purge;
create table r_quant nologging as
select distinct drug_concept_id as concept_id, denominator_value as value, denominator_unit_concept_id as unit_id
from drug_strength
join concept on concept_id=drug_concept_id and vocabulary_id in ('RxNorm', 'RxNorm Extension')
where denominator_value is not null and numerator_value is not null and drug_concept_id!=ingredient_concept_id
;

-- Create table with Dose Form information for each drug (if exists)
drop table r_df purge;
create table r_df nologging as
select r.concept_id_1 as concept_id, r.concept_id_2 as df_id from concept_relationship r
join concept d on d.concept_id=r.concept_id_1 and d.vocabulary_id in ('RxNorm', 'RxNorm Extension') and d.standard_concept='S'
join concept f on f.concept_id=r.concept_id_2 and f.concept_class_id ='Dose Form' and f.invalid_reason is null
where r.invalid_reason is null and r.relationship_id='RxNorm has dose form'
;

-- Create table with Brand Name information for each drug (if exists)
drop table r_bn purge;
create table r_bn nologging as
select r.concept_id_1 as concept_id, r.concept_id_2 as bn_id from concept_relationship r
join concept d on d.concept_id=r.concept_id_1 and d.vocabulary_id in ('RxNorm', 'RxNorm Extension') and d.standard_concept='S'
join concept f on f.concept_id=r.concept_id_2 and f.concept_class_id ='Brand Name' and f.invalid_reason is null
where r.invalid_reason is null and r.relationship_id='Has brand name'
;

-- Create table with Suppliers (manufacturers)
drop table r_mf purge;
create table r_mf nologging as
select r.concept_id_1 as concept_id, r.concept_id_2 as mf_id from concept_relationship r
join concept d on d.concept_id=r.concept_id_1 and d.vocabulary_id in ('RxNorm', 'RxNorm Extension') and d.standard_concept='S'
join concept f on f.concept_id=r.concept_id_2 and f.concept_class_id ='Supplier' and f.invalid_reason is null
where r.invalid_reason is null and r.relationship_id='Has supplier';

-- Create table with Box Size information 
drop table r_bs purge;
create table r_bs nologging as
select distinct drug_concept_id as concept_id, box_size as bs
from drug_strength 
join concept d on d.concept_id=drug_concept_id and d.vocabulary_id in ('RxNorm', 'RxNorm Extension') -- XXXX remove aftr DPD is gone
where box_size is not null
;

/**************************************************************************
* 7. Create the list of all all existing r products in attribute notation * 
***************************************************************************/

drop table existing_r purge;
create table existing_r nologging as
-- Marketed Product
  select distinct 
    c.concept_id, nvl(r_quant.value,0) as quant_value, nvl(r_quant.unit_id, 0) as quant_unit_id, c.i_combo, c.d_combo, nvl(r_df.df_id,0) as df_id,
     nvl(r_bn.bn_id,0) as bn_id, nvl(r_bs.bs,0) as bs, r_mf.mf_id as mf_id,
    'Marketed Product' as concept_class_id
  from r_combo c
  join r_df on r_df.concept_id=c.concept_id 
  join r_mf r_mf on r_mf.concept_id=c.concept_id 
  left join r_quant on r_quant.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id
  where c.d_combo!=' '
union
-- Quant Branded Box
  select distinct 
    c.concept_id, r_quant.value as quant_value, r_quant.unit_id as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, r_bn.bn_id, r_bs.bs, 0 as mf_id,
    'Quant Branded Box' as concept_class_id
  from r_combo c
  join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  join r_bs on r_bs.concept_id=c.concept_id
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where c.d_combo!=' ' and r_mf.mf_id is null
union
-- Quant Clinical Box
  select distinct 
    c.concept_id, r_quant.value as quant_value, r_quant.unit_id as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, 0 as bn_id, r_bs.bs, 0 as mf_id,
    'Quant Clinical Box' as concept_class_id
  from r_combo c
  join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  join r_bs on r_bs.concept_id=c.concept_id
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where c.d_combo!=' ' and r_bn.concept_id is null and r_mf.mf_id is null
union
-- Branded Drug Box
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, r_bn.bn_id, r_bs.bs, 0 as mf_id,
    'Branded Drug Box' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where r_quant.concept_id is null and c.d_combo!=' ' and r_mf.mf_id is null
union
-- Clinical Drug Box
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, 0 as bn_id, r_bs.bs, 0 as mf_id,
    'Clinical Drug Box' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where r_quant.concept_id is null and c.d_combo!=' ' and r_bn.concept_id is null and r_mf.mf_id is null
union
-- Quant Branded Drug
  select distinct 
    c.concept_id, r_quant.value as quant_value, r_quant.unit_id as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, r_bn.bn_id, 0 as bs, 0 as mf_id,
    'Quant Branded Drug' as concept_class_id
  from r_combo c
  join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where r_bs.concept_id is null and c.d_combo!=' ' and r_mf.mf_id is null
union
-- Quant Clinical Drug
  select distinct 
    c.concept_id, r_quant.value as quant_value, r_quant.unit_id as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, 0 as bn_id, 0 as bs, 0 as mf_id,
    'Quant Clinical Drug' as concept_class_id
  from r_combo c
  join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_bn.concept_id is null and c.d_combo!=' ' and r_bs.concept_id is null and r_mf.mf_id is null
union
-- Branded Drug
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, r_bn.bn_id, 0 as bs, 0 as mf_id,
    'Branded Drug' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo!=' ' and r_bs.concept_id is null AND r_mf.mf_id is null
union
-- Clinical Drug
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, 0 as bn_id, 0 as bs, 0 as mf_id,
    'Clinical Drug' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo!=' ' and r_bn.concept_id is null and r_bs.concept_id is null and r_mf.mf_id is null
union
-- Branded Drug Form
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, ' ' as d_combo, r_df.df_id, r_bn.bn_id, 0 as bs, 0 as mf_id,
    'Branded Drug Form' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo=' ' and r_bs.concept_id is null and r_mf.mf_id is null
union
-- Clinical Drug Form
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, ' ' as d_combo, r_df.df_id, 0 as bn_id, 0 as bs, 0 as mf_id,
    'Clinical Drug Form' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo=' ' -- and r_bn.concept_id is null and r_bs.concept_id is null and r_mf.mf_id is null
union
-- Branded Drug Component
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, 0 as df_id, r_bn.bn_id, 0 as bs, 0 as mf_id,
    'Branded Drug Comp' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  left join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo!=' ' and r_df.concept_id is null and r_bs.concept_id is null and r_mf.mf_id is null -- denominator_value is ignored
union
-- Clinical Drug Component 
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, 0 as df_id, 0 as bn_id, 0 as bs, 0 as mf_id,
    'Clinical Drug Comp' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  left join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo!=' ' and r_df.concept_id is null and r_bn.concept_id is null and r_bs.concept_id is null and r_mf.mf_id is null 
;

-- RxNorm has duplicates by attributes. Usually Ingredient and Precise Ingredient versions of the same drug. The Precise tends to be newer. This query picks the newest
delete from existing_r where rowid in (
  select rowid from (
    select e.rowid, c.concept_name, first_value(c.concept_name) over (partition by quant_value, quant_unit_id, i_combo, d_combo, df_id, bn_id, bs, mf_id order by valid_start_date desc) as newest
    from existing_r e join concept c using(concept_id)
  ) where concept_name!=newest
)
;
commit;

/************************************************************************************************
* 4. Create translation tables between q and r attributes with corridors, all starting with qr_ *
************************************************************************************************/

-- Create translation between q_uds and r_uds for everything in the 90% corridor and unit and ingredient closeness attributes
drop table qr_uds purge;
create table qr_uds as
select q_ds, r_ds, u_prec, i_prec,
  case when div>1 then 1/div else div end as div,
  quant_unit, quant_unit_id
from (
-- Standard case where all units are identical after conversion, except %
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec,
    case
      when q.amount_value!=0 and r.amount_value!=0 then q.amount_value/r.amount_value
      when q.numerator_value!=0 and r.numerator_value!=0 then q.numerator_value/r.numerator_value -- the standard case
    else 0 end as div,
    quant_unit, denominator_unit_concept_id as quant_unit_id
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      amount_value*nvl(q_ds_a.conversion_factor, 1) as amount_value, 
      nvl(q_ds_a.concept_id_2, 0) as amount_unit_concept_id, 
      numerator_value*nvl(q_ds_n.conversion_factor, 1)/nvl(q_ds_d.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_d.concept_id_2, 0) as denominator_unit_concept_id,
      coalesce(q_ds_a.precedence, (q_ds_n.precedence+q_ds_d.precedence)/2, 100) as u_prec, -- numerator unit precedence, or average of concentration precedences, or 100 (non-desirable conversion, missing conversion)
      denominator_unit as quant_unit -- when homeopathic potentiation the denominator is undefined
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_a on q_ds_a.concept_code_1=amount_unit -- amount units
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator units
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator units
  ) q
  join r_uds r using(ingredient_concept_id, amount_unit_concept_id, numerator_unit_concept_id, denominator_unit_concept_id) -- join q and r on the ingredient and all the units
  where numerator_unit_concept_id!=8554 -- %
union
-- % vs %
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec,
    q.numerator_value/r.numerator_value as div,
    null as quant_unit, null as quant_unit_id -- which is not defined, really, for situations like "10 mL oxygen 90%" to "10 mL oxygen 0.9 mL/mL", because the former has no denominator_unit. 
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      numerator_value*q_ds_n.conversion_factor as numerator_value, 
      8554 as numerator_unit_concept_id,
      nvl(q_ds_n.precedence, 100) as u_prec -- numerator unit precedence, or 100 (non-desirable conversion, missing conversion)
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator unit conversion
    where q_ds_n.concept_id_2=8554 -- %
  ) q
  join r_uds r on q.ingredient_concept_id=r.ingredient_concept_id and r.numerator_unit_concept_id=8554 -- %
union
-- % vs mg/mL
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec,
    q.numerator_value/r.numerator_value*10 as div,
    null quant_unit, 8587 as quant_unit_id
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      numerator_value*nvl(q_ds_n.conversion_factor, 1)/nvl(q_ds_d.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_n.precedence, 100) as u_prec -- numerator unit precedence, or 100 (non-desirable conversion, missing conversion)
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator unit conversion
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator unit conversion
  ) q
  join r_uds r on q.ingredient_concept_id=r.ingredient_concept_id and r.numerator_unit_concept_id=8576 and r.denominator_unit_concept_id=8587 -- mg/mL
  where q.numerator_unit_concept_id=8554 -- %
union
-- mg/mL vs %
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec,
    q.numerator_value/r.numerator_value/10 as div,
    quant_unit, null as quant_unit_id
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      numerator_value*nvl(q_ds_n.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_d.concept_id_2, 0) as denominator_unit_concept_id,
      nvl((q_ds_n.precedence+q_ds_n.precedence)/2, 100) as u_prec, -- numerator unit precedence, or 100 (non-desirable conversion, missing conversion)
      denominator_unit as quant_unit
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator unit conversion
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator unit conversion
    where q_uds.amount_unit=' ' -- redundant with clause below that numerator/denominator=mg/mL, but faster to limit here
  ) q
  join r_uds r on q.ingredient_concept_id=r.ingredient_concept_id and r.numerator_unit_concept_id=8554 -- %
  where q.numerator_unit_concept_id=8576 and q.denominator_unit_concept_id=8587  -- mg/mL
union
-- mg/mg etc. vs %
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec, 
    q.numerator_value/r.numerator_value*100 as div,
    quant_unit, null as quant_unit_id
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      numerator_value*nvl(q_ds_n.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_d.concept_id_2, 0) as denominator_unit_concept_id,
      nvl((q_ds_n.precedence+q_ds_n.precedence)/2, 100) as u_prec, -- numerator unit precedence, or 100 (non-desirable conversion, missing conversion)
      denominator_unit as quant_unit
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator unit conversion
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator unit conversion
    where q_uds.amount_unit=' ' 
  ) q
  join r_uds r on q.ingredient_concept_id=r.ingredient_concept_id and r.numerator_unit_concept_id=8554 -- %
  where q.numerator_unit_concept_id=q.denominator_unit_concept_id -- mg/mg, mL/mL etc.
union
-- % vs mg/mg etc.
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec,
    q.numerator_value/r.numerator_value/100 as div,
    null as quant_unit, r.denominator_unit_concept_id as quant_unit_id
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      numerator_value*nvl(q_ds_n.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_d.concept_id_2, 0) as denominator_unit_concept_id,
      nvl((q_ds_n.precedence+q_ds_n.precedence)/2, 100) as u_prec -- numerator unit precedence, or 100 (non-desirable conversion, missing conversion)
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator unit conversion
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator unit conversion
    where q_uds.amount_unit=' ' 
  ) q
  join r_uds r on q.ingredient_concept_id=r.ingredient_concept_id and r.numerator_unit_concept_id=r.denominator_unit_concept_id and r.amount_unit_concept_id=0-- mg/mg, mL/mL etc.
  where q.numerator_unit_concept_id=8554 -- %
)
where div>0.9 and 1/div>0.9 -- find identicals only within a corridor of 90% deviation
;

-- Remove duplicate q-r_uds combos that can result from % (two units mapped into one) or due to duplicate unit mapping with different preferences
-- The former will happen likely, the latter only if the input files are corrupt
delete from qr_uds where rowid not in (
  select first_value(rowid) over (partition by q_ds, r_ds order by u_prec, i_prec, div desc) from qr_uds
);
commit;

-- Create all possible translations for combos and their closeness attributes
drop table qr_d_combo purge;
create table qr_d_combo as
-- Create unique list of combo codes and ds components for both q and r
with q as (
  select distinct d_combo, i_combo, ds_code, quant_unit
  from q_combo
  join q_ds using(concept_code)
), r as (
  select distinct d_combo, i_combo, ds_code, quant_unit_id
  from r_combo
  join r_ds using(concept_id)
), 
-- Create all combinations of combos that share at least one ds, and calculate their size of the combos
q_to_r as (
  select qc.i_combo as qi_combo, qc.d_combo as qd_combo, q_ds, rc.i_combo as ri_combo, rc.d_combo as rd_combo, r_ds, u_prec, i_prec, div, qc.cnt, qr_uds.quant_unit, qr_uds.quant_unit_id
  from qr_uds 
-- Create q and the number of ds components
  join (
    select * from (select d_combo, count(8) as cnt from q group by d_combo having count(8)>1) join q using(d_combo)
  ) qc on qc.ds_code=q_ds
-- Same for r
  join (
    select * from (select d_combo, count(8) as cnt from r group by d_combo having count(8)>1) join r using(d_combo)
  ) rc on rc.ds_code=r_ds and qc.cnt=rc.cnt -- join q to r through qr_uds, and also the size of hte combos
)
-- Now filter those where the size of the q and r combos (already the same) is the same as the number of qr_uds matches between the combos
select qi_combo, ri_combo, qd_combo, rd_combo, u_prec, i_prec, div, quant_unit, quant_unit_id from (
  select qi_combo, ri_combo, qd_combo, rd_combo, cnt, avg(u_prec) as u_prec, avg(i_prec) as i_prec, avg(div) as div, 
    max(quant_unit) as quant_unit, max(quant_unit_id) as quant_unit_id -- for successful matches, calculate aggregate u_prec, i_prec and div
  from (select qi_combo, ri_combo, qd_combo, rd_combo, count(8) as cnt from q_to_r group by qi_combo, ri_combo, qd_combo, rd_combo) join q_to_r using(qi_combo, ri_combo, qd_combo, rd_combo, cnt)
  group by qi_combo, ri_combo, qd_combo, rd_combo, cnt
)
;

-- Add singleton combos from qr_uds. Some of them will be necessary as they don't exist as singletons in q, but x_i_combo will need them for translating ingredient combos in Forms
insert /*+ APPEND */ into qr_d_combo 
select distinct
  q_uds.ingredient_concept_code as qi_combo,
  r_uds.i_code as ri_combo,
  cast(q_uds.ds_code as varchar2(200)) as qd_combo,
  cast(r_uds.ds_code as varchar2(200)) as rd_combo,
  u_prec, i_prec, div, 
  quant_unit, quant_unit_id
from qr_uds join q_uds on q_uds.ds_code=q_ds join r_uds on r_uds.ds_code=r_ds
;
commit;

-- Same for ingredient combinations only (used for Drug Forms)
drop table qr_i_combo purge;
create table qr_i_combo as
-- Add translations of ingredient combos only (where there are no matching ds)
with q as (
  select distinct i_combo, i_code
  from q_combo
  join q_ing using(concept_code) 
), r as (
  select distinct i_combo, i_code
  from r_combo
  join r_ing using(concept_id)
), 
-- Create all combinations of combos that share at least one ing, and calculate their size of the combos
q_to_r as (
  select qc.i_combo as q_combo, q_ing, rc.i_combo as r_combo, r_ing, i_prec, qc.cnt
  from ( -- create a combination of all possible ingredient to ingredient maps
    select distinct q_ing.i_code as q_ing, precedence as i_prec, r_ing.i_code as r_ing
    from q_ing join r_to_c on q_ing.i_code=concept_code_1 join r_ing on i_id=concept_id_2
  )
-- Create q and the number of ds components
  join (
    select * from (select i_combo, count(8) as cnt from q group by i_combo) join q using(i_combo)
  ) qc on qc.i_code=q_ing
-- Same for r
  join (
    select * from (select i_combo, count(8) as cnt from r group by i_combo) join r using(i_combo)
  ) rc on rc.i_code=r_ing and qc.cnt=rc.cnt -- join q to r through q_to_r_uds, and also the size of the combos
)
-- Now filter those where the size of the q and r combos (already the same) is the same as the number of q_to_r_uds matches between the combos
select 
  q_combo as qi_combo, r_combo as ri_combo, 
  cnt, avg(i_prec) as i_prec  -- for successful matches, calculate aggregate i_prec
from (select q_combo, r_combo, count(8) as cnt from q_to_r group by q_combo, r_combo) join q_to_r using(q_combo, r_combo, cnt)
group by q_combo, r_combo, cnt
;

-- Create translations between quants. Value and unit have to work in tandem
drop table qr_quant purge;
create table qr_quant as
select * from (
  select q.value as q_value, q.unit as quant_unit, r.value as r_value, r.unit_id as quant_unit_id, precedence as prec, q.value*nvl(conversion_factor, 1)/r.value as q_div 
  from (
    select distinct value, unit from q_quant
  ) q
  join r_to_c on concept_code_1=q.unit
  join (
    select distinct value, unit_id from r_quant
  ) r on concept_id_2=r.unit_id 
)
where round(q_div*50)=50 -- making it a 2% corridor
;

-- Translation between individual Ingredients
drop table qr_i purge;
create table qr_i as
select q.i_code as qi_code, r.i_code as ri_code, precedence as prec
from (
  select distinct i_code from q_ing
) q
join r_to_c on concept_code_1=q.i_code
join (
  select distinct i_id, i_code from r_ing
) r on concept_id_2=r.i_id 
;

-- Translation between Dose Forms
drop table qr_df purge;
create table qr_df as
select q.df_code, r.df_id, precedence as df_prec
from (
  select distinct df_code from q_df
) q
join r_to_c on concept_code_1=q.df_code
join (
  select distinct df_id from r_df
) r on concept_id_2=r.df_id 
;

-- Translation between Dose Forms
drop table qr_bn purge;
create table qr_bn as
select q.bn_code, r.bn_id, precedence as bn_prec
from ( -- limit to brand names in q
  select distinct bn_code from q_bn
) q
join r_to_c on concept_code_1=q.bn_code
join ( -- limit to brand names in r
  select distinct bn_id from r_bn
) r on concept_id_2=r.bn_id 
;

-- Translation between Dose Forms
drop table qr_mf purge;
create table qr_mf as
select q.mf_code, r.mf_id, precedence as mf_prec
from ( -- limit to supplier in q
  select distinct mf_code from q_mf
) q
join r_to_c on concept_code_1=q.mf_code
join ( -- limit to supplier in r
  select distinct mf_id from r_mf
) r on concept_id_2=r.mf_id 
;

-- No need for translating box sizes 

/*************************************************************************
* 8. Compare new drug vocabulary q to existing one r and create patterns *
*************************************************************************/
-- Strategy: Find the optimal match for a varying number of existing component matches: d_combo/i_combo, df, bn and mf
-- Don't worry about duplication or conflicts. The actual matching of complete q to r will go top down and pull in incomplete patterns if they haven't been found yet

-- Prep dose form groups (with some additions for RxNorm Extension) as a way to stratify drug_strength translation within such group
drop table dfg purge;
create table dfg as
select df.concept_id as df_id, nvl(dfg.concept_id_2, concept_id) as dfg_id -- not all of them have a DFG, they stand for themselves
from concept df
left join (
  select concept_id_1, concept_id_2, concept_name from devv5.concept_relationship -- and r.invalid_reason is null -- XXXX reinstate invalid_reason after Timur is done with rxnorm/load_stage, remove devv5
  join concept on concept_id=concept_id_2 and vocabulary_id in ('RxNorm', 'RxNorm Extension') and concept_class_id='Dose Form Group'
union
  select 43126086, 36217219, 'Drug Implant Product' from dual -- Intrauterine System
union
  select 21014175, 36217219, 'Drug Implant Product' from dual -- Intrauterine device
union
  select 43563502, 36217218, 'Ophthalmic Product' from dual -- Intravitreal Applicator
union
  select 43126087, 36217206, 'Topical Product' from dual -- Medicated Nail Polish
union
  select 21014177, 36217206, 'Topical Product' from dual -- Medicated nail lacquer
union
  select 43563498, 36217213, 'Nasal Product' from dual -- Nasal Pin
union
  select 19129401, 36217206, 'Topical Product' from dual -- Ointment
union
  select 21014169, 36217206, 'Topical Product' from dual -- Paint
union
  select 21014176, 36217206, 'Topical Product' from dual -- Poultice
union
  select 43563504, 36217215, 'Dental Product' from dual --	Dental Pin
union
  select 21014171, 36217215, 'Dental Product' from dual -- Dental insert
union
  select 19082079, -1, 'Made-up extended release oral produt' from dual -- Extended Release Oral Tablet
union
  select 19082077, -1, 'Made-up extended release oral produt' from dual -- Extended Release Oral Capsule
union
  select 19001949, -1, 'Made-up extended release oral produt' from dual -- Delayed Release Oral Tablet
union
  select 19082255, -1, 'Made-up extended release oral produt' from dual -- Delayed Release Oral Capsule
union
  select 19082072, 36244042, 'Transdermal System' from dual -- 72 Hour Transdermal Patch
union
  select 19082073, 36244042, 'Transdermal System' from dual -- Biweekly Transdermal Patch
union
  select 19082252, 36244042, 'Transdermal System' from dual -- Weekly Transdermal Patch
union
  select 19082229, 36244042, 'Transdermal System' from dual -- Transdermal System
union
  select 19082049, 36244042, 'Transdermal System' from dual -- 16 Hour Transdermal Patch
union
  select 19082071, 36244042, 'Transdermal System' from dual -- 24 Hour Transdermal Patch
union
  select 42629089, 36244042, 'Transdermal System' from dual -- Medicated Patch
union
  select 19130307, 36244042, 'Transdermal System' from dual -- Medicated Pad
union
  select 19130329, 36244042, 'Transdermal System' from dual -- Medicated Tape
union
  select 19082701, 36244042, 'Transdermal System' from dual -- Patch
union
  select 46275062, -2, 'Made-up device injector' from dual -- Jet Injector
union
  select 46234468, -2, 'Made-up device injector' from dual -- Cartridge
union
  select 46234467, -2, 'Made-up device injector' from dual -- Pen Injector
union
  select 46234466, -2, 'Made-up device injector' from dual -- Auto-Injector 
union
  select 19000942, -3, 'Suppository Product' from dual -- Suppository  
union
  select 19082200, -3, 'Suppository Product' from dual -- Rectal Suppository
) dfg on dfg.concept_id_1=df.concept_id 
where df.vocabulary_id in ('RxNorm', 'RxNorm Extension') and df.concept_class_id='Dose Form' 
and df.invalid_reason is null
;

-- Delete Dose Form Groups that are too broad
delete from dfg where dfg_id=36217214; -- Oral Product

-- Take out Dose Forms that make DFGs too broad
delete from dfg where dfg_id=36217210 -- injection 
  and df_id in (
    46275062, -- Jet Injector
    46234468, -- Cartridge
    46234467, -- Pen Injector
    46234466 -- Auto-Injector
);

delete from dfg where dfg_id=36217206 -- Topical Product
  and df_id in (
    19082072, -- 72 Hour Transdermal Patch
    19082073, -- Biweekly Transdermal Patch
    19082252, -- Weekly Transdermal Patch
    19082229, -- Transdermal System
    19082049, -- 16 Hour Transdermal Patch
    19082071, -- 24 Hour Transdermal Patch
    42629089, -- Medicated Patch
    19130307, -- Medicated Pad
    19130329, -- Medicated Tape
    19082701, -- Patch
    35604394, -- Topical Liquefied Gas
    19082281 -- Powder Spray
);

delete from dfg where dfg_id=36217216 -- Pill
  and df_id in (
    19082079, -- Extended Release Oral Tablet
    19082077, -- Extended Release Oral Capsule
    19001949, -- Delayed Release Oral Tablet
    19082255 -- Delayed Release Oral Capsule
);

delete from dfg where dfg_id=36217209 -- Vaginal Product
  and df_id in (
    19010962, -- Vaginal Tablet
    19082230, -- Vaginal Powder
    40167393, -- Vaginal Ring
    19093368 -- Vaginal Suppository
);

delete from dfg where dfg_id=36217211 -- Rectal Product 
  and df_id in (
    19082198, -- Rectal Powder
    19082199, -- Rectal Spray
    19082627 -- Enema
);

delete from dfg where dfg_id=36217213 -- Nasal Product
  and df_id in (
    19082162, -- Nasal Inhalant
    19126919, -- Nasal Inhaler
    19011167 -- Nasal Spray
);

-- 1. Match all 4: d_combo, df, bn and mf have to match - Marketed Products
drop table x_pattern purge;
create table x_pattern as
select distinct
  qi_combo, first_value(ri_combo) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as rd_combo,   
  df_code, first_value(df_id) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as df_id, 
    first_value(dfg_id) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as dfg_id,
  bn_code, first_value(bn_id) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as bn_id,
  mf_code, first_value(mf_id) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as mf_id,
  first_value(q.quant_unit) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit,
  first_value(q.quant_unit_id) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit_id,
  1 as prec
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo,
    eq.d_combo as qd_combo, c.rd_combo, c.u_prec, c.i_prec, c.div, 
    eq.df_code, df.df_id, df.df_prec, dfg.dfg_id,
    eq.bn_code, bn.bn_id, bn.bn_prec,
    eq.mf_code, mf.mf_id, mf.mf_prec,
    c.quant_unit, c.quant_unit_id -- unit combination, needed to translate quant correctly
  from existing_q eq
  join qr_d_combo c on c.qd_combo=eq.d_combo -- get all potential rd_combos
  join qr_df df on df.df_code=eq.df_code -- get potential df_ids
  join dfg on dfg.df_id=df.df_id -- get larger df group
  join qr_bn bn on bn.bn_code=eq.bn_code -- get potential brand names, may not exist in Marketed Products
  join qr_mf mf on mf.mf_code=eq.mf_code -- get potential manufacturers
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo, d_combo as rd_combo, df_id, bn_id, mf_id from existing_r 
) r using(rd_combo, df_id, bn_id, mf_id)
;

-- 2. Match d_combo, df, bn, but not mf - Branded Drug, quantified and boxed
insert /*+ APPEND */ into x_pattern
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qd_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as rd_combo,   
  df_code, first_value(df_id) over (partition by qd_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as df_id, 
    first_value(dfg_id) over (partition by qd_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as dfg_id, 
  bn_code, first_value(bn_id) over (partition by qd_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as bn_id, 
  null as mf_code, null as mf_id,
  first_value(q.quant_unit) over (partition by qd_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit, 
  first_value(q.quant_unit_id) over (partition by qd_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit_id,
  2 as prec
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo,
    eq.d_combo as qd_combo, c.rd_combo, c.u_prec, c.i_prec, c.div, 
    eq.df_code, df.df_id, df.df_prec, dfg.dfg_id,
    eq.bn_code, bn.bn_id, bn.bn_prec,
    c.quant_unit, c.quant_unit_id -- unit combination, needed to translate quant correctly
  from existing_q eq
  join qr_d_combo c on c.qd_combo=eq.d_combo -- get all potential rd_combos
  join qr_df df on df.df_code=eq.df_code -- get potential df_ids
  join dfg on dfg.df_id=df.df_id -- get larger df group
  join qr_bn bn on bn.bn_code=eq.bn_code -- get potential brand names, may not exist in Marketed Products
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo, d_combo as rd_combo, df_id, bn_id from existing_r 
) r using(rd_combo, df_id, bn_id)
;
commit;

-- 3. Match d_combo, df, mf, but not bn - Marketed Products without Brand, quantified or boxed
insert /*+ APPEND */ into x_pattern
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qd_combo, df_code, mf_code order by q.mf_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo, df_code, mf_code order by q.mf_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as rd_combo,   
  df_code, first_value(df_id) over (partition by qd_combo, df_code, mf_code order by q.mf_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as df_id, 
    first_value(dfg_id) over (partition by qd_combo, df_code, mf_code order by q.mf_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as dfg_id,
  null as bn_code, null as bn_id,
  mf_code, first_value(mf_id) over (partition by qd_combo, df_code, mf_code order by q.mf_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as mf_id,
  first_value(q.quant_unit) over (partition by qd_combo, df_code, mf_code order by q.mf_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit, 
  first_value(q.quant_unit_id) over (partition by qd_combo, df_code, mf_code order by q.mf_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit_id,
  3 as prec
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo,
    eq.d_combo as qd_combo, c.rd_combo, c.u_prec, c.i_prec, c.div, 
    eq.df_code, df.df_id, df.df_prec, dfg.dfg_id,
    eq.mf_code, mf.mf_id, mf.mf_prec,
    c.quant_unit, c.quant_unit_id -- unit combination, needed to translate quant correctly
  from existing_q eq
  join qr_d_combo c on c.qd_combo=eq.d_combo -- get all potential rd_combos
  join qr_df df on df.df_code=eq.df_code -- get potential df_ids  join qr_bn bn on bn.bn_code=eq.bn_code -- get potential brand names, may not exist in Marketed Products
  join dfg on dfg.df_id=df.df_id -- get larger df group
  join qr_mf mf on mf.mf_code=eq.mf_code -- get potential manufacturers
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo, d_combo as rd_combo, df_id, mf_id from existing_r 
) r using(rd_combo, df_id, mf_id)
;
commit;

-- 4. Match d_combo, df, but not bn, mf - Clinical Drug, quantified or boxed
insert /*+ APPEND */ into x_pattern
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qd_combo, df_code order by q.df_prec, q.div desc, q.i_prec, q.u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo, df_code order by q.df_prec, q.div desc, q.i_prec, q.u_prec) as rd_combo,   
  df_code, first_value(df_id) over (partition by qd_combo, df_code order by q.df_prec, q.div desc, q.i_prec, q.u_prec) as df_id, 
    first_value(dfg_id) over (partition by qd_combo, df_code order by q.df_prec, q.div desc, q.i_prec, q.u_prec) as dfg_id, 
  null as bn_code, null as bn_id, null as mf_code, null as mf_id,
  first_value(q.quant_unit) over (partition by qd_combo, df_code order by q.df_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit, 
  first_value(q.quant_unit_id) over (partition by qd_combo, df_code order by q.df_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit_id,
  4 as prec
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo,
    eq.d_combo as qd_combo, c.rd_combo, c.u_prec, c.i_prec, c.div, 
    eq.df_code, df.df_id, df.df_prec, dfg.dfg_id,
    c.quant_unit, c.quant_unit_id -- unit combination, needed to translate quant correctly
  from existing_q eq
  join qr_d_combo c on c.qd_combo=eq.d_combo -- get all potential rd_combos
  join qr_df df on df.df_code=eq.df_code -- get potential df_ids
  join dfg on dfg.df_id=df.df_id -- get larger df group
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo, d_combo as rd_combo, df_id from existing_r 
) r using(rd_combo, df_id)
;
commit;

-- 5. Match d_combo, bn, but not df, mf - Branded Component
insert /*+ APPEND */ into x_pattern
select distinct
  qi_combo, first_value(ri_combo) over (partition by qd_combo, bn_code order by q.bn_prec, q.div desc, q.i_prec, q.u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo, bn_code order by q.bn_prec, q.div desc, q.i_prec, q.u_prec) as rd_combo,   
  null as df_code, null as df_id, null as dfg_id,
  bn_code, first_value(bn_id) over (partition by qd_combo, bn_code order by q.bn_prec, q.div desc, q.i_prec, q.u_prec) as bn_id, 
  null as mf_code, null as mf_id,
  first_value(q.quant_unit) over (partition by qd_combo, bn_code order by q.bn_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit, 
  first_value(q.quant_unit_id) over (partition by qd_combo, bn_code order by q.bn_prec, q.div desc, q.i_prec, q.u_prec) as quant_unit_id,
  5 as prec
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo,
    eq.d_combo as qd_combo, c.rd_combo, c.u_prec, c.i_prec, c.div, 
    eq.bn_code, bn.bn_id, bn.bn_prec,
    c.quant_unit, c.quant_unit_id -- unit combination, needed to translate quant correctly
  from existing_q eq
  join qr_d_combo c on c.qd_combo=eq.d_combo -- get all potential rd_combos
  join qr_bn bn on bn.bn_code=eq.bn_code -- get potential brand names, may not exist in Marketed Products
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo, d_combo as rd_combo, bn_id from existing_r 
) r using(rd_combo, bn_id)
;
commit;

-- 6. Match i_combo, df, bn but no mf - Branded Forms
insert /*+ APPEND */ into x_pattern
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qi_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.i_prec) as ri_combo,     
  null as qd_combo, null as rd_combo,   
  df_code, first_value(df_id) over (partition by qi_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.i_prec) as df_id, 
    first_value(dfg_id) over (partition by qi_combo, df_code, bn_code order by q.bn_prec, q.df_prec, q.i_prec) as dfg_id, 
  bn_code, first_value(bn_id) over (partition by qi_combo, bn_code, bn_code order by q.bn_prec, q.df_prec, q.i_prec) as bn_id, 
  null as mf_code, null as mf_id,
  null as quant_unit, null as quant_unit_id, -- no units without dose
  6 as prec
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo, c.i_prec, 
    eq.df_code, df.df_id, df.df_prec, dfg.dfg_id,
    eq.bn_code, bn.bn_id, bn.bn_prec
  from existing_q eq
  join qr_i_combo c on c.qi_combo=eq.i_combo -- get all potential rd_combos
  join qr_df df on df.df_code=eq.df_code -- get potential brand names, may not exist in Marketed Products
  join dfg on dfg.df_id=df.df_id -- get larger df group
  join qr_bn bn on bn.bn_code=eq.bn_code -- get potential brand names, may not exist in Marketed Products
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo as ri_combo, df_id, bn_id from existing_r 
) r using(ri_combo, df_id, bn_id)
;
commit;

-- 7. Match i_combo, df but not bn, mf - Clinical Forms
insert /*+ APPEND */ into x_pattern
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qi_combo, df_code order by q.df_prec, q.i_prec) as ri_combo,     
  null as qd_combo, null as rd_combo,
  df_code, first_value(df_id) over (partition by qi_combo, df_code order by q.df_prec, q.i_prec) as df_id, 
    first_value(dfg_id) over (partition by qi_combo, df_code order by q.df_prec, q.i_prec) as dfg_id, 
  null as bn_code, null as bn_id,
  null as mf_code, null as mf_id,
  null as quant_unit, null as quant_unit_id,
  7 as prec
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo, c.i_prec, 
    eq.df_code, df.df_id, df.df_prec, dfg.dfg_id
  from existing_q eq
  join qr_i_combo c on c.qi_combo=eq.i_combo -- get all potential rd_combos
  join qr_df df on df.df_code=eq.df_code -- get potential brand names, may not exist in Marketed Products
  join dfg on dfg.df_id=df.df_id -- get larger df group
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo as ri_combo, df_id from existing_r 
) r using(ri_combo, df_id)
;
commit;

-- Break up mulit-combos and write back leaving all other patterns unchanged
-- This is necessary for Clinical Drug Comps and for translating comobos that only exist in multi-versions in both q and r
insert /*+ APPEND */ into x_pattern
select distinct 
  q.qi_combo, r.ri_combo, 
  cast(q_ds as varchar2(20)) as qd_combo, cast(r_ds as varchar2(20)) as rd_combo, 
  qr.df_code, qr.df_id, dfg.dfg_id,
  qr.bn_code, qr.bn_id, 
  qr.mf_code, qr.mf_id,
  qr.quant_unit, qr.quant_unit_id,
  prec -- as already exists
from ( -- break up all combos for q
  select distinct d_combo as qd_combo, i_code as qi_combo, ds_code as q_ds from q_ds join q_combo using(concept_code) where d_combo like '%-%'
) q
join x_pattern qr using(qd_combo) -- find them in the existing complete p to existing r 
join ( -- break up all combos for r
  select distinct d_combo as rd_combo, i_code as ri_combo, ds_code as r_ds from r_ds join r_combo using(concept_id) where d_combo like '%-%'
) r using(rd_combo) 
join qr_uds using(q_ds, r_ds) -- get right component in a combination aligned
join dfg on dfg.df_id=qr.df_id
where not exists ( -- Check we don't already have that dosage covered
  select 1 from x_pattern e where e.qd_combo=cast(q_ds as varchar2(20)) and e.rd_combo=cast(r_ds as varchar2(20))
)
;
commit;

-- Break up mulit-i_combos and write back leaving all other patterns unchanged
-- This is necessary for Clinical Drug Comps and for translating comobos that only exist in multi-versions in both q and r
insert /*+ APPEND */ into x_pattern
select distinct 
  qi_combo, ri_combo, 
  null as qd_combo, null as rd_combo,
  qr.df_code, qr.df_id, qr.dfg_id,
  qr.bn_code, qr.bn_id,
  null as mf_code, null as mf_id,
  null as quant_unit, null as quant_unit_id,
  qr.prec
from x_pattern qr
join ( -- break up qi_combo from actual combo code, there is no easy way of doing it similar to q_ds
  select qi_combo, trim(regexp_substr(qi_combo, '[^\-]+', 1, levels.column_value)) as qi_code
  from (select distinct qi_combo from x_pattern), -- extension_combo contains i_combos as well
  table(cast(multiset(select level from dual connect by level <= length (regexp_replace(qi_combo, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
) q using(qi_combo)
join ( -- break up ri_combo
  select ri_combo, trim(regexp_substr(ri_combo, '[^\-]+', 1, levels.column_value)) as ri_code
  from (select distinct ri_combo from x_pattern), -- extension_combo contains i_combos as well
  table(cast(multiset(select level from dual connect by level <= length (regexp_replace(ri_combo, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
) r using(ri_combo)
join qr_i using(qi_code, ri_code) -- get right component in a combination aligned
where rd_combo is null -- only Form patterns
and not exists ( -- Check we don't already have that ingrs are covered
  select 1 from x_pattern e where e.qi_combo=qi_combo and e.ri_combo=ri_combo
)
;
commit;

-- Remove duplicate mappings for the same qd_combo, df_code, bn_code, mf_code. They happen because of situations like 1000 mg/mL vs 1 mg/mg
delete from x_pattern where rowid not in (
  select first_value(x_pattern.rowid) over (partition by qd_combo, df_code, bn_code, mf_code order by div desc, i_prec, u_prec, rd_combo) from x_pattern
  join qr_uds on cast(q_ds as varchar2(50))=qd_combo and cast(r_ds as varchar2(50))=rd_combo
)
;
commit;

/*********************************************************************************************
* Create individual translation tables all starting with x_, with one best record for each q *
*********************************************************************************************/
-- Strategy: First use what's found in the patterns, then use precedences from relationship_to_concept and div between uds

-- 1. Pick the best choices from x_pattern
drop table x_d_combo purge;
create table x_d_combo as
select distinct
  qi_combo, first_value(ri_combo) over (partition by qd_combo order by prec, rd_combo, ri_combo) as ri_combo, -- prefer the stronger patterns (df, bn and mf) with lower prec, if more than one order by rd_combo
  qd_combo, first_value(rd_combo) over (partition by qd_combo order by prec, rd_combo, ri_combo) as rd_combo,
  first_value(quant_unit) over (partition by qd_combo order by prec, rd_combo) as quant_unit, -- dragging through
  first_value(quant_unit_id) over (partition by qd_combo order by prec, rd_combo) as quant_unit_id -- dragging through
from x_pattern;
commit;

-- 2. If no patterns exist, add the best translations (usually Clinical Drug Comps)
insert /*+ APPEND */ into x_d_combo 
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qd_combo order by div desc, i_prec, u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo order by div desc, i_prec, u_prec) as rd_combo,   
  first_value(quant_unit) over (partition by qd_combo order by div desc, i_prec, u_prec) as quant_unit,
  first_value(quant_unit_id) over (partition by qd_combo order by div desc, i_prec, u_prec) as quant_unit_id
from qr_d_combo q
-- compare to existing to make sure d_combo is not already covered
where qd_combo not in (select qd_combo from x_d_combo)
;
commit;

-- 1. Based on the patterns in ds, create a translation table for ingredients for drug forms
drop table x_i_combo purge;
create table x_i_combo as
select distinct qi_combo, ri_combo from x_d_combo
;
commit;

-- 2. Add those i_combos that are not in x_d_combo, but can be inferred from qr_i_combo (singleton drug forms)
insert /*+ APPEND */ into x_i_combo
select distinct 
  qi_combo, 
  first_value (ri_combo) over (partition by qi_combo order by i_prec) as ri_combo
from qr_i_combo
-- Make sure it is not already covered
where qi_combo not in (select qi_combo from x_i_combo)
;
commit;

-- 3. Add any translations not found in the data, but provided by the input tables and have drugs containing them
insert /*+ APPEND */ into x_i_combo
select distinct
  qi_code as qi_combo,
  first_value (ri_code) over (partition by qi_code order by prec) as ri_combo -- pick the best translation
from qr_i
where qi_code not in (
  select qi_combo from x_i_combo
)
;
commit;

-- Translation of individual ingredients, whether found in r or not
-- x_i_combo is for i_comob translations in Drug Forms, x_ing for translations of individual ingredients, such as in extension_uds
-- Get all the ones in x_i_combo, which contains everything that is translated
drop table x_ing purge;
create table x_ing nologging as 
select * from x_i_combo where ri_combo not like '%-%'
;
commit;

-- Add any translations not found in the data, but provided by the input tables even if no drug contains them
-- (x_i_combo contains only ingredients that have a drug as a descendent)
insert /*+ APPEND */ into x_ing
select distinct
  concept_code_1 as qi_combo,
  first_value (i_code) over (partition by concept_code_1 order by precedence) as ri_combo -- pick the best translation
from r_to_c rc
join ing_stage on i_id=concept_id_2 -- limit to ingredients and get xxx-code
where not exists (
  select 1 from x_ing where qi_combo=concept_code_1
)
;
commit;

-- Preferred Dose Form translations. These may be a little optimistic, as DFGs are fairly broad
drop table x_df purge;
create table x_df nologging as
select distinct 
  df_code,
  first_value(df_id) over (partition by df_code order by prec, cnt desc, df_code) as df_id, -- pick the most common translation in the data
  first_value(dfg_id) over (partition by df_code order by prec, cnt desc, df_code) as dfg_id, -- pick the most common translation in the data
  first_value(concept_name) over (partition by df_code order by prec, cnt desc, df_code) as concept_name -- and the corresponding name
from (
  select df_code, df_id, prec, count(8) as cnt from x_pattern where df_id!=0 group by df_code, df_id, prec
)
join concept on concept_id=df_id
left join dfg using(df_id)
;

-- Add the ones that are not translated in the data
insert /*+ APPEND */ into x_df
select df_code, df_id, dfg.dfg_id, concept_name
from qr_df join concept on df_id=concept_id
left join dfg using(df_id)
where df_code not in (select df_code from x_df) -- don't translate the ones already there
and df_prec=1
;
commit;

-- Preferred Brand Name translations. Usually brands are one-to-one
drop table x_bn purge;
create table x_bn nologging as
select distinct 
  bn_code,
  first_value(bn_id) over (partition by bn_code order by prec, cnt desc, bn_code) as bn_id, -- pick the most common translation in the data
  first_value(concept_name) over (partition by bn_code order by prec, cnt desc, bn_code) as concept_name 
from (
  select bn_code, bn_id, prec, count(8) as cnt from x_pattern where bn_id!=0 group by bn_code, bn_id, prec
)
join concept on concept_id=bn_id
;

-- Add the ones that are not translated in the data
insert /*+ APPEND */ into x_bn
select bn_code, bn_id, concept_name
from qr_bn join concept on concept_id=bn_id
where bn_code not in (select bn_code from x_bn) -- don't translate the ones already there
and bn_prec=1
;
commit;

-- Preferred Supplier translations
drop table x_mf purge;
create table x_mf nologging as
select distinct 
  mf_code,
  first_value(mf_id) over (partition by mf_code order by prec, cnt desc, mf_code) as mf_id, -- pick the most common translation in the data
  first_value(concept_name) over (partition by mf_code order by prec, cnt desc, mf_code) as concept_name 
from (
  select mf_code, mf_id, prec, count(8) as cnt from x_pattern where mf_id!=0 group by mf_code, mf_id, prec
)
join concept on concept_id=mf_id
;

-- Add the ones that are not translated in the data
insert /*+ APPEND */ into x_mf
select mf_code, mf_id, concept_name
from qr_mf join concept on concept_id=mf_id
where mf_code not in (select mf_code from x_mf) -- don't translate the ones already there
and mf_prec=1
;
commit;

-- All unit translations, since we don't know what unit combinations we get
drop table x_unit purge;
create table x_unit as
select concept_code_1 as unit_code, concept_id_2 as unit_id, conversion_factor 
from r_to_c join drug_concept_stage on concept_code=concept_code_1 
where concept_class_id='Unit'
;
commit;

/*********************************************************
* 9. Build extensions for ing, uds, combo, df, bn and mf *
*********************************************************/

-- Create table with ingredients in q that have no translation
-- Combinations are in extension_ds, even if d_combo doesn't exist
drop table extension_i purge;
create table extension_i as
select i_code as qi_code, 'XXX'||xxx_seq.nextval as ri_code
from ( -- all ingredients that have no translation
  select distinct i_code from q_ing
  minus
  select qi_combo from x_ing
);

-- Create table with unique ds in q that have no translation
drop table extension_uds purge;
create table extension_uds as
select 
  ds_code, -- the original ds_code from q_combo can be used as there is a one-to-one relationship (no ingredient or unit splitting)
  ri_code as i_code, 0 as ingredient_concept_id,
  amount_value, nvl(xu_a.unit_id, 0) as amount_unit_concept_id,
  numerator_value, nvl(xu_n.unit_id, 0) as numerator_unit_concept_id,
  case 
    when xu_n.unit_id in (8554, 9325, 9324) then null
    else nvl(xu_d.unit_id, 0) 
  end as denominator_unit_concept_id
from ( -- get all unique ds that have no translation to r
  select ds_code from q_uds
  minus
  select cast(qd_combo as number) from x_d_combo where qd_combo not like '%-%' -- excluding the combos for cast as number to work
) 
join q_uds using(ds_code) -- get the details
join ( -- translate the ingredient
  select * from extension_i
union
  select qi_combo, ri_combo from x_ing -- use only the generic, not specific translation
) on ingredient_concept_code=qi_code
-- translate the units
left join x_unit xu_a on amount_unit=xu_a.unit_code and xu_a.conversion_factor=1
left join x_unit xu_n on numerator_unit=xu_n.unit_code and xu_n.conversion_factor=1
left join x_unit xu_d on denominator_unit=xu_d.unit_code and xu_d.conversion_factor=1
;

-- Create table linking the uds to their q and r combos
drop table extension_ds purge;
create table extension_ds as
select distinct
  i_combo, d_combo, q_ds, r_ds, q_i, r_i, quant_unit, quant_unit_id
from (
-- for each non-translated q_combo get individual ds, i_code and i_combo
  select distinct i_combo, d_combo, ds_code, i_code as q_i, quant_unit
  from q_combo qc join q_ds using(concept_code) join q_uds using(ds_code)
  where d_combo not in (select qd_combo from x_d_combo) -- those that already have a translation
union
  select i_code, cast(ds_code as varchar2(50)), ds_code, i_code, quant_unit
  from q_ds
)
join ( -- translations for the ds_code
-- get the newly defined uds from extension_uds
  select ds_code as q_ds, ds_code as r_ds, i_code as r_i, denominator_unit_concept_id as quant_unit_id from extension_uds
union -- and the translated ones
  select cast(qd_combo as number) as q_ds, cast(rd_combo as number) as r_ds, ri_combo as r_i, quant_unit_id from x_d_combo
  where qd_combo not like '%-%'
) on q_ds=ds_code
;
commit;

-- Create combos for extension. Existing combos in x_combo will not be added, but any combination of existing and new uds might get in
-- Only the best combination will be created (not all that can be inferred from x_combo)
-- Not all combos will actually be used, as some drugs are mapped 100%
drop table extension_combo purge;
create table extension_combo as
select distinct
  i_combo as qi_combo,
  listagg(r_i, '-') within group (order by r_i) as ri_combo,
  d_combo as qd_combo,
  listagg(r_ds, '-') within group (order by r_ds) as rd_combo,
  max(quant_unit) as quant_unit, max(quant_unit_id) as quant_unit_id
from extension_ds
group by i_combo, d_combo
;
commit;

-- Add ingredient only combos for Drug Forms.
insert /*+ APPEND */ into extension_combo
select distinct
  i_combo as qi_combo,
  listagg(ri_code, '-') within group (order by ri_code) as ri_combo,
  ' ' as qd_combo,
  ' ' as rd_combo,
  null as quant_unit, null as quant_unit_id
from (
-- i_combos in q_combo but not translated (x_i_combo) or added through d_combo
  select distinct i_code, i_combo
  from q_combo join q_ing using(concept_code)
  where d_combo=' '
  and i_combo not in (select qi_combo from x_i_combo) -- those that already have a translation
  and i_combo not in (select qi_combo from extension_combo) -- those we already got covered
)
join ( -- translate the ingredient
  select * from extension_i
union
  select * from x_ing-- use only the generic, not specific translation
) on i_code=qi_code
group by i_combo
;
commit;

-- Create DF extension records for those Dose Forms that don't exist
drop table extension_df purge;
create table extension_df nologging as
select df_code, concept_name, extension_id.nextval as df_id
from (select distinct df_code from q_df)
join drug_concept_stage on drug_concept_stage.concept_code=df_code
where df_code not in (select df_code from x_df) -- those that already have a translation
;

-- Create BN extension records for those Dose Forms that do not exist
drop table extension_bn purge;
create table extension_bn nologging as
select bn_code as bn_code, concept_name, extension_id.nextval as bn_id
from (select distinct bn_code from q_bn)
join drug_concept_stage on drug_concept_stage.concept_code=bn_code
where bn_code not in (select bn_code from x_bn) -- those that already have a translation
;

-- Create MF extension records for those Dose Forms that don't exist
drop table extension_mf purge;
create table extension_mf nologging as
select mf_code as mf_code, concept_name, extension_id.nextval as mf_id
from (select distinct mf_code from q_mf)
join drug_concept_stage on drug_concept_stage.concept_code=mf_code
where mf_code not in (select mf_code from x_mf) -- those that already have a translation
;

/*******************************************************************************************************************
* 10. Build a complete target corpus in both q and r notation and assign concept_code from q and concept_id from r *
*******************************************************************************************************************/

-- Marketed Product
-- Definition: d_combo, df and mf must exist, quant, bn and bs are optional
drop table full_corpus purge;
create table full_corpus nologging as
with c as (
-- Define all Marketed Products in q
  select distinct
    nvl(value, 0) as q_value, nvl(unit, ' ') as quant_unit, i_combo as qi_combo, d_combo as qd_combo, nvl(q_df.df_code, ' ') as df_code, nvl(q_bn.bn_code, ' ') as bn_code, nvl(q_bs.bs, 0) as bs, nvl(q_mf.mf_code, ' ') as mf_code
  from q_combo
  join q_df using(concept_code)
  join q_mf using(concept_code)
  left join q_quant using(concept_code)
  left join q_bn using(concept_code)
  left join q_bs using(concept_code)
  where d_combo!=' ' -- to exclude "Marketed Branded Drug Forms" without strength
)
select
  concept_code, concept_id,  
  q_value, quant_unit, qi_combo, qd_combo, df_code, bn_code, bs, mf_code, r_value, quant_unit_id, ri_combo, rd_combo, df_id, bn_id, mf_id,
  cast('Marketed Product' as varchar2(20)) as concept_class_id
from (
  select 
    p.q_value, p.quant_unit, qi_combo, qd_combo, df_code, bn_code, bs, mf_code, 
    coalesce(q.r_value, p.q_value*conversion_factor, 0) as r_value, 
    coalesce(q.quant_unit_id, x_unit.unit_id, 0) as quant_unit_id,
    ri_combo, rd_combo, df_id, bn_id, mf_id 
  from (
    select distinct
      c.*,
      coalesce(first_value(x.ri_combo) over (partition by x.qd_combo order by x.prec), combo.ri_combo, ec.ri_combo) as ri_combo,
      coalesce(first_value(x.rd_combo) over (partition by x.qd_combo order by x.prec), combo.rd_combo, ec.rd_combo) as rd_combo,
      coalesce(first_value(x.quant_unit_id) over (partition by x.qd_combo order by x.prec), combo.quant_unit_id, ec.quant_unit_id) as quant_unit_id,
      coalesce(x.df_id, x_df.df_id, edf.df_id, 0) as df_id,
      coalesce(x.bn_id, x_bn.bn_id, ebn.bn_id, 0) as bn_id,
      coalesce(x.mf_id, x_mf.mf_id, emf.mf_id, 0) as mf_id
    from c
    left join x_pattern x on c.qd_combo=x.qd_combo and c.df_code=nvl(x.df_code, c.df_code) and c.bn_code=nvl(x.bn_code, c.bn_code) and c.mf_code=nvl(x.mf_code, c.mf_code)
    left join x_d_combo combo on c.qd_combo=combo.qd_combo 
    left join extension_combo ec on c.qd_combo=ec.qd_combo
    left join x_df on c.df_code=x_df.df_code left join extension_df edf on c.df_code=edf.df_code
    left join x_bn on c.bn_code=x_bn.bn_code left join extension_bn ebn on c.bn_code=ebn.bn_code
    left join x_mf on c.mf_code=x_mf.mf_code left join extension_mf emf on c.mf_code=emf.mf_code
  ) p
  left join qr_quant q on q.q_value=p.q_value and q.quant_unit=p.quant_unit and p.quant_unit_id=q.quant_unit_id 
  -- If units are null (undefined, usually after % or the homeopathics), then match no matter what, after trying everything else
  left join x_unit on x_unit.unit_code=nvl(p.quant_unit, x_unit.unit_code) and x_unit.unit_id=nvl(p.quant_unit_id, x_unit.unit_id)
) m
left join (select concept_code, quant_value as q_value, quant_unit, i_combo as qi_combo, d_combo as qd_combo, df_code, bn_code, bs, mf_code from existing_q) using(q_value, quant_unit, qi_combo, qd_combo, df_code, bn_code, bs, mf_code)
left join (select concept_id, quant_value as r_value, quant_unit_id, i_combo as ri_combo, d_combo as rd_combo, df_id, bn_id, bs, mf_id from existing_r) using(r_value, quant_unit_id, ri_combo, rd_combo, df_id, bn_id, bs, mf_id)
;
commit;

-- Branded Products (quant, boxed or just Drug)
-- Definition: d_combo, df and bn, no mf, quant and bs optional
insert /*+ APPEND */ into full_corpus
with ex as (
  select distinct q_value, quant_unit, qi_combo, qd_combo, df_code, bn_code, bs, r_value, quant_unit_id, ri_combo, rd_combo, df_id, bn_id
  from full_corpus where df_id!=0 and bn_id!=0
),
c as (
-- Quant Branded Box
  select
    value as q_value, unit as quant_unit, i_combo as qi_combo, d_combo as qd_combo, q_df.df_code, q_bn.bn_code, q_bs.bs
  from q_combo
  join q_quant using(concept_code)
  join q_df using(concept_code)
  join q_bn using(concept_code)
  join q_bs using(concept_code)
  where d_combo!=' '
union
-- Branded Drug Box
  select
    0 as q_value, ' ' as quant_unit, i_combo as qi_combo, d_combo as qd_combo, q_df.df_code, q_bn.bn_code, q_bs.bs
  from q_combo
  join q_df using(concept_code)
  join q_bn using(concept_code)
  join q_bs using(concept_code)
  where d_combo!=' '
union
-- Quant Branded Drug
  select
    value as q_value, unit as quant_unit, i_combo as qi_combo, d_combo as qd_combo, q_df.df_code, q_bn.bn_code, 0 as bs
  from q_combo
  join q_quant using(concept_code)
  join q_df using(concept_code)
  join q_bn using(concept_code)
  where d_combo!=' '
union
-- Branded Drug
  select
    0 as q_value, ' ' as quant_unit, i_combo as qi_combo, d_combo as qd_combo, q_df.df_code, q_bn.bn_code, 0 as bs
  from q_combo
  join q_df using(concept_code)
  join q_bn using(concept_code)
  where d_combo!=' '
minus
-- exclude the combinations already translated previously
  select q_value, quant_unit, qi_combo, qd_combo, df_code, bn_code, bs from ex
)
select
  concept_code, concept_id,  
  q_value, quant_unit, qi_combo, qd_combo, df_code, bn_code, bs, ' ' as mf_code,
  r_value, quant_unit_id, ri_combo, rd_combo, df_id, bn_id, 0 as mf_id,
  case 
    when q_value=0 and bs=0 then 'Branded Drug'
    when q_value=0 then 'Branded Drug Box'
    when bs=0 then 'Quant Branded Drug'
    else 'Quant Branded Box'
  end as concept_class_id
from (
-- Collect existing
  select * from ex
union
  select 
    p.q_value, p.quant_unit, qi_combo, qd_combo, df_code, bn_code, bs,
    coalesce(q.r_value, p.q_value*conversion_factor, 0) as r_value, 
    coalesce(q.quant_unit_id, x_unit.unit_id, 0) as quant_unit_id,
    ri_combo, rd_combo, df_id, bn_id
  from (
    select distinct
      c.*,
      coalesce(first_value(x.ri_combo) over (partition by x.qd_combo order by x.prec), combo.ri_combo, ec.ri_combo) as ri_combo,
      coalesce(first_value(x.rd_combo) over (partition by x.qd_combo order by x.prec), combo.rd_combo, ec.rd_combo) as rd_combo,
      coalesce(first_value(x.quant_unit_id) over (partition by x.qd_combo order by x.prec), combo.quant_unit_id, ec.quant_unit_id) as quant_unit_id,
      coalesce(x.df_id, x_df.df_id, edf.df_id, 0) as df_id,
      coalesce(x.bn_id, x_bn.bn_id, ebn.bn_id, 0) as bn_id
    from c
    left join x_pattern x on c.qd_combo=x.qd_combo and c.df_code=nvl(x.df_code, c.df_code) and c.bn_code=nvl(x.bn_code, c.bn_code)
    left join x_d_combo combo on c.qd_combo=combo.qd_combo 
    left join extension_combo ec on c.qd_combo=ec.qd_combo
    left join x_df on c.df_code=x_df.df_code left join extension_df edf on c.df_code=edf.df_code
    left join x_bn on c.bn_code=x_bn.bn_code left join extension_bn ebn on c.bn_code=ebn.bn_code
  ) p
  left join qr_quant q on q.q_value=p.q_value and q.quant_unit=p.quant_unit and p.quant_unit_id=q.quant_unit_id 
  left join x_unit on x_unit.unit_code=nvl(p.quant_unit, x_unit.unit_code) and x_unit.unit_id=p.quant_unit_id 
) m
left join (select concept_code, quant_value as q_value, quant_unit, i_combo as qi_combo, d_combo as qd_combo, df_code, bn_code, bs from existing_q where mf_code=' ') using(q_value, quant_unit, qi_combo, qd_combo, df_code, bn_code, bs)
left join (select concept_id, quant_value as r_value, quant_unit_id, i_combo as ri_combo, d_combo as rd_combo, df_id, bn_id, bs from existing_r where mf_id=0) using(r_value, quant_unit_id, ri_combo, rd_combo, df_id, bn_id, bs)
;
commit;

-- Clinical Products (quant, boxed or just Drug)
-- Definition: d_combo, df, no bn and mf, quant and bs optional
insert /*+ APPEND */ into full_corpus
with ex as (
  select distinct q_value, quant_unit, qi_combo, qd_combo, df_code, bs, r_value, quant_unit_id, ri_combo, rd_combo, df_id
  from full_corpus where df_id!=0
),
c as (
-- Quant Clinical Box
  select
    value as q_value, unit as quant_unit, i_combo as qi_combo, d_combo as qd_combo, q_df.df_code, q_bs.bs
  from q_combo
  join q_quant using(concept_code)
  join q_df using(concept_code)
  join q_bs using(concept_code)
  where d_combo!=' '
union
-- Clinical Drug Box
  select
    0 as q_value, ' ' as quant_unit, i_combo as qi_combo, d_combo as qd_combo, q_df.df_code, q_bs.bs
  from q_combo
  join q_df using(concept_code)
  join q_bs using(concept_code)
  where d_combo!=' '
union
-- Quant Clinical Drug
  select
    value as q_value, unit as quant_unit, i_combo as qi_combo, d_combo as qd_combo, q_df.df_code, 0 as bs
  from q_combo
  join q_quant using(concept_code)
  join q_df using(concept_code)
  where d_combo!=' '
union
-- Clinical Drug
  select
    0 as q_value, ' ' as quant_unit, i_combo as qi_combo, d_combo as qd_combo, q_df.df_code, 0 as bs
  from q_combo
  join q_df using(concept_code)
  where d_combo!=' '
minus
-- exclude the combinations already translated previously
  select q_value, quant_unit, qi_combo, qd_combo, df_code, bs from ex
)
select
  concept_code, concept_id,  
  q_value, quant_unit, qi_combo, qd_combo, df_code, ' ' as bn_code, bs, ' ' as mf_code,
  r_value, quant_unit_id, ri_combo, rd_combo, df_id, 0 as bn_id, 0 as mf_id,
  case 
    when q_value=0 and bs=0 then 'Clinical Drug'
    when q_value=0 then 'Clinical Drug Box'
    when bs=0 then 'Quant Clinical Drug'
    else 'Quant Clinical Box'
  end as concept_class_id
from (
-- Collect existing
  select * from ex
union
  select 
    p.q_value, p.quant_unit, qi_combo, qd_combo, df_code, bs,
    coalesce(q.r_value, p.q_value*conversion_factor, 0) as r_value, 
    coalesce(q.quant_unit_id, x_unit.unit_id, 0) as quant_unit_id,
    ri_combo, rd_combo, df_id
  from (
    select distinct
      c.*,
      coalesce(first_value(x.ri_combo) over (partition by x.qd_combo order by x.prec), combo.ri_combo, ec.ri_combo) as ri_combo,
      coalesce(first_value(x.rd_combo) over (partition by x.qd_combo order by x.prec), combo.rd_combo, ec.rd_combo) as rd_combo,
      coalesce(first_value(x.quant_unit_id) over (partition by x.qd_combo order by x.prec), combo.quant_unit_id, ec.quant_unit_id) as quant_unit_id,
      coalesce(x.df_id, x_df.df_id, edf.df_id, 0) as df_id
    from c
    left join x_pattern x on c.qd_combo=x.qd_combo and c.df_code=nvl(x.df_code, c.df_code)
    left join x_d_combo combo on c.qd_combo=combo.qd_combo 
    left join extension_combo ec on c.qd_combo=ec.qd_combo
    left join x_df on c.df_code=x_df.df_code left join extension_df edf on c.df_code=edf.df_code
  ) p
  left join qr_quant q on q.q_value=p.q_value and q.quant_unit=p.quant_unit and p.quant_unit_id=q.quant_unit_id 
  left join x_unit on x_unit.unit_code=nvl(p.quant_unit, x_unit.unit_code) and x_unit.unit_id=p.quant_unit_id 
) m
left join (select concept_code, quant_value as q_value, quant_unit, i_combo as qi_combo, d_combo as qd_combo, df_code, bs from existing_q where mf_code=' ' and bn_code=' ') using(q_value, quant_unit, qi_combo, qd_combo, df_code, bs)
left join (select concept_id, quant_value as r_value, quant_unit_id, i_combo as ri_combo, d_combo as rd_combo, df_id, bs from existing_r where mf_id=0 and bn_id=0) using(r_value, quant_unit_id, ri_combo, rd_combo, df_id, bs)
;
commit;

-- Branded Drug Form
-- Definition: i_combo, df and bn, no quant, d_combo, bs and mf
insert /*+ APPEND */ into full_corpus
with ex as (
  select distinct qi_combo, df_code, bn_code, ri_combo, df_id, bn_id
  from full_corpus where df_id!=0 and bn_id!=0
),
c as (
  select
    i_combo as qi_combo, q_df.df_code, q_bn.bn_code
  from q_combo
  join q_df using(concept_code)
  join q_bn using(concept_code)
minus
-- exclude the combinations already translated previously
  select qi_combo, df_code, bn_code from ex
)
select
  concept_code, concept_id,  
  0 as q_value, ' ' as quant_unit, qi_combo, ' ' as qd_combo, df_code, bn_code, 0 as bs, ' ' as mf_code,
  0 as r_value, 0 as quant_unit_id, ri_combo, ' ' as rd_combo, df_id, bn_id, 0 as mf_id,
  'Branded Drug Form' as concept_class_id
from (
-- Collect existing
  select * from ex
union
  select distinct
    c.*,
    coalesce(first_value(x.ri_combo) over (partition by x.qi_combo order by x.prec), combo.ri_combo, ec.ri_combo) as ri_combo,
    coalesce(x.df_id, x_df.df_id, edf.df_id, 0) as df_id,
    coalesce(x.bn_id, x_bn.bn_id, ebn.bn_id, 0) as bn_id
  from c
  left join x_pattern x on c.qi_combo=x.qi_combo and c.df_code=nvl(x.df_code, c.df_code) and c.bn_code=nvl(x.bn_code, c.bn_code)
  left join x_i_combo combo on c.qi_combo=combo.qi_combo 
  left join extension_combo ec on c.qi_combo=ec.qi_combo
  left join x_df on c.df_code=x_df.df_code left join extension_df edf on c.df_code=edf.df_code
  left join x_bn on c.bn_code=x_bn.bn_code left join extension_bn ebn on c.bn_code=ebn.bn_code
) m
left join (select concept_code, i_combo as qi_combo, df_code, bn_code from existing_q where quant_value=0 and d_combo=' ' and bs=0 and mf_code=' ') using(qi_combo, df_code, bn_code)
left join (select concept_id, i_combo as ri_combo, df_id, bn_id from existing_r where quant_value=0 and d_combo=' ' and bs=0 and mf_id=0) using(ri_combo, df_id, bn_id)
;
commit;

-- Clinical Drug Form
-- Definition: i_combo and df, no quant, d_combo, bn, bs and mf
insert /*+ APPEND */ into full_corpus
with ex as (
  select distinct qi_combo, df_code, ri_combo, df_id
  from full_corpus where df_id!=0 
),
c as (
  select
    i_combo as qi_combo, q_df.df_code
  from q_combo
  join q_df using(concept_code)
minus
-- exclude the combinations already translated previously
  select qi_combo, df_code from ex
)
select
  concept_code, concept_id,  
  0 as q_value, ' ' as quant_unit, qi_combo, ' ' as qd_combo, df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
  0 as r_value, 0 as quant_unit_id, ri_combo, ' ' as rd_combo, df_id, 0 as bn_id, 0 as mf_id,
  'Clinical Drug Form' as concept_class_id
from (
-- Collect existing
  select * from ex
union
  select distinct
    c.*,
    coalesce(first_value(x.ri_combo) over (partition by x.qi_combo order by x.prec), combo.ri_combo, ec.ri_combo) as ri_combo,
    coalesce(x.df_id, x_df.df_id, edf.df_id, 0) as df_id
  from c
  left join x_pattern x on c.qi_combo=x.qi_combo and c.df_code=nvl(x.df_code, c.df_code)
  left join x_i_combo combo on c.qi_combo=combo.qi_combo 
  left join extension_combo ec on c.qi_combo=ec.qi_combo
  left join x_df on c.df_code=x_df.df_code left join extension_df edf on c.df_code=edf.df_code
) m
left join (select concept_code, i_combo as qi_combo, df_code from existing_q where quant_value=0 and d_combo=' ' and bn_code=' ' and bs=0 and mf_code=' ') using(qi_combo, df_code)
left join (select concept_id, i_combo as ri_combo, df_id from existing_r where quant_value=0 and d_combo=' ' and bn_id=0 and bs=0 and mf_id=0) using(ri_combo, df_id)
;
commit;

-- Branded Drug Component
-- Definition: d_combo and bn, no quant, df, bs and mf
insert /*+ APPEND */ into full_corpus
with ex as (
  select distinct qi_combo, qd_combo, bn_code, ri_combo, rd_combo, bn_id
  from full_corpus where qd_combo!=' ' and bn_id!=0
),
c as (
  select
    i_combo as qi_combo, d_combo as qd_combo, q_bn.bn_code
  from q_combo
  join q_bn using(concept_code)
  where d_combo!=' ' 
minus
-- exclude the combinations already translated previously
  select qi_combo, qd_combo, bn_code from ex
)
select
  concept_code, concept_id,
  0 as q_value, ' ' as quant_unit, qi_combo, qd_combo, ' ' as df_code, bn_code, 0 as bs, ' ' as mf_code,
  0 as r_value, 0 as quant_unit_id, ri_combo, rd_combo, 0 as df_id, bn_id, 0 as mf_id,
  'Branded Drug Comp' as concept_class_id

from (
-- Collect existing
  select * from ex
union
  select distinct
    c.*,
    coalesce(first_value(x.ri_combo) over (partition by x.qd_combo order by x.prec), combo.ri_combo, ec.ri_combo) as ri_combo,
    coalesce(first_value(x.rd_combo) over (partition by x.qd_combo order by x.prec), combo.rd_combo, ec.rd_combo) as rd_combo,
    coalesce(x.bn_id, x_bn.bn_id, ebn.bn_id, 0) as bn_id
  from c
  left join x_pattern x on c.qd_combo=x.qd_combo and c.bn_code=nvl(x.bn_code, c.bn_code)
  left join x_d_combo combo on c.qd_combo=combo.qd_combo 
  left join extension_combo ec on c.qd_combo=ec.qd_combo
  left join x_bn on c.bn_code=x_bn.bn_code left join extension_bn ebn on c.bn_code=ebn.bn_code
) m
left join (select concept_code, i_combo as qi_combo, d_combo as qd_combo, bn_code from existing_q where quant_value=0 and df_code=' ' and bs=0 and mf_code=' ') using(qi_combo, qd_combo, bn_code)
left join (select concept_id, i_combo as ri_combo, d_combo as rd_combo, bn_id from existing_r where quant_value=0 and df_id=0 and bs=0 and mf_id=0) using(ri_combo, rd_combo, bn_id)
;
commit;

-- Break up multi-ingredient ds and r for Clinical Drug Components
drop table singleton_q purge;
create table singleton_q nologging as 
select distinct d_combo as qd_combo, i_code as q_i, ds_code as q_ds
from q_combo join q_ds using(concept_code) 
;
drop table singleton_r purge;
create table singleton_r nologging as 
  select distinct d_combo as rd_combo, i_code as r_i, ds_code as r_ds from r_ds join r_combo using(concept_id) 
union
  select distinct rd_combo, r_i, r_ds from extension_combo left join extension_ds on d_combo=qd_combo where d_combo!=' '
;

-- Clinical Drug Component
-- Definition: broken up d_combo, no quant, df, bn bs and mf
insert /*+ APPEND */ into full_corpus
with ex as (
  select q_i as qi_combo, cast(q_ds as varchar2(50)) as qd_combo, r_i as ri_combo, cast(r_ds as varchar2(50)) as rd_combo
-- get all singleton translations
  from (select distinct qd_combo, rd_combo from full_corpus)
-- break up qd_combo
  join singleton_q using(qd_combo)
  -- break up rd_combo
  join singleton_r using(rd_combo)
-- combine the ones that belong together
  join (
    select q_ds, r_ds from extension_ds
  union
    select ds_code, ds_code from q_uds -- the same ds_code is used for both q and r, if r is a newly created extension_uds
  ) using(q_ds, r_ds)
),
c as (
  select
    q_i as qi_combo, cast(q_ds as varchar2(50)) as qd_combo
  from q_combo
  join singleton_q on d_combo=qd_combo
  where d_combo!=' ' 
minus
-- exclude the combinations already translated previously
  select qi_combo, qd_combo from ex
)
select
  concept_code, concept_id,
  0 as q_value, ' ' as quant_unit, qi_combo, qd_combo, ' ' as df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
  0 as r_value, 0 as quant_unit_id, ri_combo, rd_combo, 0 as df_id, 0 as bn_id, 0 as mf_id,
  'Clinical Drug Comp' as concept_class_id
from (
-- Collect existing
  select * from ex
union
  select distinct
    c.*,
    coalesce(first_value(x.ri_combo) over (partition by x.qd_combo order by x.prec), combo.ri_combo, ec.ri_combo) as ri_combo,
    coalesce(first_value(x.rd_combo) over (partition by x.qd_combo order by x.prec), combo.rd_combo, ec.rd_combo) as rd_combo
  from c
  left join x_pattern x on c.qd_combo=x.qd_combo
  left join x_d_combo combo on c.qd_combo=combo.qd_combo 
  left join extension_combo ec on c.qd_combo=ec.qd_combo
) m
left join (select concept_code, i_combo as qi_combo, d_combo as qd_combo from existing_q where quant_value=0 and df_code=' ' and bn_code=' ' and bs=0 and mf_code=' ') using(qi_combo, qd_combo)
left join (select concept_id, i_combo as ri_combo, d_combo as rd_combo from existing_r where quant_value=0 and df_id=0 and bn_id=0 and bs=0 and mf_id=0) using(ri_combo, rd_combo)
;
commit;

-- Create full set of extensions with all attribute (left side of full_corpus)
-- It includes the existing concepts with positive existing concept_id
drop table extension_attribute purge;
create table extension_attribute nologging as
select extension_id.nextval as concept_id, e.*
from ( -- make new ones
  select distinct r_value, quant_unit_id, ri_combo, rd_combo, df_id, bn_id, bs, mf_id, concept_class_id from full_corpus where concept_id is null
) e
;

-- Add existing
insert /*+ Append */ into extension_attribute 
select distinct concept_id, r_value, quant_unit_id, ri_combo, rd_combo, df_id, bn_id, bs, mf_id, concept_class_id from full_corpus where concept_id is not null
;
commit;

-- Create ea in both concept_id and concept_code/vocabulary_id notation
drop table ex purge;
create table ex nologging as -- create extension_attribute in concept_code/vocabulary_id notation
select 
  nvl(c.concept_code, cs.concept_code) as concept_code, nvl(c.vocabulary_id, cs.vocabulary_id) as vocabulary_id, 
  concept_id, r_value, quant_unit_id, ri_combo, rd_combo, df_id, bn_id, bs, mf_id, extension_attribute.concept_class_id
from extension_attribute left join concept c using(concept_id) left join concept_stage cs using(concept_id)
;

-- Connect existing_q concept codes (from drug_concept_stage) to existing corpus or new extensions
drop table maps_to purge;
create table maps_to nologging as
select fc.concept_code as from_code, ea.concept_id as to_id
from full_corpus fc join extension_attribute ea using(r_value, quant_unit_id, ri_combo, rd_combo, df_id, bn_id, bs, mf_id) where concept_code is not null
;
commit;

/*******************
* 11. Create names *
*******************/

-- Auto-generate all names 
-- Create RxNorm-style units. UCUM units have no normalized abbreviation
drop table rxnorm_unit purge;
create table rxnorm_unit (rxn_unit varchar2(20), concept_id integer not null);
insert  into rxnorm_unit (rxn_unit, concept_id) values ('ORGANISMS', 45744815); -- Organisms, UCUM calls it {bacteria}
insert  into rxnorm_unit (rxn_unit, concept_id) values ('%', 8554);
insert  into rxnorm_unit (rxn_unit, concept_id) values ('ACTUAT', 45744809); -- actuation
insert  into rxnorm_unit (rxn_unit, concept_id) values ('AU', 45744811); -- allergenic unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('BAU', 45744810); -- bioequivalent allergenic unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('CELLS', 45744812); -- cells
insert  into rxnorm_unit (rxn_unit, concept_id) values ('CFU', 9278); -- colony forming unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('CU', 45744813); -- clinical unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('HR', 8505); -- hour
insert  into rxnorm_unit (rxn_unit, concept_id) values ('IU', 8718); -- International unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('LFU', 45744814); -- limit of flocculation unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('MCI', 44819154); -- millicurie
insert  into rxnorm_unit (rxn_unit, concept_id) values ('MEQ', 9551); -- milliequivalent
insert  into rxnorm_unit (rxn_unit, concept_id) values ('MG', 8576); -- milligram
insert  into rxnorm_unit (rxn_unit, concept_id) values ('MIN', 9367); -- minim
insert  into rxnorm_unit (rxn_unit, concept_id) values ('ML', 8587);
insert  into rxnorm_unit (rxn_unit, concept_id) values ('MMOL', 9573);
insert  into rxnorm_unit (rxn_unit, concept_id) values ('MU', 9439); -- mega-international unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('PFU', 9379); -- plaque forming unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('PNU', 45744816); -- protein nitrogen unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('SQCM', 9483); -- square centimeter
insert  into rxnorm_unit (rxn_unit, concept_id) values ('TCID', 9414); -- 50% tissue culture infectious dose
insert  into rxnorm_unit (rxn_unit, concept_id) values ('UNT', 8510); -- unit
insert  into rxnorm_unit (rxn_unit, concept_id) values ('IR', 9693); -- index of reactivity
insert  into rxnorm_unit (rxn_unit, concept_id) values ('X', 9325); -- Decimal potentiation of homeopathic drugs
insert  into rxnorm_unit (rxn_unit, concept_id) values ('C', 9324); -- Centesimal potentation of homoeopathic drugs
insert  into rxnorm_unit (rxn_unit, concept_id) values ('', 0); -- empty
commit;

-- collect statistics so Oracle does the following in a reasonable approach
exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'full_corpus', estimate_percent  => null, cascade  => true);
exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'extension_combo', estimate_percent  => null, cascade  => true);

-- create components
drop table spelled_out purge;
create table spelled_out nologging as
with n as ( -- translate i_code to ingredient name
  select i_code, concept_name from ing_stage join concept on concept.concept_id=i_id
union
  select ri_code, concept_name from extension_i join drug_concept_stage on concept_code=qi_code
),
-- Get all ds
ds_comp as (
  select 
    -- ds_code, i_code, 
    d_combo as rd_combo, concept_name,
    amount_value+numerator_value as v, -- one of them is null
    case
      when numerator_unit_concept_id in (8554, 9325, 9324) then nu.rxn_unit -- percent and homeopathics 
      when numerator_value!=0 then nu.rxn_unit||'/'||de.rxn_unit -- concentration (liquid)
      else au.rxn_unit -- absolute (solid)
    end as u
  from ( -- get details on uds in r
    select * from extension_uds union
    select * from r_uds -- adding them even though they already exist because they might be one of many components
  )
  join ( -- get combo to ds_code and i_code resolution
    select distinct d_combo, ds_code from r_ds join r_combo using(concept_id)
  union
    select distinct rd_combo, r_ds from extension_combo left join extension_ds on d_combo=qd_combo
  ) using(ds_code)
  join n using(i_code) -- get name
-- translate units back to RxNorm lingo
  left join rxnorm_unit au on au.concept_id=amount_unit_concept_id
  left join rxnorm_unit nu on nu.concept_id=numerator_unit_concept_id
  left join rxnorm_unit de on de.concept_id=denominator_unit_concept_id
),
-- Add a 0 before a leading dot
u as (
  select
    rd_combo,
    concept_name||case when v is null then null else ' '||regexp_replace(v, '^\.', '0.') ||' '||u end as comp_name
  from ds_comp
)
-- build the component
select
  c.concept_id,
  case when c.r_value=0 then '' else regexp_replace(r_value, '^\.', '0.')||' '||first_value(q.rxn_unit) ignore nulls over (partition by c.concept_id)||' ' end as quant,
  comp.comp_name,
  sum(comp.comp_len) over (partition by c.concept_id order by comp.comp_name rows between unbounded preceding and current row) as agg_len,
  case when df_id=0 then '' else ' '||nvl(edf.concept_name, df.concept_name) end as df_name,
  case when bn_id=0 then '' else ' ['||nvl(ebn.concept_name, bn.concept_name)||']' end as bn_name,
  case when c.bs=0 then '' else ' Box of '||c.bs end as box,
  case when mf_id=0 then ''
-- remove stop words
    else ' by '||replace(replace(replace(replace(replace(replace(replace(replace(nvl(emf.concept_name, mf.concept_name), ' Ltd'), ' Plc'), ' UK'), ' (UK)'), ' Pharmaceuticals'), ' Pharma'), ' GmbH'), 'Laboratories') 
  end as mf_name
from extension_attribute c
join ( -- resolve the rd_combo to uds details
  select rd_combo, comp_name, length(comp_name)+3 as comp_len -- length plus 3 characters for ' / '
  from u
) comp using(rd_combo)
-- get quant unit in RxNorm notation
left join rxnorm_unit q on q.concept_id=c.quant_unit_id
-- get dose form from Rx or source
left join extension_df edf using(df_id)
left join concept df on df_id=df.concept_id
-- get brand name from Rx or source
left join extension_bn ebn using(bn_id)
left join concept bn on bn_id=bn.concept_id
-- get supplier
left join extension_mf emf using(mf_id)
left join concept mf on mf_id=mf.concept_id
where c.concept_id<0 and rd_combo!=' ' -- Exclude Drug Forms, do these in the next step
;
commit;

-- Add Drug Forms
insert /*+ APPEND */ into spelled_out
with n as ( -- translate i_code to ingredient name
  select i_code, concept_name from ing_stage join concept on concept.concept_id=i_id
union
  select ri_code, concept_name from extension_i join drug_concept_stage on concept_code=qi_code
),
-- Get all i_combos
u as (
  select 
    i_combo as ri_combo, concept_name as comp_name
  from (
-- get combo to i_code resolution
    select ri_combo as i_combo, trim(regexp_substr(ri_combo, '[^\-]+', 1, levels.column_value)) as i_code
    from (select distinct ri_combo from extension_attribute where concept_id<0), -- extension_combo contains i_combos as well
    table(cast(multiset(select level from dual connect by level <= length (regexp_replace(ri_combo, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
  )
  join n using(i_code) -- get name
)
-- build the component
select 
  c.concept_id,
  '' as quant,
  comp.comp_name,
  sum(comp.comp_len) over (partition by c.concept_id order by comp.comp_name rows between unbounded preceding and current row) as agg_len,
  case when df_id=0 then '' else ' '||nvl(edf.concept_name, df.concept_name) end as df_name,
  case when bn_id=0 then '' else ' ['||nvl(ebn.concept_name, bn.concept_name)||']' end as bn_name,
  '' as box,
  '' as mf_name
from extension_attribute c
join (
  select ri_combo, comp_name, length(comp_name)+3 as comp_len -- length plus 3 characters for ' / '
  from u
) comp using(ri_combo)
-- get dose form from Rx or source
left join extension_df edf using(df_id)
left join concept df on df_id=df.concept_id
-- get brand name from Rx or source
left join extension_bn ebn using(bn_id)
left join concept bn on bn_id=bn.concept_id
-- get supplier
where c.concept_id<0 and rd_combo=' ' -- Only Drug Forms
;
commit;

drop table extension_name purge;
create table extension_name (
  concept_id number,
  concept_name varchar2(255)
);
commit;

-- Create names 
insert /*+ APPEND */ into extension_name
select
  concept_id,
-- count the cumulative length of the components. The tildas are to make sure the three dots are put at the end of the list
  replace(quant||listagg(comp_name, ' / ') within group (order by upper(comp_name))||df_name||bn_name||box||mf_name, '~~~', '...') as concept_name
from (
-- keep only components where concatenation will leave enough space for the quant, dose form, brand name and box size
  select * from spelled_out s
  where s.agg_len<=253-(nvl(length(s.quant), 0)+nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+nvl(length(s.box), 0)+nvl(length(s.mf_name), 0)+3)
-- Add three dots if ingredients are to be cut
union
  select 
    concept_id,
    quant,
    '~~~' as comp_name, -- last ASCII character to make sure they get sorted towards the end.
    1 as agg_len,
    df_name,
    bn_name,
    box,
    mf_name
  from spelled_out s
  where s.agg_len>253-(nvl(length(s.quant), 0)+nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+nvl(length(s.box), 0)+nvl(length(s.mf_name), 0)+6)
  group by quant, concept_id, df_name, bn_name, box, mf_name 
)
group by quant, concept_id, df_name, bn_name, box, mf_name 
;
commit;

/********************
* 12. Process Packs *
********************/

-- create XXX type concept_codes for new packs
drop table pack_seq purge;
create table pack_seq as
select
  pack_concept_code, omop_seq.nextval as pack_concept_id 
from pc_stage
;
commit;

-- create a complete set of packs with attributes
drop table existing_pack purge;
create table existing_pack as
select distinct -- because the content in some packs, albeit different in drug_concept_stage, becomes identical after mapping
  pack_concept_code, maps_to.to_id as drug_concept_id, nvl(amount, 0) as amount, nvl(box_size, 0) as bs, nvl(bn_id, 0) as bn_id, nvl(mf_id, 0) as mf_id,
  case
    when mf_id is not null then 'Marketed Product'
    when box_size is not null and bn_id is not null then 'Branded Pack Box'
    when box_size is not null then 'Clinical Pack Box'
    when bn_id is not null then 'Branded Pack'
    else 'Clinical Pack'
  end as concept_class_id
from pc_stage
-- Component drug
join maps_to on drug_concept_code=from_code -- all components should exist, either in RxE or in the new tables
left join ( -- Obtain Brand Name if exists, could be more than one effective r_to_c
  select distinct concept_code, nvl(x.bn_id, ex.bn_id) as bn_id from q_bn left join x_bn x using(bn_code) left join extension_bn ex using(bn_code)
) q_bn on q_bn.concept_code=pack_concept_code 
left join ( -- Obtain Supplier if exists, could be more than one effective r_to_c
  select distinct concept_code, nvl(x.mf_id, ex.mf_id) as mf_id from q_mf left join x_mf x using(mf_code) left join extension_mf ex using(mf_code)
) q_mf on q_mf.concept_code=pack_concept_code
;
commit;

-- Create pack hierarchy
drop table complete_pack purge;
create table complete_pack as
select * from existing_pack where concept_class_id='Marketed Product';

-- Branded Pack Box. Definition: bn and bs, but no mf.
insert into complete_pack
select pack_concept_code, drug_concept_id, amount, bs, bn_id, 0 as mf_id, 'Branded Pack Box' as concept_class_id 
from (
  select pack_concept_code, drug_concept_id, amount, bs, bn_id from complete_pack
union
  select pack_concept_code, drug_concept_id, amount, bs, bn_id from existing_pack where bs!=0 and bn_id!=0 and mf_id=0
);
commit;

-- Clinical Pack Box. Definition: bs, but no bn or mf.
insert into complete_pack
select pack_concept_code, drug_concept_id, amount, bs, 0 as bn_id, 0 as mf_id, 'Clinical Pack Box' as concept_class_id 
from (
  select pack_concept_code, drug_concept_id, amount, bs from complete_pack
union
  select pack_concept_code, drug_concept_id, amount, bs from existing_pack where bs!=0 and bn_id=0 and mf_id=0
);

-- Branded Pack. Definition: bn, but no bs or mf.
insert into complete_pack
select pack_concept_code, drug_concept_id, amount, 0 as bs, bn_id, 0 as mf_id, 'Branded Pack' as concept_class_id 
from (
  select pack_concept_code, drug_concept_id, amount, bn_id from complete_pack
union
  select pack_concept_code, drug_concept_id, amount, bn_id from existing_pack where bn_id!=0 and bs=0 and mf_id=0
);

-- Clinical Pack. Definition: neither bn, bs nor mf.
insert into complete_pack
select pack_concept_code, drug_concept_id, amount, 0 as bs, 0 as bn_id, 0 as mf_id, 'Clinical Pack' as concept_class_id 
from (
  select pack_concept_code, drug_concept_id, amount from complete_pack
union
  select pack_concept_code, drug_concept_id, amount from existing_pack where bn_id=0 and bs=0 and mf_id=0
);
commit;

-- Match to existing 
drop table qr_pack purge;
create table qr_pack nologging as
with q_pc as (
  select pack_concept_code, drug_concept_id, amount, bs, bn_id, mf_id, cnt from complete_pack join(select pack_concept_code, count(8) as cnt from complete_pack group by pack_concept_code having count(8)>1) using(pack_concept_code)
),
pc as (
  select pack_concept_id, drug_concept_id, nvl(amount, 0) as amount, nvl(box_size, 0) as bs, nvl(bn_id, 0) as bn_id, nvl(mf_id, 0) as mf_id
  from pack_content pc
  left join r_bn on drug_concept_id=r_bn.concept_id
  left join r_mf on drug_concept_id=r_mf.concept_id
  join concept on pack_concept_id=concept.concept_id and vocabulary_id='RxNorm'
),
r_pc as (-- includes counts of components
  select pack_concept_id, drug_concept_id, amount, bs, bn_id, mf_id, cnt from pc join(select pack_concept_id, count(8) as cnt from pc group by pack_concept_id having count(8)>1) using(pack_concept_id)
)
select distinct pack_concept_code, pack_concept_id from q_pc join r_pc using(drug_concept_id, amount, bs, bn_id, mf_id, cnt)
order by 1;
commit;

drop table pack_name purge;
create table pack_name as
-- Get the component parts
with c as (
  select 
    cp.pack_concept_code,
    case when cp.amount is null then '' else cp.amount||' ' end||'('||coalesce(cr.concept_name, en.concept_name) as content_name,
    case when cp.amount is null then 0 else length(cp.amount)+1 end as a_len, -- length of the amount
    length(coalesce(cr.concept_name, en.concept_name)) as n_len -- length of the concept_name
  from complete_pack cp
  left join concept cr on cr.concept_code=cp.drug_concept_code and cr.vocabulary_id=cp.drug_vocab
  left join extension_name en on en.concept_code=cp.drug_concept_code and cp.drug_vocab='RxNorm Extension'
--  left join drug_concept_stage cd on cd.concept_code=cp.drug_concept_code and cp.drug_vocab is null
),
-- Get the common part
pd as (
  select distinct
    cp.pack_concept_code, 
    case when cp.bn_code is null then '' else ' ['||nvl(br.concept_name, x_bn.q_name)||']' end as brand_name,
    case when cp.box_size is null then '' else ' box of '||box_size||' ' end as bs_name,
    case when cp.supplier_code is null then '' else ' by '||nvl(sr.concept_name, x_mf.q_name) end as supplier_name
  from complete_pack cp
  left join concept br on br.concept_code=cp.bn_code and br.vocabulary_id=cp.brand_vocab
  left join x_bn on x_bn.r_code=cp.bn_code and cp.brand_vocab='RxNorm Extension' and x_bn.r_vocab is null
  left join concept sr on sr.concept_code=cp.supplier_code and sr.vocabulary_id=cp.supplier_vocab
  left join x_mf on x_mf.r_code=cp.supplier_code and cp.supplier_vocab='RxNorm Extension' and x_mf.r_vocab is null
),
-- Calculate total length of everything if space weren't the issue, and then calculate the factor that each concept_name needs to be shortened by
p as (
  select 
    pd.pack_concept_code,
    pd.brand_name||pd.bs_name||pd.supplier_name as concept_name,
    nvl(length(pd.bs_name), 0)+nvl(length(pd.brand_name), 0)+nvl(length(pd.supplier_name), 0) as len -- length of the Brand Name of the Pack plus extra characters making up the name minus the ' / ' at the last component
    from pd
),
l as (
  select pack_concept_code, 
    (245-all_a_len-p.len)/all_n_len as factor -- 255-10 for common pack text (curly brackets, spaces)
  from (
    select distinct
      pack_concept_code,
      sum(n_len) over (partition by pack_concept_code) as all_n_len, -- 7: slashes, parentheses and spaces, minus the trailing ' / '
      sum(a_len+5) over (partition by pack_concept_code) -3 as all_a_len -- 7: slashes, parentheses and spaces, minus the trailing ' / '
    from c
  ) 
  join p using(pack_concept_code)
),
-- Cut the individual components by the factor and add ...
c_p as (
  select 
    pack_concept_code,
    case when l.factor<1 then substr(c.content_name, 1, c.n_len*l.factor-3)||'...' else c.content_name end as concept_name
  from l join c using(pack_concept_code)
)
select 
  pack_concept_code,
  '{'||listagg(c_p.concept_name, ') / ') within group (order by c_p.concept_name) ||') } Pack'||p.concept_name as concept_name
from c_p -- components, possibly trimmed
join p using(pack_concept_code) -- common part
group by pack_concept_code, p.concept_name -- aggregate within concept_code
;
commit;

-- Temporary till stable xxxxxxxxxxxxxxxxxx
insert /*+ APPEND */ into pack_q_to_r
select pn.pack_concept_code, c.concept_id as clinical, null as branded, null as supplied, null as marketed, null as neither
from pack_name pn join concept c using (concept_name) where c.vocabulary_id like 'RxNorm%' and invalid_reason is null 
and not exists ( select 1 from pack_q_to_r pqr where pn.pack_concept_code=pqr.pack_concept_code
);
*/

/****************************
* 13. Write RxNorm Extension *
****************************/

-- Create sequence that starts after existing OMOP???-style concept codes
drop sequence omop_seq; 
/* XXXX uncomment
declare
 ex number;
begin
select max(iex)+1 into ex from (  
    select cast(substr(concept_code, 5) as integer) as iex from drug_concept_stage where concept_code like 'OMOP%' and concept_code not like '% %' -- Last valid value of the OMOP123-type codes
  union
    select cast(substr(concept_code, 5) as integer) as iex from concept where concept_code like 'OMOP%' and concept_code not like '% %'
);
  begin
    execute immediate 'create sequence omop_seq increment by 1 start with ' || ex || ' nocycle cache 20 noorder';
    exception
      when others then null;
  end;
end;
*/

truncate table concept_stage;
truncate table concept_relationship_stage;
truncate table drug_strength_stage;

-- Write RxNorm Extension into concept_stage
-- Write Ingredients that have no equivalent. Ingredients are written in code notation. Therefore, concept_id is null, and the XXX code is in concept_code
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select
  null as concept_id,
  dcs.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  'Ingredient' as concept_class_id,
  'S' as standard_concept,
  ri_code, -- XXX code, rather than original from dcs. Will be replaced with OMOP???-style concept_code
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
  nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  null as invalid_reason
from extension_i
join drug_concept_stage dcs on qi_code=dcs.concept_code
;
commit;

-- Write Dose Forms that have no equivalent. Dose forms have negative ids
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select
  df_id as concept_id, -- will be replaced with null after writing all relationships
  dcs.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  'Dose Form' as concept_class_id,
  null as standard_concept,
  'OMOP'||omop_seq.nextval as concept_code, 
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
  nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  null as invalid_reason
from extension_df
join drug_concept_stage dcs on df_code=dcs.concept_code
;
commit;

-- Write Brand Name that have no equivalent
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select
  bn_id as concept_id, -- will be replaced with null after writing all relationships
  dcs.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  'Brand Name' as concept_class_id,
  null as standard_concept,
  'OMOP'||omop_seq.nextval as concept_code, 
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
  nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  null as invalid_reason
from extension_bn
join drug_concept_stage dcs on bn_code=dcs.concept_code
;
commit;

-- Write Supplier that have no equivalent
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select
  mf_id as concept_id, -- will be replaced with null after writing all relationships
  dcs.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  'Supplier' as concept_class_id,
  null as standard_concept,
  'OMOP'||omop_seq.nextval as concept_code, 
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
  nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  null as invalid_reason
from extension_mf
join drug_concept_stage dcs on mf_code=dcs.concept_code
;
commit;

-- Write drug concepts from extension_attribute
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select
  concept_id,
  en.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  ea.concept_class_id,
  'S' as standard_concept, -- Standard Concept 
  'OMOP'||omop_seq.nextval as concept_code, 
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from extension_attribute ea
join extension_name en using(concept_id) -- limits it to only negative (new) concept_ids
;
commit;

-- write RxNorm-like relationships between concepts of all classes except Drug Forms and Clinical Drug Component based on matching components
drop table rl purge;
create table rl (
concept_class_1 varchar2(20),
relationship_id varchar2(20),
concept_class_2 varchar2(20)
);
insert into rl
select 'Brand Name', 'Brand name of', 'Branded Drug Box' from dual union
select 'Brand Name', 'Brand name of', 'Branded Drug Comp' from dual union
select 'Brand Name', 'Brand name of', 'Branded Drug Form' from dual union
select 'Brand Name', 'Brand name of', 'Branded Drug' from dual union
select 'Brand Name', 'Brand name of', 'Branded Pack' from dual union
select 'Brand Name', 'Brand name of', 'Branded Pack Box' from dual union
select 'Brand Name', 'Brand name of', 'Marketed Product' from dual union
select 'Brand Name', 'Brand name of', 'Quant Branded Box' from dual union
select 'Brand Name', 'Brand name of', 'Quant Branded Drug' from dual union
select 'Branded Drug Box', 'Has marketed form', 'Marketed Product' from dual union
select 'Branded Drug Box', 'Has quantified form', 'Quant Branded Box' from dual union
select 'Branded Drug Comp', 'Constitutes', 'Branded Drug' from dual union
select 'Branded Drug Form', 'RxNorm inverse is a', 'Branded Drug' from dual union
select 'Branded Drug', 'Available as box', 'Branded Drug Box' from dual union
select 'Branded Drug', 'Has marketed form', 'Marketed Product' from dual union
select 'Branded Drug', 'Has quantified form', 'Quant Branded Drug' from dual union
select 'Clinical Drug Box', 'Has marketed form', 'Marketed Product' from dual union
select 'Clinical Drug Box', 'Has quantified form', 'Quant Clinical Box' from dual union
select 'Clinical Drug Box', 'Has tradename', 'Branded Drug Box' from dual union
select 'Clinical Drug Comp', 'Constitutes', 'Clinical Drug' from dual union
select 'Clinical Drug Comp', 'Has tradename', 'Branded Drug Comp' from dual union
select 'Clinical Drug Form', 'Has tradename', 'Branded Drug Form' from dual union
select 'Clinical Drug Form', 'RxNorm inverse is a', 'Clinical Drug' from dual union
select 'Clinical Drug', 'Available as box', 'Clinical Drug Box' from dual union
select 'Clinical Drug', 'Has marketed form', 'Marketed Product' from dual union
select 'Clinical Drug', 'Has quantified form', 'Quant Clinical Drug' from dual union
select 'Clinical Drug', 'Has tradename', 'Branded Drug' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Branded Drug Box' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Branded Drug Form' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Branded Drug' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Branded Pack' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Clinical Drug Box' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Clinical Drug Form' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Clinical Drug' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Clinical Pack' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Marketed Product' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Quant Branded Box' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Quant Branded Drug' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Quant Clinical Box' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Quant Clinical Drug' from dual union
select 'Ingredient', 'Has brand name', 'Brand Name' from dual union
select 'Ingredient', 'RxNorm ing of', 'Clinical Drug Comp' from dual union
select 'Ingredient', 'RxNorm ing of', 'Clinical Drug Form' from dual union
select 'Marketed Product', 'Has Supplier', 'Supplier' from dual union 
select 'Supplier', 'Supplier of', 'Marketed Product' from dual union
select 'Quant Branded Box', 'Has marketed form', 'Marketed Product' from dual union
select 'Quant Branded Drug', 'Available as box', 'Quant Branded Box' from dual union
select 'Quant Branded Drug', 'Has marketed form', 'Marketed Product' from dual union
select 'Quant Clinical Box', 'Has marketed form', 'Marketed Product' from dual union
select 'Quant Clinical Box', 'Has tradename', 'Quant Branded Box' from dual union
select 'Quant Clinical Drug', 'Available as box', 'Quant Clinical Box' from dual union
select 'Quant Clinical Drug', 'Has marketed form', 'Marketed Product' from dual union
select 'Quant Clinical Drug', 'Has tradename', 'Quant Branded Drug' from dual
;
commit;

-- Write inner-RxNorm Extension relationships, mimicking RxNorm
-- Everything but the Drug Forms, Clinical Drug Comp and Marketed Products
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct -- because several of them can map to the same existing RxE creating duplicates
  an.concept_code as concept_code_1, 
  an.vocabulary_id as vocabulary_id_1,
  de.concept_code as concept_code_2,
  de.vocabulary_id as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex de
join rl on rl.concept_class_2=de.concept_class_id 
  and rl.concept_class_1 not in ('Clinical Drug Form', 'Branded Drug Form', 'Clinical Drug Comp') -- these have no valid d_combo, or the d_combo has to be decomposed
join ex an
  on rl.concept_class_1=an.concept_class_id
    and de.rd_combo=an.rd_combo -- the d_combos have to match completely
    and de.r_value=case an.r_value when 0 then de.r_value else an.r_value end -- the descendant may not have quants
    and de.quant_unit_id=case an.quant_unit_id when 0 then de.quant_unit_id else an.quant_unit_id end
    and de.df_id=case an.df_id when 0 then de.df_id else an.df_id end -- the descedant may not have a df
    and de.bn_id=case an.bn_id when 0 then de.bn_id else an.bn_id end -- the descendant may not have a bn
    and de.bs=case an.bs when 0 then de.bs else an.bs end -- the descendant may not have bs
    and de.concept_id!=an.concept_id -- to avoid linking to self
where de.concept_class_id not in ('Clinical Drug Comp', 'Clinical Drug Form', 'Clinical Drug', 'Branded Drug Form', 'Marketed Product')
  and de.concept_id<0 -- descendant has to be a new extension, otherwise we are writing existing relationships
;
commit;

-- Marketed Products: Everything has to agree except Supplier. There are not links amongst Marketed Product, everything links up to the next level
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  an.concept_code as concept_code_1, 
  an.vocabulary_id as vocabulary_id_1,
  de.concept_code as concept_code_2,
  de.vocabulary_id as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex de 
join rl on rl.concept_class_2=de.concept_class_id and rl.concept_class_1!='Marketed Product' -- need to exclude otherwise it's linking Marketed to Marketed, which are not defined
join ex an
  on rl.concept_class_1=an.concept_class_id
    and de.rd_combo=an.rd_combo -- the d_combos have to match completely
    and de.r_value=case an.r_value when 0 then de.r_value else an.r_value end -- the descendant may not have quants
    and de.quant_unit_id=case an.quant_unit_id when 0 then de.quant_unit_id else an.quant_unit_id end
    and de.df_id=case an.df_id when 0 then de.df_id else an.df_id end -- the descedant may not have a df
    and de.bn_id=case an.bn_id when 0 then de.bn_id else an.bn_id end -- the descendant may not have a bn
    and de.bs=case an.bs when 0 then de.bs else an.bs end -- the descendant may not have bs
    and de.concept_id!=an.concept_id -- to avoid linking to self
where de.concept_class_id ='Marketed Product'
  and de.concept_id<0 -- descendant has to be a new extension, otherwise we are writing existing relationships
;
commit;

-- Drug Forms
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  an.concept_code as concept_code_1, 
  an.vocabulary_id as vocabulary_id_1,
  de.concept_code as concept_code_2,
  de.vocabulary_id as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex de 
join rl on rl.concept_class_2=de.concept_class_id 
  and rl.concept_class_1 in ('Clinical Drug Form', 'Branded Drug Form') -- these have i_combo to share with their descendants
join ex an
  on rl.concept_class_1=an.concept_class_id
    and de.ri_combo=an.ri_combo -- the i_combos have to match completely
    and de.df_id=case an.df_id when 0 then de.df_id else an.df_id end -- the descedant may not have a df
    and de.bn_id=case an.bn_id when 0 then de.bn_id else an.bn_id end -- the descendant may not have a bn
    and de.concept_id!=an.concept_id -- to avoid linking to self
where de.concept_id<0 -- descendant has to be a new extension, otherwise we are writing existing relationships
;
commit;

-- Clinical Drug Comp - ds_combo is really only singleton q_ds and needs be decomposed
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  an.concept_code as concept_code_1, 
  an.vocabulary_id as vocabulary_id_1,
  de.concept_code as concept_code_2,
  de.vocabulary_id as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ( -- Create de that has ds_code instead of d_combo by splitting them up
  select cast(r_ds as varchar2(50)) as r_ds, -- component ds from rd_combo
  concept_code, vocabulary_id, concept_id, r_value, quant_unit_id, rd_combo, df_id, bn_id, bs, mf_id, concept_class_id
  from ex join singleton_r using(rd_combo)
  where concept_class_id in ('Clinical Drug', 'Branded Drug Comp') -- the only concept class it connects to
) de 
join rl on rl.concept_class_2=de.concept_class_id and rl.concept_class_1='Clinical Drug Comp'
join ex an
  on an.concept_class_id='Clinical Drug Comp'
    and de.r_ds=an.rd_combo -- the q_ds has to match the d_combo of the Clinical Drug Comp
    and de.concept_code!=an.concept_code 
where de.concept_id<0
;
commit;

-- Ingredient to Clinical Drug Comp
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  an.concept_code as concept_code_1, 
  an.vocabulary_id as vocabulary_id_1,
  de.concept_code as concept_code_2,
  de.vocabulary_id as vocabulary_id_2,
  relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex de
join rl on concept_class_2=de.concept_class_id and concept_class_1 in ('Ingredient')
join ( -- resolve ri_combo ingredients
  select i_code, concept_code, vocabulary_id from ing_stage join concept on concept.concept_id=i_id
union
  select ri_code, ri_code, 'RxNorm Extension' from extension_i
) an on an.i_code=de.ri_combo
where concept_class_id='Clinical Drug Comp' and concept_id<0
;
commit;

-- Ingredients to Clinical Drug Form 
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  an.concept_code as concept_code_1, 
  an.vocabulary_id as vocabulary_id_1,
  de.concept_code as concept_code_2,
  de.vocabulary_id as vocabulary_id_2,
  (select relationship_id from rl where rl.concept_class_1 in ('Ingredient') and rl.concept_class_2='Clinical Drug Form') as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex de
join ( -- resolve ri_combo into i_codes and create rx notation
  select ri_combo, concept_code, vocabulary_id
  from (select distinct ri_combo from extension_attribute where concept_id<0), 
  ( -- resolve ri_combo ingredients
    select i_code, concept_code, vocabulary_id from ing_stage join concept on concept.concept_id=i_id
  union
    select ri_code, ri_code, 'RxNorm Extension' from extension_i
  ), 
  table(cast(multiset(select level from dual connect by level <= length (regexp_replace(ri_combo, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
  where trim(regexp_substr(ri_combo, '[^\-]+', 1, levels.column_value))=i_code
) an using(ri_combo)
where de.concept_id<0 and de.concept_class_id='Clinical Drug Form'
;
commit;

-- Write attribute relationships
-- Dose Forms
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  df.concept_code as concept_code_1,
  df.vocabulary_id as vocabulary_id_1,
  ex.concept_code as concept_code_2,
  ex.vocabulary_id as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex
join rl on concept_class_1='Dose Form' and concept_class_2=concept_class_id
join ( -- resolve df_id - either into existing concept or extension_df
  select concept_code, vocabulary_id, concept_id as df_id from concept where vocabulary_id in ('RxNorm', 'RxNorm Extension') and concept_class_id='Dose Form'
union
  select df_code, 'RxNorm Extension', df_id from extension_df -- the negatives
) df using(df_id)
where ex.concept_id<0 and df_id!=0
;
commit;

-- Brand Name 
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  bn.concept_code as concept_code_1,
  bn.vocabulary_id as vocabulary_id_1,
  ex.concept_code as concept_code_2,
  ex.vocabulary_id as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex
join rl on concept_class_1='Brand Name' and concept_class_2=concept_class_id
join ( -- resolve bn_id - either into existing concept or extension_bn
  select concept_code, vocabulary_id, concept_id as bn_id from concept where vocabulary_id in ('RxNorm', 'RxNorm Extension') and concept_class_id='Brand Name'
union
  select bn_code, 'RxNorm Extension', bn_id from extension_bn -- the negatives
) bn using(bn_id)
where ex.concept_id<0 and bn_id!=0
;
commit;

-- Suppliers
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  mf.concept_code as concept_code_1,
  mf.vocabulary_id as vocabulary_id_1,
  ex.concept_code as concept_code_2,
  ex.vocabulary_id as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex
join rl on concept_class_1='Supplier' and concept_class_2=concept_class_id
join ( -- resolve mf_id - either into existing concept or extension_mf
  select concept_code, vocabulary_id, concept_id as mf_id from concept where vocabulary_id in ('RxNorm', 'RxNorm Extension') and concept_class_id='Supplier'
union
  select mf_code, 'RxNorm Extension', mf_id from extension_mf -- the negatives
) mf using(mf_id)
where ex.concept_id<0 and mf_id!=0
;
commit;

-- Write relationships between Brand Name and Ingredient
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
with ri_bn as (
  select distinct ri_combo, bn_id from extension_attribute where concept_id<0
)
select distinct
  ing.concept_code as concept_code_1, 
  ing.vocabulary_id as vocabulary_id_1,
  bn.concept_code as concept_code_2,
  bn.vocabulary_id as vocabulary_id_2,
  (select relationship_id from rl where concept_class_1='Ingredient' and concept_class_2='Brand Name') as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ri_bn
join ( -- resolve ri_combo into i_codes and create rx notation
  select ri_combo, concept_code, vocabulary_id
  from ri_bn, 
  ( -- resolve ri_combo ingredients
    select i_code, concept_code, vocabulary_id from ing_stage join concept on concept.concept_id=i_id
  union
    select ri_code, ri_code, 'RxNorm Extension' from extension_i
  ), 
  table(cast(multiset(select level from dual connect by level <= length (regexp_replace(ri_combo, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
  where trim(regexp_substr(ri_combo, '[^\-]+', 1, levels.column_value))=i_code
) ing using(ri_combo)
join ( -- resolve bn_id - either into existing concept or extension_bn
  select concept_code, vocabulary_id, concept_id as bn_id from concept where vocabulary_id in ('RxNorm', 'RxNorm Extension') and concept_class_id='Brand Name'
union
  select bn_code, 'RxNorm Extension', bn_id from extension_bn -- the negatives
) bn using(bn_id)
;
commit;

-- Write Packs
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select distinct -- because records duplicate due to components
  null as concept_id, 
  concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  concept_class_id,
  'S' as standard_concept, -- all non-existing packs are Standard
  cp.pack_concept_code as concept_code,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason -- if they are 'U' they get mapped using Maps to to RxNorm/E anyway
from complete_pack cp join pack_name pn on pn.pack_concept_code=cp.pack_concept_code
left join pack_q_to_r pqr on cp.pack_concept_code=pqr.pack_concept_code -- exclude those that can be fully mapped
where pqr.pack_concept_code is null
;
commit;

-- Write links between Packs and their containing Drugs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct -- because drugs can be in a pack in several components
  cp.pack_concept_code as concept_code_1,
  'RxNorm Extension' as vocabulary_id_1,
  cp.drug_concept_code as concept_code_2,
  cp.drug_vocab as vocabulary_id_2,
  'Contains' as relationship_id, -- the relationship_id is not taken from rl, but expicitly defined
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from complete_pack cp 
left join pack_q_to_r pqr on cp.pack_concept_code=pqr.pack_concept_code -- exclude those that can be fully mapped
where pqr.pack_concept_code is null
;
commit;

-- Write Brand Names for Packs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  cp.bn_code as concept_code_1,
  nvl(cp.brand_vocab, 'RxNorm Extension') as vocabulary_id_1,
  cp.pack_concept_code as concept_code_2,
  'RxNorm Extension' as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from complete_pack cp join rl on rl.concept_class_1='Brand Name' and rl.concept_class_2=cp.concept_class_id
left join pack_q_to_r pqr on cp.pack_concept_code=pqr.pack_concept_code -- exclude those that can be fully mapped
where pqr.pack_concept_code is null
and bn_code!=' '
;
commit;

-- Write Suppliers for Packs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  cp.supplier_code as concept_code_1,
  nvl(cp.supplier_vocab, 'RxNorm Extension') as vocabulary_id_1,
  cp.pack_concept_code as concept_code_2,
  'RxNorm Extension' as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from complete_pack cp join rl on rl.concept_class_1='Supplier' and rl.concept_class_2=cp.concept_class_id
left join pack_q_to_r pqr on cp.pack_concept_code=pqr.pack_concept_code -- exclude those that can be fully mapped
where pqr.pack_concept_code is null
and supplier_code!=' '
;
commit;

/************************
* 14. Write source vocab *
************************/

-- Write source drugs as non-standard
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select distinct
  null as concept_id, 
  concept_name,
  domain_id,
  vocabulary_id,
  nvl(source_concept_class_id, concept_class_id) as concept_class_id,
  null as standard_concept, -- Source Concept, no matter whether active or not
  concept_code,
  nvl(valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
  nvl(valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  case invalid_reason when 'U' then 'D' else invalid_reason end as invalid_reason -- if they are 'U' they get mapped using Maps to to RxNorm/E anyway
from drug_concept_stage
where concept_class_id in ('Ingredient', 'Drug Product', 'Supplier', 'Dose Form', 'Brand Name') -- but no Unit
  and nvl(domain_id, 'Drug')='Drug'
;
commit;

-- Write source devices as standard (unless deprecated)
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select distinct
  null as concept_id, 
  concept_name,
  domain_id,
  vocabulary_id,
  nvl(source_concept_class_id, concept_class_id) as concept_class_id,
  case when invalid_reason is null then null else 'S' end as standard_concept, -- Devices are not mapped
  concept_code,
  nvl(valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
  nvl(valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  invalid_reason -- if they are 'U' they get mapped using Maps to to RxNorm/E anyway
from drug_concept_stage
where domain_id='Device'
;
commit;

-- Write maps for drugs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason);
select 
dcs.concept_name, nvl(c.concept_name, cs.concept_name), to_id,
  from_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(c.concept_code, cs.concept_code) as concept_code_2,
  nvl(c.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from maps_to left join concept_stage cs on to_id=cs.concept_id left join concept c on to_id=c.concept_id
join drug_concept_stage dcs on from_code=dcs.concept_code
where cs.concept_code is not null
;
commit;

-- Write maps for upgraded drugs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct -- xxxxxxxxxxxxxxxxxxxxx
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join existing_to_complete etc on etc.e_code=u.concept_code
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
where dcs.concept_code not in (select concept_code_1 from concept_relationship_stage where relationship_id='Maps to')
;
commit;

-- Write maps for ill-formed drugs (attribute combination not in RxNorm/RxNorm Extenion) in the order Ingredient, Drug_strength, Dose Form, Brand Name, Quantity, Box Size, Supplier. 
-- Drop q_mfurer
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_df on q_df.concept_code=i.concept_code 
  join q_quant on q_quant.concept_code=i.concept_code
  join q_bn on q_bn.concept_code=i.concept_code
  join q_bs on q_bs.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=df.df_code and c.denominator_value=quant.denominator_value and c.bn_code=bn.bn_code and c.box_size=bs.box_size and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- Drop box size
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_df on q_df.concept_code=i.concept_code 
  join q_quant on q_quant.concept_code=i.concept_code
  join q_bn on q_bn.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=df.df_code and c.denominator_value=quant.denominator_value and c.bn_code=bn.bn_code and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop Quantity, leaving Branded Drug
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_df on q_df.concept_code=i.concept_code 
  join q_bn on q_bn.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=df.df_code and c.denominator_value=0 and c.bn_code=bn.bn_code and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop brand name, leaving Clinical Drug 
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_df on q_df.concept_code=i.concept_code 
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=df.df_code and c.denominator_value=0 and c.bn_code=' ' and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop dose form, but keep brand name, leaving Branded Drug Comp
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_bn on q_bn.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=' ' and c.denominator_value=0 and c.bn_code=bn.bn_code and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop dose form and brand name, leaving Clinical Drug Comp
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_ing i -- single ingredient, not combo
  join q_ds d on i.concept_code=d.concept_code -- single q_ds entry
  join complete_q c 
    on c.i_combo=i.i_code and c.d_combo=d.ds_code and c.df_code=' ' and c.denominator_value=0 and c.bn_code=' ' and c.box_size=0 and c.mf_code=' '
  join drug_concept_stage dcs on dcs.concept_code=i.concept_code
  join extension_name en on en.concept_code=c.concept_code
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop drug_strength, leaving Branded Drug Form
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_df on q_df.concept_code=i.concept_code 
  join q_bn on q_bn.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=' ' and c.df_code=df.df_code and c.denominator_value=0 and c.bn_code=bn.bn_code and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop brand name, leaving Clinical Drug Form
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_df on q_df.concept_code=i.concept_code 
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=' ' and c.df_code=df.df_code and c.denominator_value=0 and c.bn_code=' ' and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- Map the remaining hanging products to Ingredients
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  i.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_ing.r_code as concept_code_2,
  nvl(x_ing.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from q_ing i
join x_ing on x_ing.q_code=i.i_code 
where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
;
commit;

-- Write maps for Ingredients
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  x_ing.q_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_ing.r_code as concept_code_2,
  nvl(x_ing.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from x_ing
where x_ing.q_code not in (select concept_code_1 from internal_relationship_stage) -- expecting that an ingredient will only be in concept_code_1 if it is upgraded
;
commit;

-- Write maps for deprecated Ingredients
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct -- xxxxxxxxxxxxxxxxxx doesn't have to be 
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_ing.r_code as concept_code_2,
  nvl(x_ing.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join x_ing on x_ing.q_code=u.concept_code
;
commit;

-- Write maps for Dose Forms
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  x_df.q_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_df.r_code as concept_code_2,
  nvl(x_df.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from x_df
where x_df.q_code not in (select concept_code_1 from internal_relationship_stage) -- expecting that an ingredient will only be in concept_code_1 if it is upgraded
;
commit;

-- Write maps for deprecated Dose Forms
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_df.r_code as concept_code_2,
  nvl(x_df.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
-- usual validity
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join x_df on x_df.q_code=u.concept_code
;
commit;

-- Write maps for Brand Names
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  x_bn.q_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_bn.r_code as concept_code_2,
  nvl(x_bn.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from x_bn
where x_bn.q_code not in (select concept_code_1 from internal_relationship_stage) -- expecting that an ingredient will only be in concept_code_1 if it is upgraded
;
commit;

-- Write maps for deprecated Brand Names
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_bn.r_code as concept_code_2,
  nvl(x_bn.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
-- usual validity
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join x_bn on x_bn.q_code=u.concept_code
;
commit;

-- Write maps for Suppliers
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  x_mf.q_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_mf.r_code as concept_code_2,
  nvl(x_mf.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from x_mf
where x_mf.q_code not in (select concept_code_1 from internal_relationship_stage) -- expecting that an ingredient will only be in concept_code_1 if it is upgraded
;
commit;

-- Write maps for deprecated Suppliers
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_mf.r_code as concept_code_2,
  nvl(x_mf.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
-- usual validity
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join x_mf on x_mf.q_code=u.concept_code
;
commit;

-- Write relationship to drug classes like ATC
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct 
  nvl(r_code, etc.c_code) as concept_code_1,
  nvl(r_vocab, 'RxNorm Extension') as vocabulary_id_1,
  dc.concept_code as concept_code_2,
  dc.vocabulary_id as vocabulary_id_2,
  'Drug has drug class' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from existing_to_complete etc
join r_to_c r on r.concept_code_1=etc.e_code 
join concept dc on dc.concept_id=r.concept_id_2
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) on q_dcode=etc.c_code
where dc.vocabulary_id in (select distinct vocabulary_id from concept where domain_id='Drug' and standard_concept='C')
;
commit;

-- Write mappings for Packs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct -- because each pack has many drugs
  source_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(concept_code, pack_concept_code) as concept_code_2,
  nvl(vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from pack_seq
left join (
  select pack_concept_code, concept_code, vocabulary_id from pack_q_to_r join concept on concept_id=coalesce(marketed, supplied, branded, clinical, neither)
) using (pack_concept_code)
;
commit;

-- Build drug_strength_stage
insert /*+ APPEND */ into drug_strength_stage
select 
  drug_concept_code,
  'RxNorm Extension' as vocabulary_id_1,
  ingredient_concept_code,
  case ingredient_vocab when ' ' then 'RxNorm Extension' else ingredient_vocab end as vocabulary_id_2,
  amount_value, amount_unit_concept_id, numerator_value, numerator_unit_concept_id, denominator_value, denominator_unit_concept_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select drug_concept_code, ingredient_concept_code, ingredient_vocab, 
  sum(amount_value) as amount_value, amount_unit_concept_id, 
  sum(numerator_value) as numerator_value, numerator_unit_concept_id, 
  denominator_value, denominator_unit_concept_id
  from extension_uds
  join concept_stage cs on cs.concept_code=drug_concept_code
  group by drug_concept_code, ingredient_concept_code, ingredient_vocab, amount_unit_concept_id, numerator_unit_concept_id, denominator_value, denominator_unit_concept_id
)
;
commit;

-- Build pack_content
drop table pack_content_stage;
create table pack_content_stage nologging as
select distinct 
  cp.pack_concept_code,
  'RxNorm Extension' as pack_vocabulary_id,
  cp.drug_concept_code,
  cp.drug_vocab as drug_vocabulary_id,
  cp.amount, cp.box_size
from complete_pack cp
left join pack_q_to_r pqr on pqr.pack_concept_code=cp.pack_concept_code
where pqr.pack_concept_code is null -- only those that have no translation.
;
commit;

/*************
* 9. Tidy up *
*************/

-- Replace concept_codes XXX123 with OMOP123
-- Create replacement map
drop table xxx_replace purge;
create table xxx_replace (
  xxx_code varchar2(50),
  omop_code varchar2(50)
);

-- generate OMOP codes for new concepts
insert /*+ APPEND */ into xxx_replace
select concept_code as xxx_code, 'OMOP'||omop_seq.nextval as omop_code
from concept_stage 
where concept_code like 'XXX%' 
;
commit;

-- fast way to update codes require temporary tables. 
-- replace concept_stage
create table cs_rowid_update nologging as
select cs.rowid as irowid, xr.omop_code as concept_code from xxx_replace xr JOIN concept_stage cs ON cs.concept_code=xr.xxx_code;

merge into concept_stage cs
using (select * from cs_rowid_update) d on (d.irowid=cs.rowid)
when matched then update
  set cs.concept_code=d.concept_code;

drop table cs_rowid_update purge;

-- replace concept_relationship_stage
create table crs_rowid_update nologging as
select distinct crs.rowid as irowid, nvl(xr1.omop_code, crs.concept_code_1) as concept_code_1, nvl(xr2.omop_code, crs.concept_code_2) as concept_code_2 from concept_relationship_stage crs
left join xxx_replace xr1 ON xr1.xxx_code=crs.concept_code_1 
left join xxx_replace xr2 ON xr2.xxx_code=crs.concept_code_2
where xr1.omop_code is not null or xr2.omop_code is not null;

merge into concept_relationship_stage crs
using (select * from crs_rowid_update) d on (d.irowid=crs.rowid)
when matched then update
  set crs.concept_code_1=d.concept_code_1, crs.concept_code_2=d.concept_code_2;

drop table crs_rowid_update purge;

-- replace drugs in drug_strength
create table dss_rowid_update nologging as
select dss.rowid as irowid, xr.omop_code as drug_concept_code from xxx_replace xr JOIN drug_strength_stage dss ON dss.drug_concept_code=xr.xxx_code;

merge into drug_strength_stage dss
using (select * from dss_rowid_update) d on (d.irowid=dss.rowid)
when matched then update
  set dss.drug_concept_code=d.drug_concept_code;

drop table dss_rowid_update purge;

-- replace ingredients in drug_strength
create table dss_rowid_update nologging as
select dss.rowid as irowid, xr.omop_code as ingredient_concept_code from xxx_replace xr JOIN drug_strength_stage dss ON dss.ingredient_concept_code=xr.xxx_code;

merge into drug_strength_stage dss
using (select * from dss_rowid_update) d on (d.irowid=dss.rowid)
when matched then update
  set dss.ingredient_concept_code=d.ingredient_concept_code;

drop table dss_rowid_update purge;

-- replace packs in pack_content
create table pcs_rowid_update nologging as
select pcs.rowid as irowid, xr.omop_code as pack_concept_code from xxx_replace xr join pack_content_stage pcs on pcs.pack_concept_code=xr.xxx_code;

merge into pack_content_stage pcs
using (select * from pcs_rowid_update) d on (d.irowid=pcs.rowid)
when matched then update
  set pcs.pack_concept_code=d.pack_concept_code;

drop table pcs_rowid_update purge;

-- replace drugs in pack_content
create table pcs_rowid_update nologging as
select pcs.rowid as irowid, xr.omop_code as drug_concept_code from xxx_replace xr join pack_content_stage pcs on pcs.drug_concept_code=xr.xxx_code;

merge into pack_content_stage pcs
using (select * from pcs_rowid_update) d on (d.irowid=pcs.rowid)
when matched then update
  set pcs.drug_concept_code=d.drug_concept_code;

drop table pcs_rowid_update purge;

commit;

--get duplicates for some reason 
delete from concept_relationship_stage a where exists (select 1 from  (
  select concept_code_1,concept_code_2,relationship_id, max (rowid) as rid from concept_relationship_stage group by concept_code_1,concept_code_2,relationship_id having count ( 1) >1 ) x 
  where  a.concept_code_1= x.concept_code_1 and a.concept_code_2= x.concept_code_2 and a.relationship_id =x.relationship_id and x.rid = a.rowid)
;  
--6 Working with replacement mappings;
BEGIN
   DEVV5.VOCABULARY_PACK.CheckReplacementMappings;
END;
/
COMMIT;

--7 Deprecate 'Maps to' mappings to deprecated and upgraded concepts
BEGIN
   DEVV5.VOCABULARY_PACK.DeprecateWrongMAPSTO;
END;
/
COMMIT;

--8 Add mapping from deprecated to fresh concepts
BEGIN
   DEVV5.VOCABULARY_PACK.AddFreshMAPSTO;
END;
/
COMMIT;

--9 Delete ambiguous 'Maps to' mappings
BEGIN
   DEVV5.VOCABULARY_PACK.DeleteAmbiguousMAPSTO;
END;
/
COMMIT;
