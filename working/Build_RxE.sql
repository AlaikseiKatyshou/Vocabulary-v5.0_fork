/**************************************************************************
* Copyright 2016 Observational Health Data Sciences and Informatics (OHDSI)
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
* Authors: Christian Reich
* Date: 2016-2017
**************************************************************************/

-- To do: Ingredient to Brand Name (has brand name), product to Brand Name (has tradename), possible excipient, mEq to mmol, other funny units
-- Add filter for standard_concept=null and pass through 'Concept_replaced_by' or 'Maps to' links (for Ingredients, Forms, Brand Names)
-- Put all "drops" to the end

/******************************************************************************
* This script creates a new drug vocabulary in the OMOP Standard Vocabularies *
* The new drug vocabulary must be provided in the format described in         *
* http://www.ohdsi.org/web/wiki/doku.php?id=documentation:international_drugs *
* The processing is also described there. The following tables are required:  *
* drug_concept_stage, internal_relationship_stage, relationship_to_concept,   *
* q_ds_stage. Records that have no concept_code in the source should            *
* receive autogenerated ones in the format 'OMOP' plus a running number.      *
* The tables concept, concept_relationship, concept_ancestor and              *
* drug_strength need to be locally availabe.                                  *
*******************************************************************************/

/** IMPORTANT **/
/* Add the latest_udpate and version information to the VOCABULARY table **/

drop index idx_dcs_concept_code;
create index idx_dcs_concept_code on drug_concept_stage (concept_code)
;
commit;

-- Add existing mappings from previous runs. 
drop view r_to_c;
create view r_to_c as
  select * from relationship_to_concept where concept_code_1 is not null
union
  select c1.concept_code as concept_code_1, c1.vocabulary_id as vocabulary_id_1, r.concept_id_2, 1, null
  from concept c1
  join concept_relationship r on r.concept_id_1=c1.concept_id and r.relationship_id in ('Maps to', 'Source - RxNorm eq') and r.invalid_reason is null
  join concept c2 on c2.concept_id=r.concept_id_2 and c2.standard_concept='S'
  where c1.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)
  and c2.vocabulary_id in ('RxNorm', 'RxNorm Extension') 
  and c2.concept_class_id in ('Ingredient', 'Dose Form', 'Brand Name', 'Supplier')
  and c1.concept_code not in (select concept_code_1 from relationship_to_concept where concept_code_1 is not null)
union -- XXXX remove as soon as Anya has added
  select 'mL', 'Rxfix', 8576, 2, 1000 from dual
union
  select 'mg', 'Rxfix', 8587, 2, 0.001 from dual
;

/*****************************************************************************************************************************************************
* 1. Prepare drug components for new vocabularies: Create unique list and for each drug enumerate. This allows to create a single row for each drug. *
*****************************************************************************************************************************************************/

-- Create temporary for uniqe strength recordsdrop sequence q_ds_seq;
drop sequence ds_seq;
create sequence ds_seq increment by 1 start with 1 nocycle cache 20 noorder;
-- Create sequence for temporary XXX concept codes
drop sequence xxx_seq;
create sequence xxx_seq increment by 1 start with 1 nocycle cache 20 noorder;


/*****************************
* 2. Collect atributes for q *
*****************************/

-- Create table with all drug concept codes linked to the codes of the ingredients (rather than full dose components)
drop table q_ing purge;
create table q_ing nologging as
  select c.concept_code as concept_code, i.concept_code as i_code
  from drug_concept_stage c
  join internal_relationship_stage r on r.concept_code_1=c.concept_code
  join drug_concept_stage i on i.concept_code=r.concept_code_2 and i.concept_class_id='Ingredient'
  where c.concept_class_id='Drug Product' and c.domain_id='Drug' -- Drug Products
union
  select drug_concept_code as concept_code, ingredient_concept_code as i_code from ds_stage -- just in case, won't hurt if the internal_relationship table forgot something
;

-- Create distinct version of drug_strength in concentration notation (no quant). 
-- Replace nulls with 0 and ' '
drop table q_uds purge;
create table q_uds (
  ds_code integer not null,
  ingredient_concept_code varchar2(50) not null,
  amount_value number,
  amount_unit varchar2(50),
  numerator_value number,
  numerator_unit varchar2(50),
  denominator_unit varchar2(50)
) nologging;

-- Check validity of ds_stage and force error if conventions are violated. Won't be necessary if strong QA
insert into q_uds (ds_code) 
select null from ds_stage-- force error as ds_code is not nullable
where coalesce(amount_value, numerator_value, 0)=0 -- needs to have at least one value, zeros don't count
  or coalesce(amount_unit, numerator_unit) is null -- needs to have at least one unit
  or (amount_value is not null and amount_unit is null) -- if there is an amount record, there must be a unit
  or (nvl(numerator_value, 0)!=0 and coalesce(numerator_unit, denominator_unit) is null) -- if there is a concentration record there must be a unit in both numerator and denominator
  or amount_unit='%' -- % should be in the numerator_unit
;

-- Write from ds_stage, converting % and numerator/denominator to concentration
insert into q_uds
select ds_seq.nextval as ds_code, q_ds.* from (
  select distinct ingredient_concept_code, 
    nvl(amount_value, 0) as amount_value, nvl(amount_unit, ' ') as amount_unit, 
    case 
      when lower(numerator_unit) in ('%', 'percent') then numerator_value -- % is already a fixed concentration, no need to adjust to volume
      when upper(numerator_unit) in ('C', 'X', 'D', '[HP_X]', '[HP_C]') then numerator_value -- same for homeopathic drugs
      when nvl(numerator_value, 0)=0 then 0 
      else numerator_value/nvl(denominator_value, 1) -- turn into concentration as basis for comparison.
    end as numerator_value, 
    nvl(numerator_unit, ' ') as numerator_unit, 
    nvl(denominator_unit, ' ') as denominator_unit
  from ds_stage
) q_ds
;

-- Create table with all drug concept codes linked to the above unique components 
drop table q_ds cascade constraints purge;
create table q_ds nologging as
select dss.drug_concept_code as concept_code, dss.ingredient_concept_code as i_code, uds.ds_code
from ds_stage dss
join q_uds uds on uds.ingredient_concept_code=dss.ingredient_concept_code
  and uds.amount_value=nvl(dss.amount_value, 0) and uds.amount_unit=nvl(dss.amount_unit, ' ')
  and uds.numerator_value=
    case 
      when lower(dss.numerator_unit) in ('%', 'percent') then nvl(dss.numerator_value, 0) 
      when upper(dss.numerator_unit) in ('C', 'X', 'D', '[HP_X]', '[HP_C]') then nvl(dss.numerator_value, 0) 
      when nvl(dss.numerator_value, 0)=0 then 0 
      else nvl(dss.numerator_value, 0)/nvl(dss.denominator_value, 1)
    end 
  and uds.numerator_unit=nvl(dss.numerator_unit, ' ')
  and uds.denominator_unit=nvl(dss.denominator_unit, ' ')
;
create index idx_q_ds on q_ds (ds_code);

-- Create table with the combination of components for each drug concept delimited by '-'
-- Contains both ingredient combos and ds combos. For Drug Comps d_combo=' '
drop table q_combo purge;
create table q_combo as
select distinct concept_code, 
  listagg(i_code, '-') within group (order by i_code) as i_combo,
  listagg(ds_code, '-') within group (order by ds_code) as d_combo
from q_ds
group by concept_code
;
commit;

-- Add Drug Forms, which have no entry in ds_stage. Shouldn't exist, unless there are singleton Drug Forms with no descendants.
insert into q_combo
select * from (
  select distinct concept_code, 
    listagg(i_code, '-') within group (order by i_code) as i_combo,
    ' ' as d_combo
  from (
    select d.concept_code, i.concept_code as i_code
    from drug_concept_stage d
    join internal_relationship_stage r on r.concept_code_1=d.concept_code
    join drug_concept_stage i on i.concept_code=r.concept_code_2 and i.concept_class_id='Ingredient'
    where d.concept_code in (
      select concept_code from drug_concept_stage where domain_id='Drug' and concept_class_id='Drug Product'
      minus
      select drug_concept_code from ds_stage
    )
  )
  group by concept_code
)
where not exists (
  select 1 from q_combo q where q.i_combo=i_combo
)
;

-- Create table with Quantity Factor information for each drug (if exists), not rounded
drop table q_quant purge;
create table q_quant nologging as
select distinct drug_concept_code as concept_code, denominator_value as value, denominator_unit as unit
from ds_stage
where denominator_value is not null and denominator_value!=0 and numerator_value is not null and numerator_value!=0
;

-- Create table with Dose Form information for each drug (if exists)
drop table q_df purge;
create table q_df nologging as
select distinct ir.concept_code_1 as concept_code, f.concept_code as df_code -- distinct only because source may contain duplicated maps
from internal_relationship_stage ir
join drug_concept_stage f on f.concept_code=ir.concept_code_2 and f.concept_class_id='Dose Form' and f.domain_id='Drug' -- Dose Form of a drug
;

-- Create table with Brand Name information for each drug (if exists)
drop table q_bn purge;
create table q_bn nologging as
select distinct ir.concept_code_1 as concept_code, b.concept_code as bn_code -- distinct only because source contains duplicated maps
from internal_relationship_stage ir
join drug_concept_stage b on b.concept_code=ir.concept_code_2 and b.concept_class_id='Brand Name' and b.domain_id='Drug' -- Brand Name of a drug
;

-- Create table with Suppliers (manufacturers)
drop table q_mf purge;
create table q_mf nologging as
select irs.concept_code_1 as concept_code, irs.concept_code_2 as mf_code from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_2=dcs.concept_code
where dcs.concept_class_id='Supplier'
;

-- Create table with Box Size information 
drop table q_bs purge;
create table q_bs nologging as
select distinct drug_concept_code as concept_code, box_size as bs
from ds_stage where box_size is not null
;

/******************************
* 3. Collect atributes for r  *
******************************/
-- Create xxx-type codes for the ingredients, so we can add them
drop table ing_stage purge;
create table ing_stage as
select 'XXX'||xxx_seq.nextval as i_code, i_id from (
  select concept_id as i_id from concept where vocabulary_id in ('RxNorm', 'RxNorm Extension1') and concept_class_id='Ingredient' -- XXXX remove 1
);

-- Create table with all drug concept codes linked to the codes of the ingredients (rather than full dose components)
drop table r_ing purge;
create table r_ing nologging as
select * from (
  select de.concept_id as concept_id, an.concept_id as i_id
  from concept_ancestor a 
  join concept an on a.ancestor_concept_id=an.concept_id and an.vocabulary_id in ('RxNorm', 'RxNorm Extension1') and an.concept_class_id='Ingredient' -- XXXX remove 1
  join concept de on de.concept_id=a.descendant_concept_id and de.vocabulary_id in ('RxNorm', 'RxNorm Extension1') and de.concept_class_id not in ('Ingredient', 'Clinical Dose Group', 'Branded Dose Group') -- XXXX remove 1
union
  select drug_concept_id as concept_id, ingredient_concept_id as i_id from drug_strength -- just in case, won't hurt if the internal_relationship table forgot something
join concept r on r.concept_id=drug_concept_id and r.vocabulary_id in ('RxNorm', 'RxNorm Extension1') -- XXXX remove!!!!!!!!
  where drug_concept_id!=ingredient_concept_id -- in future, ingredients will also have records, where drug and ingredient ids are the same
)
join ing_stage using(i_id)
;

-- Create table with unique dosages 
drop table r_uds purge;
create table r_uds nologging as
select ds_seq.nextval as ds_code, ds.* from ( -- reuse the same sequence for q_ds and r_ds
  select distinct
    i_code, -- use internal codes instead of concept id, so new ones can be added later.
    ingredient_concept_id, -- still keep it for faster creation of r_ds, but don't use it otherwise
    nvl(amount_value, 0) as amount_value, nvl(amount_unit_concept_id, 0) as amount_unit_concept_id,
    case -- turn into concentration mode
      when numerator_unit_concept_id in (8554, 9325, 9324) then nvl(numerator_value, 0) -- don't for % and homeopathic units C, X
      else nvl(numerator_value, 0)/nvl(denominator_value, 1)
    end as numerator_value, 
    nvl(numerator_unit_concept_id, 0) as numerator_unit_concept_id,
    nvl(denominator_unit_concept_id, 0) as denominator_unit_concept_id
  from drug_strength join ing_stage on ingredient_concept_id=i_id
join concept r on r.concept_id=drug_concept_id and r.vocabulary_id in ('RxNorm', 'RxNorm Extension1') -- XXXX remove!!!!!!!!
) ds
;

-- Create table with all drug concept codes linked to the above unique components 
drop table r_ds purge;
create table r_ds nologging as 
select ds.drug_concept_id as concept_id, uds.i_code, uds.ds_code, uds.denominator_unit_concept_id as quant_unit_id
from (
  select drug_concept_id, ingredient_concept_id, i_code, nvl(amount_value, 0) as amount_value, nvl(amount_unit_concept_id, 0) as amount_unit_concept_id, 
    nvl(numerator_value, 0) as numerator_value, nvl(numerator_unit_concept_id, 0) as numerator_unit_concept_id, 
    nvl(denominator_value, 1) as denominator_value, nvl(denominator_unit_concept_id, 0) as denominator_unit_concept_id
  from drug_strength join ing_stage on ingredient_concept_id=i_id
join concept r on r.concept_id=drug_concept_id and r.vocabulary_id in ('RxNorm', 'RxNorm Extension1') -- XXXX remove!!!!!!!!
) ds 
join r_uds uds 
  on uds.ingredient_concept_id=ds.ingredient_concept_id
  and uds.amount_value=ds.amount_value and uds.amount_unit_concept_id=ds.amount_unit_concept_id
  and uds.numerator_value=ds.numerator_value/ds.denominator_value
  and uds.numerator_unit_concept_id=ds.numerator_unit_concept_id
  and uds.denominator_unit_concept_id=ds.denominator_unit_concept_id
;
create index idx_r_ds on r_ds (ds_code);

-- Create table with the combination of ds components for each drug concept delimited by '-'
-- Add corresponding ingredient combos
drop table r_combo purge;
create table r_combo as
select distinct concept_id, 
  listagg(i_code, '-') within group (order by i_code) as i_combo,
  listagg(ds_code, '-') within group (order by ds_code) as d_combo,
  max(quant_unit_id) as quant_unit_id
from r_ds
group by concept_id
;
commit;

-- Add Drug Forms, which have no entry in ds_stage. Shouldn't exist, unless there are drug forms with no descendants
insert into r_combo 
select * from (
  select distinct 
    concept_id, 
    listagg(i_code, '-') within group (order by i_code) as i_combo,
    ' ' as d_combo,
    0 as quant_unit_id
  from r_ing
  group by concept_id
)
where not exists (
  select 1 from r_combo r where r.i_combo=i_combo
)
;

-- Create table with Quantity Factor information for each drug (if exists), not rounded
drop table r_quant purge;
create table r_quant nologging as
select distinct drug_concept_id as concept_id, denominator_value as value, denominator_unit_concept_id as unit_id
from drug_strength
join concept on concept_id=drug_concept_id and vocabulary_id in ('RxNorm', 'RxNorm Extension1') -- XXXX remove!!!!!!!!
where denominator_value is not null and numerator_value is not null and drug_concept_id!=ingredient_concept_id
;

-- Create table with Dose Form information for each drug (if exists)
drop table r_df purge;
create table r_df nologging as
select r.concept_id_1 as concept_id, r.concept_id_2 as df_id from concept_relationship r
join concept d on d.concept_id=r.concept_id_1 and d.vocabulary_id in ('RxNorm', 'RxNorm Extension1') and d.standard_concept='S' -- XXXX remove 1
join concept f on f.concept_id=r.concept_id_2 and f.concept_class_id ='Dose Form' and f.invalid_reason is null
where r.invalid_reason is null and r.relationship_id='RxNorm has dose form'
;

-- Create table with Brand Name information for each drug (if exists)
drop table r_bn purge;
create table r_bn nologging as
select r.concept_id_1 as concept_id, r.concept_id_2 as bn_id from concept_relationship r
join concept d on d.concept_id=r.concept_id_1 and d.vocabulary_id in ('RxNorm', 'RxNorm Extension1') and d.standard_concept='S' -- XXXX remove 1
join concept f on f.concept_id=r.concept_id_2 and f.concept_class_id ='Brand Name' and f.invalid_reason is null
where r.invalid_reason is null and r.relationship_id='Has brand name'
;

-- Create table with Suppliers (manufacturers)
drop table r_mf purge;
create table r_mf nologging as
select r.concept_id_1 as concept_id, r.concept_id_2 as mf_id from concept_relationship r
join concept d on d.concept_id=r.concept_id_1 and d.vocabulary_id in ('RxNorm', 'RxNorm Extension1') and d.standard_concept='S' -- XXXX remove 1
join concept f on f.concept_id=r.concept_id_2 and f.concept_class_id ='Supplier' and f.invalid_reason is null
where r.invalid_reason is null and r.relationship_id='Has supplier';

-- Create table with Box Size information 
drop table r_bs purge;
create table r_bs nologging as
select distinct drug_concept_id as concept_id, box_size as bs
from drug_strength 
join concept d on d.concept_id=drug_concept_id and d.vocabulary_id in ('RxNorm', 'RxNorm Extension1') -- XXXX remove entirely
where box_size is not null
;

/*************************************************************************
* 3. Create translation tables between q and r attributes with corridors *
**************************************************************************/

-- Create comparison between q_uds and r_uds for everything in the 90% corridor
drop table qr_uds purge;
create table qr_uds as
select q_ds, r_ds, u_prec, i_prec,
  case when div>1 then 1/div else div end as div
from (
-- Standard case where all units are identical after conversion
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec,
    case
      when q.amount_value!=0 and r.amount_value!=0 then q.amount_value/r.amount_value
      when q.numerator_value!=0 and r.numerator_value!=0 then q.numerator_value/r.numerator_value -- the standard case
    else 0 end as div
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      amount_value*nvl(q_ds_a.conversion_factor, 1) as amount_value, 
      nvl(q_ds_a.concept_id_2, 0) as amount_unit_concept_id, 
      numerator_value*nvl(q_ds_n.conversion_factor, 1)/nvl(q_ds_d.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_d.concept_id_2, 0) as denominator_unit_concept_id,
      coalesce(q_ds_a.precedence, (q_ds_n.precedence+q_ds_d.precedence)/2, 100) as u_prec -- numerator unit precedence, or average of concentration precedences, or 100 (non-desirable conversion, missing conversion)
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_a on q_ds_a.concept_code_1=amount_unit -- amount units
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator units
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator units
  ) q
  join r_uds r using(ingredient_concept_id, amount_unit_concept_id, numerator_unit_concept_id, denominator_unit_concept_id) -- join q and r on the ingredient and all the units
union
-- % vs mg/mL
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec,
    q.numerator_value/r.numerator_value*10 as div
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      numerator_value*nvl(q_ds_n.conversion_factor, 1)/nvl(q_ds_d.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_n.precedence, 100) as u_prec -- numerator unit precedence, or 100 (non-desirable conversion, missing conversion)
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator unit conversion
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator unit conversion
  ) q
  join r_uds r on q.ingredient_concept_id=r.ingredient_concept_id and r.numerator_unit_concept_id=8576 and r.denominator_unit_concept_id=8587 -- mg/mL
  where q.numerator_unit_concept_id=8554 -- %
union
-- mg/mL vs %
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec,
    q.numerator_value/r.numerator_value/10 as div
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      numerator_value*nvl(q_ds_n.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_d.concept_id_2, 0) as denominator_unit_concept_id,
      nvl((q_ds_n.precedence+q_ds_n.precedence)/2, 100) as u_prec -- numerator unit precedence, or 100 (non-desirable conversion, missing conversion)
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator unit conversion
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator unit conversion
    where q_uds.amount_unit=' ' -- redundant with clause below that numerator/denominator=mg/mL, but faster to limit here
  ) q
  join r_uds r on q.ingredient_concept_id=r.ingredient_concept_id and r.numerator_unit_concept_id=8554 -- %
  where q.numerator_unit_concept_id=8576 and q.denominator_unit_concept_id=8587  -- mg/mL
union
-- mg/mg etc. vs %
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec, 
    q.numerator_value/r.numerator_value*100 as div
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      numerator_value*nvl(q_ds_n.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_d.concept_id_2, 0) as denominator_unit_concept_id,
      nvl((q_ds_n.precedence+q_ds_n.precedence)/2, 100) as u_prec -- numerator unit precedence, or 100 (non-desirable conversion, missing conversion)
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator unit conversion
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator unit conversion
    where q_uds.amount_unit=' ' 
  ) q
  join r_uds r on q.ingredient_concept_id=r.ingredient_concept_id and r.numerator_unit_concept_id=8554 -- %
  where q.numerator_unit_concept_id=q.denominator_unit_concept_id -- mg/mg, mL/mL etc.
union
-- % vs mg/mg etc.
  select q.ds_code as q_ds, r.ds_code as r_ds, q.u_prec, q.i_prec,
    q.numerator_value/r.numerator_value/100 as div
  from (
-- q component with drug_strength in RxNorm speak (ids instead of codes)
    select 
      ds_code, 
      q_ds_i.concept_id_2 as ingredient_concept_id, nvl(q_ds_i.precedence, 1) as i_prec,
      numerator_value*nvl(q_ds_n.conversion_factor, 1) as numerator_value, 
      nvl(q_ds_n.concept_id_2, 0) as numerator_unit_concept_id,
      nvl(q_ds_d.concept_id_2, 0) as denominator_unit_concept_id,
      nvl((q_ds_n.precedence+q_ds_n.precedence)/2, 100) as u_prec -- numerator unit precedence, or 100 (non-desirable conversion, missing conversion)
    from q_uds
    join r_to_c q_ds_i on q_ds_i.concept_code_1=ingredient_concept_code -- ingredient matching
    left join r_to_c q_ds_n on q_ds_n.concept_code_1=numerator_unit -- numerator unit conversion
    left join r_to_c q_ds_d on q_ds_d.concept_code_1=denominator_unit -- denominator unit conversion
    where q_uds.amount_unit=' ' 
  ) q
  join r_uds r on q.ingredient_concept_id=r.ingredient_concept_id and r.numerator_unit_concept_id=r.denominator_unit_concept_id -- mg/mg, mL/mL etc.
  where q.numerator_unit_concept_id=8554 -- %
)
where div>0.9 and 1/div>0.9 -- find identicals only within a corridor of 90% deviation
;

-- Create conversion table between drug strength combos
drop table qr_d_combo purge;
create table qr_d_combo as
-- Create unique list of combo codes and ds components for both q and r
with q as (
  select distinct d_combo, i_combo, ds_code
  from q_combo
  join q_ds using(concept_code)
), r as (
  select distinct d_combo, i_combo, ds_code
  from r_combo
  join r_ds using(concept_id)
), 
-- Create all combinations of combos that share at least one ds, and calculate their size of the combos
q_to_r as (
  select qc.i_combo as qi_combo, qc.d_combo as qd_combo, q_ds, rc.i_combo as ri_combo, rc.d_combo as rd_combo, r_ds, u_prec, i_prec, div, qc.cnt
  from qr_uds 
-- Create q and the number of ds components
  join (
    select * from (select d_combo, count(8) as cnt from q group by d_combo) join q using(d_combo)
  ) qc on qc.ds_code=q_ds
-- Same for r
  join (
    select * from (select d_combo, count(8) as cnt from r group by d_combo) join r using(d_combo)
  ) rc on rc.ds_code=r_ds and qc.cnt=rc.cnt -- join q to r through qr_uds, and also the size of hte combos
)
-- Now filter those where the size of the q and r combos (already the same) is the same as the number of qr_uds matches between the combos
select qi_combo, qd_combo, ri_combo, rd_combo, cnt, avg(u_prec) as u_prec, avg(i_prec) as i_prec, avg(div) as div -- for successful matches, calculate aggregate u_prec, i_prec and div
from (select qi_combo, qd_combo, ri_combo, rd_combo, count(8) as cnt from q_to_r group by qi_combo, qd_combo, ri_combo, rd_combo) join q_to_r using(qi_combo, qd_combo, ri_combo, rd_combo, cnt)
group by qi_combo, qd_combo, ri_combo, rd_combo, cnt
;

-- Same for ingredient combinations only (used for Drug Forms)
drop table qr_i_combo purge;
create table qr_i_combo as
-- Add translations of ingredient combos only (where there are no matching ds)
with q as (
  select distinct i_combo, i_code
  from q_combo
  join q_ing using(concept_code) 
), r as (
  select distinct i_combo, i_code
  from r_combo
  join r_ing using(concept_id)
), 
-- Create all combinations of combos that share at least one ing, and calculate their size of the combos
q_to_r as (
  select qc.i_combo as q_combo, q_ing, rc.i_combo as r_combo, r_ing, i_prec, qc.cnt
  from ( -- create a combination of all possible ingredient to ingredient maps
    select distinct q_ing.i_code as q_ing, precedence as i_prec, r_ing.i_code as r_ing
    from q_ing join r_to_c on q_ing.i_code=concept_code_1 join r_ing on i_id=concept_id_2
  )
-- Create q and the number of ds components
  join (
    select * from (select i_combo, count(8) as cnt from q group by i_combo) join q using(i_combo)
  ) qc on qc.i_code=q_ing
-- Same for r
  join (
    select * from (select i_combo, count(8) as cnt from r group by i_combo) join r using(i_combo)
  ) rc on rc.i_code=r_ing and qc.cnt=rc.cnt -- join q to r through q_to_r_uds, and also the size of hte combos
)
-- Now filter those where the size of the q and r combos (already the same) is the same as the number of q_to_r_uds matches between the combos
select 
  q_combo as qi_combo, ' ' as qd_combo, 
  r_combo as ri_combo, ' ' as rd_combo, 
  cnt, 100 as u_prec, avg(i_prec) as i_prec, 1 as div -- for successful matches, calculate aggregate i_prec
from (select q_combo, r_combo, count(8) as cnt from q_to_r group by q_combo, r_combo) join q_to_r using(q_combo, r_combo, cnt)
group by q_combo, r_combo, cnt
;

-- Create translations between quant, value and unit have to work in tandem
drop table qr_quant purge;
create table qr_quant as
select * from (
  select q.value as q_value, q.unit as q_unit, r.value as r_value, r.unit_id as r_unit_id, precedence as prec, q.value*nvl(conversion_factor, 1)/r.value as q_div 
  from (
    select distinct value, unit from q_quant
  ) q
  join r_to_c on concept_code_1=q.unit
  join (
    select distinct value, unit_id from r_quant
  ) r on concept_id_2=r.unit_id 
)
where round(q_div*50)=50 -- making it a 2% corridor
;
select * from r_ing;

-- Translation between Ingredients
drop table qr_i purge;
create table qr_i as
select q.i_code as qi_code, r.i_code as ri_code, precedence as prec
from (
  select distinct i_code from q_ing
) q
join r_to_c on concept_code_1=q.i_code
join (
  select distinct i_id, i_code from r_ing
) r on concept_id_2=r.i_id 
;


-- Translation between Dose Forms
drop table qr_df purge;
create table qr_df as
select q.df_code, r.df_id, precedence as prec
from (
  select distinct df_code from q_df
) q
join r_to_c on concept_code_1=q.df_code
join (
  select distinct df_id from r_df
) r on concept_id_2=r.df_id 
;

-- Translation between Dose Forms
drop table qr_bn purge;
create table qr_bn as
select q.bn_code, r.bn_id, precedence as prec
from (
  select distinct bn_code from q_bn
) q
join r_to_c on concept_code_1=q.bn_code
join (
  select distinct bn_id from r_bn
) r on concept_id_2=r.bn_id 
;

-- Translation between Dose Forms
drop table qr_mf purge;
create table qr_mf as
select q.mf_code, r.mf_id, precedence as prec
from (
  select distinct mf_code from q_mf
) q
join r_to_c on concept_code_1=q.mf_code
join (
  select distinct mf_id from r_mf
) r on concept_id_2=r.mf_id 
;

-- No need for translating box sizes

/**************************************************************************
* 2. Create the list of all all existing q products in attribute notation * 
***************************************************************************/

-- Duplication rule 1: More than one definition per concept_code is illegal
-- Duplication rule 2: More than one concept_code per definition is allowed. 

-- Collect all input drugs and create master matrix, including assignment of concept_classes
drop table existing_q purge;
create table existing_q nologging as
-- Marketed Product
  select distinct 
    c.concept_code, nvl(q_quant.value,0) as quant_value, nvl(q_quant.unit, ' ') as quant_unit, c.i_combo, c.d_combo, nvl(q_df.df_code,' ') as df_code,
     nvl(q_bn.bn_code,' ') as bn_code, nvl(q_bs.bs,0) as bs, q_mf.mf_code as mf_code,
    'Marketed Product' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code 
  join q_mf q_mf on q_mf.concept_code=c.concept_code 
  left join q_quant on q_quant.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Quant Branded Box
  select distinct 
    c.concept_code, q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, q_bs.bs, ' ' as mf_code,
    'Quant Branded Box' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where c.d_combo!=' ' and q_mf.mf_code is null
union
-- Quant Clinical Box
  select distinct 
    c.concept_code, q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, q_bs.bs, ' ' as mf_code,
    'Quant Clinical Box' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where c.d_combo!=' ' and q_bn.concept_code is null and q_mf.mf_code is null
union
-- Branded Drug Box
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, q_bs.bs, ' ' as mf_code,
    'Branded Drug Box' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where q_quant.concept_code is null and c.d_combo!=' ' and q_mf.mf_code is null
union
-- Clinical Drug Box
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, q_bs.bs, ' ' as mf_code,
    'Clinical Drug Box' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where q_quant.concept_code is null and c.d_combo!=' ' and q_bn.concept_code is null and q_mf.mf_code is null
union
-- Quant Branded Drug
  select distinct 
    c.concept_code, q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Quant Branded Drug' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code 
  where c.d_combo!=' ' and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Quant Clinical Drug
  select distinct 
    c.concept_code, q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Quant Clinical Drug' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where c.d_combo!=' ' and q_bn.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Branded Drug
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo!=' ' and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Clinical Drug
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo!=' ' and q_bn.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Branded Drug Form
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug Form' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo=' ' and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Clinical Drug Form
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug Form' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo=' ' and q_bn.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null
union
-- Branded Drug Component
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, ' ' as df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug Comp' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  left join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo!=' ' and q_df.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null -- denominator_value is ignored
union
-- Clinical Drug Component 
  select distinct 
    c.concept_code, 0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, ' ' as df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug Comp' as concept_class_id
  from q_combo c
  left join q_quant on q_quant.concept_code=c.concept_code
  left join q_df on q_df.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code 
  left join q_mf q_mf on q_mf.concept_code=c.concept_code
  where q_quant.concept_code is null and c.d_combo!=' ' and q_df.concept_code is null and q_bn.concept_code is null and q_bs.concept_code is null and q_mf.mf_code is null 
;

/***************************************************************************************
* 3. Write all concept classes, whether existing in source or not from all possible combinations *
***************************************************************************************/

drop table complete_q purge;
create table complete_q nologging as
select 'XXX'||xxx_seq.nextval as concept_code, -- make sure xxx_seq is defined.
  c.*
from (
-- Marketed Product
  select distinct 
    nvl(q_quant.value, 0) as quant_value, nvl(q_quant.unit, ' ') as quant_unit, c.i_combo, c.d_combo, nvl(q_df.df_code, ' ') as df_code, 
      nvl(q_bn.bn_code, ' ') as bn_code, nvl(q_bs.bs, 0) as bs, q_mf.mf_code,
    'Marketed Product' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code 
  join q_mf q_mf on q_mf.concept_code=c.concept_code 
-- Marketed Product is the only one where these may or may not be defined, hence left joins
  left join q_quant on q_quant.concept_code=c.concept_code
  left join q_bn on q_bn.concept_code=c.concept_code
  left join q_bs on q_bs.concept_code=c.concept_code
  where c.d_combo!=' ' 
union  
-- Quant Branded Box
  select distinct 
    q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, q_bs.bs, ' ' as mf_code,
    'Quant Branded Box' as concept_class_id
  from q_combo c 
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  where c.d_combo!=' ' 
union
-- Quant Clinical Box
  select distinct 
    q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, q_bs.bs, ' ' as mf_code,
    'Quant Clinical Box' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  where c.d_combo!=' ' 
union
-- Branded Drug Box
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, q_bs.bs, ' ' as mf_code,
    'Branded Drug Box' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  where c.d_combo!=' ' 
union
-- Clinical Drug Box
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, q_bs.bs, ' ' as mf_code,
    'Clinical Drug Box' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code
  join q_bs on q_bs.concept_code=c.concept_code 
  where c.d_combo!=' ' 
union
-- Quant Branded Drug
  select distinct 
    q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Quant Branded Drug' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Quant Clinical Drug
  select distinct 
    q_quant.value as quant_value, q_quant.unit as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Quant Clinical Drug' as concept_class_id
  from q_combo c
  join q_quant on q_quant.concept_code=c.concept_code
  join q_df on q_df.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Branded Drug
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Clinical Drug
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug' as concept_class_id
  from q_combo c
  join q_df on q_df.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Branded Drug Form
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, ' ' as d_combo, q_df.df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug Form' as concept_class_id
  from q_combo c -- i_combo is not unique, but the union will remove the duplicates because concept_code is not maintained
  join q_df on q_df.concept_code=c.concept_code
  join q_bn on q_bn.concept_code=c.concept_code
  where c.d_combo=' ' 
union
-- Clinical Drug Form
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, ' ' as d_combo, q_df.df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug Form' as concept_class_id
  from q_combo c 
  join q_df on q_df.concept_code=c.concept_code
  where c.d_combo=' ' 
union
-- Branded Drug Component
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.i_combo, c.d_combo, ' ' as df_code, q_bn.bn_code, 0 as bs, ' ' as mf_code,
    'Branded Drug Comp' as concept_class_id
  from q_combo c
  join q_bn on q_bn.concept_code=c.concept_code
  where c.d_combo!=' ' 
union
-- Clinical Drug Component - they are unique per ingredients
  select distinct 
    0 as quant_value, ' ' as quant_unit, c.ingredient_concept_code as i_combo, cast(c.ds_code as varchar(20)) as d_combo, ' ' as df_code, ' ' as bn_code, 0 as bs, ' ' as mf_code,
    'Clinical Drug Comp' as concept_class_id
  from q_uds c
) c
;
create index idx_cq_concept_code on complete_q (concept_code);
create index idx_cq_d_combo on complete_q (d_combo);

-- Create equivalence between existing_q and future RxNorm Extension (complete_q)
drop table existing_to_complete purge;
create table existing_to_complete nologging as
select e.concept_code as e_code, c.concept_code as c_code
from existing_q e
join complete_q c using(quant_value, quant_unit, i_combo, d_combo, df_code, bn_code, bs, mf_code)
;

commit;

/**************************************************************************
* 2. Create the list of all all existing r products in attribute notation * 
***************************************************************************/
drop table existing_r purge;
create table existing_r nologging as
-- Marketed Product
  select distinct 
    c.concept_id, nvl(r_quant.value,0) as quant_value, nvl(r_quant.unit_id, 0) as quant_unit_id, c.i_combo, c.d_combo, nvl(r_df.df_id,0) as df_id,
     nvl(r_bn.bn_id,0) as bn_id, nvl(r_bs.bs,0) as bs, r_mf.mf_id as mf_id,
    'Marketed Product' as concept_class_id
  from r_combo c
  join r_df on r_df.concept_id=c.concept_id 
  join r_mf r_mf on r_mf.concept_id=c.concept_id 
  left join r_quant on r_quant.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id
  where c.d_combo!=' '
union
-- Quant Branded Box
  select distinct 
    c.concept_id, r_quant.value as quant_value, r_quant.unit_id as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, r_bn.bn_id, r_bs.bs, 0 as mf_id,
    'Quant Branded Box' as concept_class_id
  from r_combo c
  join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  join r_bs on r_bs.concept_id=c.concept_id
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where c.d_combo!=' ' and r_mf.mf_id is null
union
-- Quant Clinical Box
  select distinct 
    c.concept_id, r_quant.value as quant_value, r_quant.unit_id as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, 0 as bn_id, r_bs.bs, 0 as mf_id,
    'Quant Clinical Box' as concept_class_id
  from r_combo c
  join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  join r_bs on r_bs.concept_id=c.concept_id
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where c.d_combo!=' ' and r_bn.concept_id is null and r_mf.mf_id is null
union
-- Branded Drug Box
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, r_bn.bn_id, r_bs.bs, 0 as mf_id,
    'Branded Drug Box' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where r_quant.concept_id is null and c.d_combo!=' ' and r_mf.mf_id is null
union
-- Clinical Drug Box
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, 0 as bn_id, r_bs.bs, 0 as mf_id,
    'Clinical Drug Box' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where r_quant.concept_id is null and c.d_combo!=' ' and r_bn.concept_id is null and r_mf.mf_id is null
union
-- Quant Branded Drug
  select distinct 
    c.concept_id, r_quant.value as quant_value, r_quant.unit_id as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, r_bn.bn_id, 0 as bs, 0 as mf_id,
    'Quant Branded Drug' as concept_class_id
  from r_combo c
  join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id 
  where r_bs.concept_id is null and c.d_combo!=' ' and r_mf.mf_id is null
union
-- Quant Clinical Drug
  select distinct 
    c.concept_id, r_quant.value as quant_value, r_quant.unit_id as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, 0 as bn_id, 0 as bs, 0 as mf_id,
    'Quant Clinical Drug' as concept_class_id
  from r_combo c
  join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_bn.concept_id is null and c.d_combo!=' ' and r_bs.concept_id is null and r_mf.mf_id is null
union
-- Branded Drug
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, r_bn.bn_id, 0 as bs, 0 as mf_id,
    'Branded Drug' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo!=' ' and r_bs.concept_id is null AND r_mf.mf_id is null
union
-- Clinical Drug
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, 0 as bn_id, 0 as bs, 0 as mf_id,
    'Clinical Drug' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo!=' ' and r_bn.concept_id is null and r_bs.concept_id is null and r_mf.mf_id is null
union
-- Branded Drug Form
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, r_bn.bn_id, 0 as bs, 0 as mf_id,
    'Branded Drug Form' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo=' ' and r_bs.concept_id is null and r_mf.mf_id is null
union
-- Clinical Drug Form
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, r_df.df_id, 0 as bn_id, 0 as bs, 0 as mf_id,
    'Clinical Drug Form' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo=' ' and r_bn.concept_id is null and r_bs.concept_id is null and r_mf.mf_id is null
union
-- Branded Drug Component
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, 0 as df_id, r_bn.bn_id, 0 as bs, 0 as mf_id,
    'Branded Drug Comp' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  left join r_df on r_df.concept_id=c.concept_id
  join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo!=' ' and r_df.concept_id is null and r_bs.concept_id is null and r_mf.mf_id is null -- denominator_value is ignored
union
-- Clinical Drug Component 
  select distinct 
    c.concept_id, 0 as quant_value, 0 as quant_unit_id, c.i_combo, c.d_combo, 0 as df_id, 0 as bn_id, 0 as bs, 0 as mf_id,
    'Clinical Drug Comp' as concept_class_id
  from r_combo c
  left join r_quant on r_quant.concept_id=c.concept_id
  left join r_df on r_df.concept_id=c.concept_id
  left join r_bn on r_bn.concept_id=c.concept_id
  left join r_bs on r_bs.concept_id=c.concept_id 
  left join r_mf r_mf on r_mf.concept_id=c.concept_id
  where r_quant.concept_id is null and c.d_combo!=' ' and r_df.concept_id is null and r_bn.concept_id is null and r_bs.concept_id is null and r_mf.mf_id is null 
;

-- RxNorm has duplicates by attributes. Usually Ingredient and Precise Ingredient versions of the same drug. The Precise tends to be newer. This query picks the newest
delete from existing_r where rowid in (
  select rowid from (
    select e.rowid, c.concept_name, first_value(c.concept_name) over (partition by quant_value, quant_unit_id, i_combo, d_combo, df_id, bn_id, bs, mf_id order by valid_start_date desc) as newest
    from existing_r e join concept c using(concept_id)
  ) where concept_name!=newest
)
;

/*****************************************************
* 4. Compare new drug vocabulary q to existing one r *
*****************************************************/
-- Strategy: replace attributes with existing ones. Since there are multiple choices for quant, i_combo, d_combo, df_code, bn_code and mf_code, start with lowest (most defined) concept_classes and move up
-- If there is a conflict (more than one equally good choices despite precs and div), split up
-- At the end, if all attributes of a concept are replaced, it's a full hit. The others, partial hits, still have the optimally translated attributes.

-- Prep dose form groups (with some additions for RxNorm Extension) as a way to stratify drug_strength translation within such group
drop table dfg purge;
create table dfg as
select df.concept_id as df_id, nvl(dfg.concept_id_2, concept_id) as dfg_id -- not all of them have a DFG, they stand for themselves
from concept df
left join (
  select concept_id_1, concept_id_2, concept_name from concept_relationship -- and r.invalid_reason is null -- XXXX reinstate invalid_reason after Timur is done with rxnorm/load_stage
  join concept on concept_id=concept_id_2 and vocabulary_id in ('RxNorm', 'RxNorm Extension') and concept_class_id='Dose Form Group'
union
  select 43126086, 36217219, 'Drug Implant Product' from dual -- Intrauterine System
union
  select 21014175, 36217219, 'Drug Implant Product' from dual -- Intrauterine device
union
  select 43563502, 36217218, 'Ophthalmic Product' from dual -- Intravitreal Applicator
union
  select 43126087, 36217206, 'Topical Product' from dual -- Medicated Nail Polish
union
  select 21014177, 36217206, 'Topical Product' from dual -- Medicated nail lacquer
union
  select 43563498, 36217213, 'Nasal Product' from dual -- Nasal Pin
union
  select 19129401, 36217206, 'Topical Product' from dual -- Ointment
union
  select 21014169, 36217206, 'Topical Product' from dual -- Paint
union
  select 21014176, 36217206, 'Topical Product' from dual -- Poultice
union
  select 19000942, 36217211, 'Rectal Product' from dual -- Suppository
union
  select 43563504, 36217215, 'Dental Product' from dual --	Dental Pin
union
  select 21014171, 36217215, 'Dental Product' from dual -- Dental insert
union
  select 21014179, 36217209, 'Vaginal Product' from dual -- Vaginal delivery system
union
  select 21014174, 36217209, 'Vaginal Product' from dual -- Vaginal device
) dfg on dfg.concept_id_1=df.concept_id 
where df.vocabulary_id in ('RxNorm', 'RxNorm Extension') and df.concept_class_id='Dose Form' 
and df.invalid_reason is null
;

-- 1. Create conversion table between existing q and r for Marketed Drugs: d_combo, dfg, bn and mf have to match
drop table x_ds purge;
create table x_ds as
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as rd_combo,   
  df_code, first_value(df_id) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as df_id, 
  bn_code, first_value(bn_id) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as bn_id, 
  mf_code, first_value(mf_id) over (partition by qd_combo, df_code, bn_code, mf_code order by q.mf_prec, q.bn_prec, q.df_prec, q.div desc, q.i_prec, q.u_prec) as mf_id,
  1 as diag
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo,
    eq.d_combo as qd_combo, c.rd_combo, 
    c.u_prec, c.i_prec, c.div, 
    eq.df_code, dfg.dfg_id, dfg.df_prec, -- dfg might not been added yet, in that case df stands for itself
    eq.bn_code, bn.bn_id, bn.prec as bn_prec,
    eq.mf_code, mf.mf_id, mf.prec as mf_prec
  from existing_q eq
  join qr_d_combo c on c.qd_combo=eq.d_combo -- get all potential rd_combos
  join ( -- roll up to dose form group
    select df.df_code, df.prec as df_prec, nvl(dfg.dfg_id, df_id) as dfg_id
    from qr_df df left join dfg using (df_id)
  ) dfg on dfg.df_code=eq.df_code
  join qr_bn bn on bn.bn_code=eq.bn_code -- get potential brand names
  join qr_mf mf on mf.mf_code=eq.mf_code -- get potential manufacturers
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo, d_combo as rd_combo, df_id, nvl(dfg_id, df_id) as dfg_id, bn_id, mf_id from existing_r left join dfg using(df_id)
) r using(rd_combo, dfg_id, bn_id, mf_id)
;

-- 2. Create conversion table between existing q and r for Branded Drugs: d_combo, dfg and bn have to match, mf can be whatever it is
insert into x_ds
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qd_combo, df_code, bn_code order by bn_prec, df_prec, div desc, i_prec, u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo, df_code, bn_code order by bn_prec, df_prec, div desc, i_prec, u_prec) as rd_combo,   
  df_code, first_value(df_id) over (partition by qd_combo, df_code, bn_code order by bn_prec, df_prec, div desc, i_prec, u_prec) as df_id, 
  bn_code, first_value(bn_id) over (partition by qd_combo, df_code, bn_code order by bn_prec, df_prec, div desc, i_prec, u_prec) as bn_id, 
  ' ' as mf_code, 0 as mf_id,
  2 as diag
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo,
    eq.d_combo as qd_combo, c.rd_combo, 
    c.u_prec, c.i_prec, c.div, 
    eq.df_code, dfg.dfg_id, dfg.df_prec, -- dfg might not been added yet, in that case df stands for itself
    eq.bn_code, bn.bn_id, bn.prec as bn_prec
  from existing_q eq
  join qr_d_combo c on c.qd_combo=eq.d_combo -- get all potential rd_combos
  join ( -- roll up to dose form group
    select df.df_code, df.prec as df_prec, nvl(dfg.dfg_id, df_id) as dfg_id
    from qr_df df left join dfg using (df_id)
  ) dfg on dfg.df_code=eq.df_code
  join qr_bn bn on bn.bn_code=eq.bn_code -- get potential brand names
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo, d_combo as rd_combo, df_id, nvl(dfg_id, df_id) as dfg_id, bn_id from existing_r left join dfg using(df_id)
) r using(rd_combo, dfg_id, bn_id)
where not exists ( -- Check we don't already have that combination covered
  select 1 from x_ds e where e.qd_combo=q.qd_combo and e.df_code=q.df_code and e.bn_code=q.bn_code
)
; 
commit;

-- 3: Create conversion table between existing q and r for Clinical Drugs: d_combo and dfg have to match
insert into x_ds
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qd_combo, df_code order by df_prec, div desc, i_prec, u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo, df_code order by df_prec, div desc, i_prec, u_prec) as rd_combo,   
  df_code, first_value(df_id) over (partition by qd_combo, df_code order by df_prec, div desc, i_prec, u_prec) as df_id, 
  ' ' as bn_code, 0 as bn_id,
  ' ' as mf_code, 0 as mf_id,
  3 as diag
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo,
    eq.d_combo as qd_combo, c.rd_combo, 
    c.u_prec, c.i_prec, c.div, 
    eq.df_code, dfg.dfg_id, dfg.df_prec -- dfg might not been added yet, in that case df stands for itself
  from existing_q eq
  join qr_d_combo c on c.qd_combo=eq.d_combo -- get all potential rd_combos
  join ( -- roll up to dose form group
    select df.df_code, df.prec as df_prec, nvl(dfg.dfg_id, df_id) as dfg_id
    from qr_df df left join dfg using (df_id)
  ) dfg on dfg.df_code=eq.df_code
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select distinct concept_id, i_combo, d_combo as rd_combo, df_id, nvl(dfg_id, df_id) as dfg_id from existing_r left join dfg using(df_id)
) r using(rd_combo, dfg_id)
where not exists ( -- Check we don't already have that combination covered
  select 1 from x_ds e where e.qd_combo=q.qd_combo and e.df_code=q.df_code
)
;
commit;

-- 4. Create conversion table between existing q and r for Comps: d_combo have to match
insert into x_ds
select distinct 
  qi_combo, first_value(ri_combo) over (partition by qd_combo order by div desc, i_prec, u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo order by div desc, i_prec, u_prec) as rd_combo,   
  ' ' as df_code, 0 as df_id, 
  ' ' as bn_code, 0 as bn_id,
  ' ' as mf_code, 0 as mf_id,
  4 as diag
from ( -- create existing_q with all attributes extended to their r-corridors
  select 
    eq.i_combo as qi_combo, c.ri_combo,
    eq.d_combo as qd_combo, c.rd_combo, 
    c.u_prec, c.i_prec, c.div
  from existing_q eq
  join qr_d_combo c on c.qd_combo=eq.d_combo -- get all potential rd_combos
) q
join ( -- pick those rd_combos that actually exist in combination with dose form, brand name and manufacturer
  select concept_id, i_combo, d_combo as rd_combo from existing_r 
) r using(rd_combo)
where not exists ( -- Check we don't already have that combination covered
  select 1 from x_ds e where e.qd_combo=q.qd_combo
)
;
commit;

-- 5. Add all those combos that are not used in q, but have a translation to something that exists in r. There shouldn't be any, because q is taken from existing, and r should be fully built out.
insert into x_ds
select distinct 
-- q.concept_code, r.concept_id, 
  qi_combo, first_value(ri_combo) over (partition by qd_combo order by div desc, i_prec, u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo order by div desc, i_prec, u_prec) as rd_combo,   
  ' ' as df_code, 0 as df_id, 
  ' ' as bn_code, 0 as bn_id,
  ' ' as mf_code, 0 as mf_id,
  5 as diag
from qr_d_combo q
-- compare to existing to make sure d_combo is used
join (
  select distinct d_combo as rd_combo from existing_r
) r using(rd_combo)
where not exists ( -- Check we don't already have that combination covered
  select 1 from x_ds e where e.qd_combo=q.qd_combo
)
;
commit;

-- 6: Add singleton ds translations by breaking up translated combinations, unless already covered. They would not have been picked up by lower level hierarchical levels if the ds only exists in combination.
insert into x_ds
select distinct 
  q.qi_combo, r.ri_combo, 
  cast(q_ds as varchar2(20)) as qd_combo, cast(r_ds as varchar2(20)) as rd_combo, 
  ' ' as df_code, 0 as df_id, 
  ' ' as bn_code, 0 as bn_id,
  ' ' as mf_code, 0 as mf_id,
  6 as diag
from ( -- break up all combos for q
  select distinct d_combo as qd_combo, i_code as qi_combo, ds_code as q_ds from q_ds join q_combo using(concept_code) where d_combo like '%-%'
) q
join x_ds qr using(qd_combo) -- find them in the existing complete p to existing r 
join ( -- break up all combos for r
  select distinct d_combo as rd_combo, i_code as ri_combo, ds_code as r_ds from r_ds join r_combo using(concept_id) where d_combo like '%-%'
) r using(rd_combo) 
join qr_uds using(q_ds, r_ds) -- get right component in a combination aligned
where not exists ( -- Check we don't already have that dosage covered
  select 1 from x_ds e where e.qd_combo=cast(q_ds as varchar2(20))
)
;
commit;

-- 7. Add singleton ds translations by breaking up *un*translated combinations, and pick the best singleton translation for them.
insert into x_ds
select distinct
  qi_combo, first_value(ri_combo) over (partition by qd_combo order by div desc, i_prec, u_prec) as ri_combo,     
  qd_combo, first_value(rd_combo) over (partition by qd_combo order by div desc, i_prec, u_prec) as rd_combo,   
  ' ' as df_code, 0 as df_id, 
  ' ' as bn_code, 0 as bn_id,
  ' ' as mf_code, 0 as mf_id,
  7 as diag
from (
  select -- create the ds detail for all components of all combinations
    q_uds.ingredient_concept_code as qi_combo,
    cast(q_uds.ds_code as varchar2(50)) as qd_combo,
    r_uds.i_code as ri_combo,
    cast(r_uds.ds_code as varchar2(50)) as rd_combo,
    u_prec, i_prec, div
  from qr_uds qr join q_uds on q_uds.ds_code=qr.q_ds join r_uds on r_uds.ds_code=qr.r_ds
) q
join ( -- 
  select distinct d_combo as rd_combo from existing_r
) r using(rd_combo)
where not exists ( -- Check we don't already have that combination covered
  select 1 from x_ds e where e.qd_combo=q.qd_combo
)
;
commit;

-- 1. Based on the patterns in ds, create a translation table for ingredients for drug forms
drop table x_ing purge;
create table x_ing as
select qi_combo, ri_combo, df_code, df_id, 1 as diag from x_ds where df_code=' ' -- get all DF-independent
union
select b.qi_combo, b.ri_combo, b.df_code, b.df_id, 1 as diag from x_ds b where b.df_code!=' ' -- and collect those DF-dependent with a different translation. 
and not exists (
  select 1 from x_ds w where w.df_code=' ' and b.qi_combo=w.qi_combo and b.ri_combo=b.ri_combo
)
order by 1;
commit;

-- 2: Add those ingredients that are not in translated DS, but used in them, and prefer the most frequent translation
insert into x_ing
select 
  qi_combo, first_value(ri_combo) over (partition by qi_combo order by cnt desc) as ri_combo, -- pick the most frequent
  ' ' as df_code, 0 as df_id, 2 as diag
from (
  select qi_combo, ri_combo, count(8) as cnt from ( -- count the translations for a single qi
    select distinct
      qi_combo, 
      first_value (ri_combo) over (partition by qi_combo order by prec) as ri_combo -- pick the best translation
    from qr_i
    join x_ds on qi_combo=qi_code and ri_combo=ri_code -- take all translations that exist in q_ds, even if the ds themselves are not translated (wrong dosage)
  )
  group by qi_combo, ri_combo
) q
where not exists (
  select 1 from x_ing where x_ing.qi_combo=q.qi_combo
)
;

-- 3_ Add those i_combos that are not in x_ds, but can be inferred from qr_i_combo (singleton drug forms)
insert into x_ing
select distinct 
  qi_combo, 
  first_value (ri_combo) over (partition by qi_combo order by div desc, i_prec, u_prec) as ri_combo,
  ' ' as df_code, 0 as df_id, 3 as diag  
from qr_i_combo q
where not exists (
  select 1 from x_ing where x_ing.qi_combo=q.qi_combo
)
;
commit;

-- 4. Add any translations not found in the data, but provided by the input tables
insert into x_ing
select distinct
  qi_code as qi_combo,
  first_value (ri_code) over (partition by qi_code order by prec) as ri_combo, -- pick the best translation
  ' ' as df_code, 0 as df_id, 4 as diag
from qr_i
where not exists (
  select 1 from x_ing where qi_combo=qi_code
)
;
commit;

select distinct i_code from q_ing
minus
select qi_combo from x_ing;
select i_combo from q_combo
minus
select qi_combo from x_ing
;




-- Dose Forms
drop table x_df purge;
create table x_df nologging as
with x as (
  select irs.concept_code_2 as q_code, q_df.concept_name as q_name, r_drug.concept_code as r_code, r_drug.vocabulary_id as r_vocab
  from internal_relationship_stage irs 
-- get dose form for name
  join drug_concept_stage q_df on q_df.concept_code=irs.concept_code_2
-- get drug having q dose form
  join drug_concept_stage q_drug on q_drug.concept_code=irs.concept_code_1
  join existing_to_complete etc on etc.e_code=q_drug.concept_code
  join q_to_r qr on qr.q_dcode=etc.c_code 
-- get translation of q dose form to r dose form
  join r_to_c r on r.concept_code_1=irs.concept_code_2
  join concept r_drug on r_drug.concept_id=r.concept_id_2 
  join concept_relationship cr on cr.concept_id_2=r_drug.concept_id and qr.r_did=cr.concept_id_1 and cr.relationship_id='RxNorm has dose form'
  where q_drug.concept_class_id not in ('Ingredient', 'Device', 'Unit', 'Supplier', 'Dose Form', 'Brand Name') -- exclude upgrade links 
)
select distinct
  q_code, q_name,
  first_value(r_code) over (partition by q_code order by x2.cnt desc) as r_code,
  first_value(r_vocab) over (partition by q_code order by x2.cnt desc) as r_vocab
from (
  select q_code, r_code, r_vocab, count(8) as cnt from x group by q_code, r_code, r_vocab
) x2
join x using(q_code, r_code, r_vocab)
;
commit;

-- Add those that have not been used in q_to_r, same as with Ingredients
insert into x_df
select 
  q_df.concept_code as q_code,
  q_df.concept_name as q_name,
  nvl(r_df.concept_code, 'XXX'||xxx_seq.nextval) as r_code, 
  r_df.vocabulary_id as r_vocab
from drug_concept_stage q_df 
left join (
  select concept_code_1, concept_code, vocabulary_id
  from r_to_c  join concept on concept_id=concept_id_2 and nvl(precedence, 1)=1
) r_df on r_df.concept_code_1=q_df.concept_code
where q_df.concept_class_id='Dose Form'
and not exists (select 1 from x_df where x_df.q_code=q_df.concept_code)
;
commit;

-- Brand Names
drop table x_bn purge;
create table x_bn nologging as
with x as (
  select irs.concept_code_2 as q_code, b.concept_name as q_name, r_drug.concept_code as r_code, r_drug.vocabulary_id as r_vocab
  from internal_relationship_stage irs 
-- Need to check Brand Name concepts directly, because the relationship_id linking to them is not unique
  join drug_concept_stage b on b.concept_code=irs.concept_code_2 and b.concept_class_id='Brand Name'
-- get drug having q dose form
  join drug_concept_stage q_drug on q_drug.concept_code=irs.concept_code_1
  join existing_to_complete etc on etc.e_code=q_drug.concept_code
  join q_to_r qr on qr.q_dcode=etc.c_code 
-- get translation of q dose form to r dose form
  join r_to_c r on r.concept_code_1=irs.concept_code_2
  join concept r_drug on r_drug.concept_id=r.concept_id_2 
    join concept c on qr.r_did = c.concept_id and  c.concept_class_id !='Ingredient' and c.invalid_reason is null and c.vocabulary_id like 'RxNorm%'
  join concept_relationship cr on cr.concept_id_2=r_drug.concept_id and qr.r_did=cr.concept_id_1 and cr.relationship_id in ('Has brand name')

  where q_drug.concept_class_id not in ('Ingredient', 'Device', 'Unit', 'Supplier', 'Dose Form', 'Brand Name') -- exclude upgrade links 
)
select distinct
  q_code, q_name,
  first_value(r_code) over (partition by q_code order by x2.cnt desc) as r_code,
  first_value(r_vocab) over (partition by q_code order by x2.cnt desc) as r_vocab
from (
  select q_code, r_code, r_vocab, count(8) as cnt from x group by q_code, r_code, r_vocab
) x2
join x using(q_code, r_code, r_vocab)
;
commit;

-- Add those that have not been used in q_to_r
insert into x_bn
select 
  q_bn.concept_code as q_code, q_bn.concept_name as q_name,
  nvl(r_bn.concept_code, 'XXX'||xxx_seq.nextval) as r_code, 
  r_bn.vocabulary_id as r_vocab
from drug_concept_stage q_bn
left join (
  select concept_code_1, concept_code, vocabulary_id
  from r_to_c  join concept on concept_id=concept_id_2 and nvl(precedence, 1)=1
) r_bn on r_bn.concept_code_1=q_bn.concept_code
where q_bn.concept_class_id='Brand Name'
and not exists (select 1 from x_bn where x_bn.q_code=q_bn.concept_code)
;
commit;

-- Suppliers
drop table x_mf purge;
create table x_mf nologging as
with x as (
  select irs.concept_code_2 as q_code, q_mf.concept_name as q_name, r_drug.concept_code as r_code, r_drug.vocabulary_id as r_vocab
  from internal_relationship_stage irs 
-- get supplier for name
  join drug_concept_stage q_mf on q_mf.concept_code=irs.concept_code_2
-- get drug having q dose form
  join drug_concept_stage q_drug on q_drug.concept_code=irs.concept_code_1
  join existing_to_complete etc on etc.e_code=q_drug.concept_code
  join q_to_r qr on qr.q_dcode=etc.c_code 
-- get translation of q dose form to r dose form
  join r_to_c r on r.concept_code_1=irs.concept_code_2
  join concept r_drug on r_drug.concept_id=r.concept_id_2 
  join concept_relationship cr on cr.concept_id_2=r_drug.concept_id and qr.r_did=cr.concept_id_1 and cr.relationship_id in ('Has supplier')
  where q_drug.concept_class_id not in ('Ingredient', 'Device', 'Unit', 'Supplier', 'Dose Form', 'Brand Name') -- exclude upgrade links 
)
select distinct
  q_code, 
  q_name,
  first_value(r_code) over (partition by q_code order by x2.cnt desc) as r_code,
  first_value(r_vocab) over (partition by q_code order by x2.cnt desc) as r_vocab
from (
  select q_code, r_code, r_vocab, count(8) as cnt from x group by q_code, r_code, r_vocab
) x2
join x using(q_code, r_code, r_vocab)
;
commit;

-- Add those that have not been used in q_to_r
insert into x_mf
select 
  q_mf.concept_code as q_code,
  q_mf.concept_name as q_name,
  nvl(r_mf.concept_code, 'XXX'||xxx_seq.nextval) as r_code, 
  r_mf.vocabulary_id as r_vocab
from drug_concept_stage q_mf
left join (
  select concept_code_1, concept_code, vocabulary_id
  from r_to_c join concept on concept_id=concept_id_2 and nvl(precedence, 1)=1
) r_mf on r_mf.concept_code_1=q_mf.concept_code
where q_mf.concept_class_id='Supplier'
and not exists (select 1 from x_mf where x_mf.q_code=q_mf.concept_code)
;
commit;




-- Create new i, ds, df, bn and mf entities
-- Use x_ds and qr_i, and add by priority.
-- Add to uds, ds and d_combo on either side
-- Add to x_ds and qr_i
-- Build x_ds, x_bn, x_mf






-- Build full extension with optimal attributes
drop table extension purge;
-- join everything we know and can translate. Start with dose-containing concept classes
create table extension as
select distinct
  cq.concept_code,
  cq.quant_value*urc.conversion_factor as q_quant_value, c.quant_unit_id as q_quant_unit_id, q.r_value as r_quant_value, q.r_unit_id as r_quant_unit_id, 
  cq.i_combo, cq.d_combo, d.ri_combo, d.rd_combo,
  df_id,
  bn_code, bn.bn_id as bn_id1, d.bn_id as bn_id2,
  cq.bs, -- gets passed through
  mf_code, mf.mf_id as mf_id1, d.mf_id as mf_id2,
  cq.concept_class_id
from complete_q cq
left join r_combo c on cq.i_combo=c.i_combo and cq.d_combo=c.d_combo -- to grab the quant unit
left join r_to_c urc on cq.quant_unit=urc.concept_code_1 and c.quant_unit_id=urc.concept_id_2 -- if there is no combination, translate the unit and get the conversion factor
left join qr_quant q on q.q_value=cq.quant_value and q.q_unit=cq.quant_unit and q.r_unit_id=c.quant_unit_id -- get existing quant translations (with some rounding)
left join qr_df df using(df_code) -- get generic df translation
left join ( -- get dose form group 
  select df.df_code, df.prec as df_prec, nvl(dfg.dfg_id, df_id) as dfg_id
  from qr_df df left join dfg using (df_id)
) dfg using (df_code)
left join qr_bn bn using(bn_code) -- get generic bn translation
left join qr_mf mf using(mf_code) -- get generic mf translation
left join qr_d d on cq.i_combo=d.qi_combo and cq.d_combo=d.qd_combo and nvl(dfg.dfg_id, d.dfg_id)=d.dfg_id 
  and nvl(bn.bn_id, d.bn_id)=d.bn_id and nvl(mf.mf_id, d.mf_id)=d.mf_id
where cq.d_combo!=' '
;
select * from extension where d_combo='14856' order by 1;
select * from drug_concept_stage where concept_code in ('OMOP452289', 'OMOP428334', 'OMOP428333', 'OMOP452291');
select * from q_ds join drug_concept_stage using(concept_code) where ds_code=14854;
select * from q_uds join drug_concept_stage on ingredient_concept_code=concept_code where ds_code=6289;
select * from qr_d_combo where qi_combo='8137';
select * from qr_uds where q_ds=8137;
select * from r_uds where ingredient_concept_id=1036157;
select * from ds_stage where drug_concept_code='OMOP412180';
select * from concept where concept_code='10167';
select * from r_to_c
join concept c1 on c1.concept_code=concept_code_1 and c1.concept_id=concept_id_2
where concept_code_1='10046';
select * from concept where upper(concept_name) like '%CHAMOMILE%' and vocabulary_id='RxNorm';
select * from concept where concept_id in (21018888, 43130801, 21014840);
select * from complete_q;
select * from qr_quant;
with d as (
  select distinct 
    qi_combo, 
    first_value(ri_combo) over (partition by qd_combo, bn_id order by bn_prec desc, df_prec, div desc, i_prec, u_prec) as ri_combo, -- best ds combo(s)
    bn_code, -- for brand names and clinical drugs that weren't in existing, it should be mapped through bn_id below
    first_value(bn_id) over (partition by qd_combo, dfg_id, bn_id order by bn_prec desc, df_prec, div desc, i_prec, u_prec) as bn_id
  from qr_qr_d
)
select qi_combo, ri_combo from (select distinct qi_combo, ri_combo from d) group by qi_combo, ri_combo having count(8)>1
-- select * from d join (select qd_combo, dfg_id, bn_id from d group by qd_combo, dfg_id, bn_id having count(8)>1) using(qd_combo, dfg_id, bn_id)
order by 1;


-- Marketed Product
-- Quant Branded Box
-- Quant Clinical Box
-- Branded Drug Box
-- Clinical Drug Box
-- Quant Branded Drug
-- Quant Clinical Drug
-- Branded Drug
-- Clinical Drug
-- Branded Drug Form
-- Clinical Drug Form
-- Branded Drug Component
-- Clinical Drug Component 










/***********************************************************************************************************
* 5. Generate unique and optimal mappings for attributes (Ingredients, Dose Forms, Brand Names, Suppliers) *
***********************************************************************************************************/


-- Determine which Ingredients, Dose Forms, Brand Names, Suppliers are the preferred ones (from the mapped contingent) by checking which of them was most often identified in q_to_r
-- Ingredients
drop table x_ing purge;
create table x_ing nologging as
with x as (
  select irs.concept_code_2 as q_code, i.concept_name as q_name, r_drug.concept_code as r_code, r_drug.vocabulary_id as r_vocab
  from internal_relationship_stage irs 
-- get ingredient
  join drug_concept_stage i on i.concept_code=irs.concept_code_2
-- get drug containing q ingredient
  join drug_concept_stage q_drug on q_drug.concept_code=irs.concept_code_1
  join existing_to_complete etc on etc.e_code=q_drug.concept_code
  join q_to_r qr on qr.q_dcode=etc.c_code 
-- get translation of q ingredient to r ingredient
  join r_to_c r on r.concept_code_1=irs.concept_code_2
  join concept r_drug on r_drug.concept_id=r.concept_id_2 
  join concept_ancestor a on a.ancestor_concept_id=r_drug.concept_id and qr.r_did=a.descendant_concept_id
  where q_drug.concept_class_id not in ('Ingredient', 'Device', 'Unit', 'Supplier', 'Dose Form', 'Brand Name') -- exclude upgrade links 
)
select distinct
  q_code,
  q_name, -- original name if no translation available
  first_value(r_code) over (partition by q_code order by x2.cnt desc) as r_code,
  first_value(r_vocab) over (partition by q_code order by x2.cnt desc) as r_vocab
from (
  select q_code, r_code, r_vocab, count(8) as cnt from x group by q_code, r_code, r_vocab
) x2
join x using(q_code, r_code, r_vocab)
;
commit;

-- Add those that have not been used in q_to_r and adopt concept_relationship_stage precedence=1
insert into x_ing
select 
  q_ing.concept_code as q_code, 
  q_ing.concept_name as q_name,
  nvl(r_ing.concept_code, 'XXX'||xxx_seq.nextval) as r_code, -- create new XXX code for new Ingredients
  r_ing.vocabulary_id as r_vocab -- Convention: If null then new, otherwise RxNorm or RxNorm Extension
from drug_concept_stage q_ing 
left join (
  select concept_code_1, concept_code, vocabulary_id
  from r_to_c  join concept on concept_id=concept_id_2 and nvl(precedence, 1)=1
) r_ing on r_ing.concept_code_1=q_ing.concept_code
where q_ing.concept_class_id='Ingredient'
--  and q_ing.standard_concept='S' 
  and q_ing.invalid_reason is null
and not exists (select 1 from x_ing where x_ing.q_code=q_ing.concept_code)
;
commit;

/*******************************************************************************************
* 6. Create RxNorm Extension from complete_q, but in RxNorm notion and deduped *
*******************************************************************************************/

-- collect statistics so Oracle does the following in a reasonable approach
exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'q_ds', estimate_percent  => null, cascade  => true);
exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'complete_q', estimate_percent  => null, cascade  => true);

-- extension_q_ds differes from q_uds by converting the units (applying the conversion_factors)
drop table extension_ds purge;
create table extension_ds nologging as
with q_q_ds as (
  select 
    cq.concept_code as drug_concept_code, 
    uds.ingredient_concept_code,
    uds.amount_value, uds.amount_unit, 
    uds.numerator_value*case cq.denominator_value when 0 then 1 else denominator_value end as numerator_value, -- reconstitue full quantified 
    uds.numerator_unit,
    cq.denominator_value, uds.denominator_unit
  from q_uds uds join q_ds on uds.ds_code=q_ds.ds_code join q_combo dc on dc.concept_code=q_ds.concept_code 
  join complete_q cq on cq.d_combo=dc.combo_code and cq.concept_class_id!='Clinical Drug Comp' -- in Clinical Drug Comp no combinations of ds_codes
union
  select cq.concept_code as drug_concept_code,
    uds.ingredient_concept_code, uds.amount_value, uds.amount_unit, 
    uds.numerator_value, uds.numerator_unit, 
    0 as denominator_value, uds.denominator_unit
  from q_uds uds
  join complete_q cq on cq.d_combo=uds.ds_code and cq.concept_class_id='Clinical Drug Comp' -- in Clinical Drug Comp no combinations of 
)
select num, drug_concept_code, ingredient_concept_code, ingredient_vocab, 
  amount_value, amount_unit_concept_id, 
  numerator_value, numerator_unit_concept_id, 
  denominator_value, denominator_unit_concept_id 
from (
-- Create the numbers
  select distinct 
    rownum as num, -- so we can later refer to the unique q_ds entries in extension_combo
    q_q_ds.drug_concept_code, 
    x_ing.r_code as ingredient_concept_code, 
    nvl(x_ing.r_vocab, ' ') as ingredient_vocab, -- new RxNorm Extension ingredient, ' ' but faster for comparison
    case when q_q_ds.amount_value=0 then null else q_q_ds.amount_value*nvl(q_q_ds_a.conversion_factor, 1) end as amount_value, 
    q_q_ds_a.concept_id_2 as amount_unit_concept_id, 
    case when q_q_ds.numerator_value=0 then null else 
      case when q_q_ds.denominator_value=0 then q_q_ds.numerator_value*nvl(q_q_ds_n.conversion_factor, 1)/nvl(q_q_ds_d.conversion_factor, 1) -- if there is no denominator value the conversion needs to fix he numerator
        else q_q_ds.numerator_value*nvl(q_q_ds_n.conversion_factor, 1) -- if there is a denominator value the conversion will only affect this
      end
    end as numerator_value, 
    q_q_ds_n.concept_id_2 as numerator_unit_concept_id,
    case when q_q_ds.denominator_value=0 then null else q_q_ds.denominator_value*nvl(q_q_ds_d.conversion_factor, 1) end as denominator_value, 
    q_q_ds_d.concept_id_2 as denominator_unit_concept_id
  from q_q_ds
  join x_ing on x_ing.q_code=q_q_ds.ingredient_concept_code -- and coalesce(q_q_ds_a.concept_code_1, q_q_ds_n.concept_code_1, q_q_ds_d.concept_code_1) is not null
  left join r_to_c q_q_ds_a on q_q_ds_a.concept_code_1=q_q_ds.amount_unit and nvl(q_q_ds_a.precedence, 1)=1 -- amount units
  left join r_to_c q_q_ds_n on q_q_ds_n.concept_code_1=q_q_ds.numerator_unit and nvl(q_q_ds_n.precedence, 1)=1 -- numerator units
  left join r_to_c q_q_ds_d on q_q_ds_d.concept_code_1=q_q_ds.denominator_unit and nvl(q_q_ds_d.precedence, 1)=1 -- denominator units
)
;
commit;

exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'x_bn', estimate_percent  => null, cascade  => true);
exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'q_to_r', estimate_percent  => null, cascade  => true);

-- Create full RxNorm universe from complete_q
drop table extension_attribute purge;
create table extension_attribute nologging as
select distinct
  c.concept_code,
  denominator_value as quant,
  case when df_code=' ' then ' ' else coalesce(tdf.tree_df_code, cdf.concept_code, x_df.r_code) end as df_code, -- ' ' means no Dose Form
  coalesce(tdf.tree_df_vocab, cdf.vocabulary_id, ' ') as dose_form_vocab, 
  case when bn_code=' ' then ' ' else coalesce(tbn.tree_bn_code, cbn.concept_code, x_bn.r_code) end as bn_code,
  coalesce(tbn.tree_bn_vocab, cbn.vocabulary_id, ' ') as brand_vocab,
  box_size,
  case when mf_code=' ' then ' ' else nvl(cmf.concept_code, x_mf.r_code) end as supplier_code,
  nvl(cmf.vocabulary_id, ' ') as supplier_vocab,
  c.concept_class_id
from complete_q c
-- get general gues dose form
left join x_df on x_df.q_code=c.df_code
left join concept cdf on cdf.concept_code=x_df.r_code and cdf.vocabulary_id=x_df.r_vocab
-- get specific dose form of q_to_r equivalent in the tree
left join (
  select concept_id_2, denominator_value, i_combo, d_combo, df_code, bn_code, box_size, mf_code, q_df.concept_code as tree_df_code, q_df.vocabulary_id as tree_df_vocab
  from complete_q
  join x_df on q_code=df_code -- get best general translation
  join q_to_r on q_dcode=concept_code -- get specific equivalent
  join concept_relationship on r_did=concept_id_1 and relationship_id='RxNorm has dose form' and invalid_reason is null -- retrieve Dose Form of specific equivalent
  join concept q_df on q_df.concept_id=concept_id_2 -- get concept for concept_code and vocabulary_id
  where (r_code!=df.concept_code or r_vocab!=df.vocabulary_id) -- only those where general and specific differ
) tdf using(denominator_value, i_combo, d_combo, df_code, bn_code, box_size, mf_code)
-- get brand name
left join x_bn on x_bn.q_code=bn_code
left join concept cbn on cbn.concept_code=x_bn.r_code and cbn.vocabulary_id=x_bn.r_vocab
-- get specific brand name of q_to_r equivalent in the tree
left join (
  select denominator_value, i_combo, d_combo, df_code, bn_code, box_size, mf_code, 
  null as tree_bn_code, null as tree_bn_vocab
--  q_bn.concept_code as tree_bn_code, q_bn.vocabulary_id as tree_bn_vocab
  from complete_q
/* Needs fixing XXXXXX
  join x_bn on q_code=bn_code -- get best general translation
  join q_to_r on q_dcode=concept_code -- get specific equivalent
  join concept_relationship on r_did=concept_id_1 and relationship_id='Has brand name' -- retrieve Brand Name of specific equivalent !!! check for Ingredients problem
  join concept q_bn on q_bn.concept_id=concept_id_2 -- get concept for concept_code and vocabulary_id
  where r_code!=bn.concept_code or r_vocab!=bn.vocabulary_id -- only those where general and specific differ
*/
) tbn using(denominator_value, i_combo, d_combo, df_code, bn_code, box_size, mf_code)
-- get supplier
left join x_mf on x_mf.q_code=mf_code
left join concept cmf on cmf.concept_code=x_mf.r_code and cmf.vocabulary_id=x_mf.r_vocab
;
commit;

-- Create an final version of the q_ds
drop table extension_combo purge;
create table extension_combo as
-- for each drug/ingredient/rounded q_ds pair get the lowest num from extension_ds
with ueds as (
-- Get the concept_code and the lowest record number of all unique q_ds records. Use the raw numbers, rounded to 3 and 2 signficant digits
-- Perform the rounding to 2 significant digits
  select distinct -- partition by rounding to 3 significant numbers
    first_value(u3num) over (
      partition by ingredient_concept_code, ingredient_vocab, 
        units,
        round(amount_value, 2-floor(log(10, amount_value))-1),
        round(norm_num_value, 2-floor(log(10, norm_num_value))-1)
      order by u3num range between unbounded preceding and unbounded following
    ) as unum,
    drug_concept_code, ingredient_concept_code, ingredient_vocab
  from (
-- Perform the rounding to 3 significant digits
    select distinct -- partition by rounding to 3 significant numbers
      units, amount_value, norm_num_value,
      first_value(unum_unrounded) over (
        partition by ingredient_concept_code, ingredient_vocab, 
          units,
          round(amount_value, 3-floor(log(10, amount_value))-1),
          round(norm_num_value, 3-floor(log(10, norm_num_value))-1)
        order by unum_unrounded range between unbounded preceding and unbounded following
      ) as u3num,
      drug_concept_code, ingredient_concept_code, ingredient_vocab
    from (
-- Partition by raw numerical values of amount and numerator/denominator
      select distinct
        units, amount_value, norm_num_value,    
    -- round(numerator_value/nvl(denominator_value, 1), 2-floor(log(10, numerator_value/nvl(denominator_value, 1)))-1), -- take q_quant out
        first_value(num) over (
          partition by ingredient_concept_code, ingredient_vocab, 
            units, amount_value, norm_num_value
          order by num range between unbounded preceding and unbounded following
        ) as unum_unrounded,
        drug_concept_code, ingredient_concept_code, ingredient_vocab
      from (
        select 
          num, drug_concept_code, ingredient_concept_code, ingredient_vocab,
          amount_unit_concept_id||numerator_unit_concept_id||denominator_unit_concept_id as units,
          amount_value, numerator_value/nvl(denominator_value, 1) as norm_num_value -- q_ds is normalized to denominator of 1        
        from extension_ds -- number the q_ds records
      ) 
    )
  )
)
-- All concept classes that can have combos
select concept_code, i_combo, d_combo
from extension_attribute
join (
  select concept_code, 
    listagg(ucode, '-') within group (order by ucode) as i_combo,
    case when concept_class_id like '%Form' then ' ' else listagg(nvl(to_char(unum), 'i'||ucode), '-') within group (order by ucode) end as d_combo -- use ingredient instead of q_ds if missing
  from (
-- get the concept_code and the smallest record number of all ingredient concept_codes - making it quasi unique. 
  -- Note that the cooncept codes are a mixture of XXX and existing OMOP (RxE) and RxNorm codes
    select distinct cq.concept_code, cq.concept_class_id, r_code as ucode, unum
    from complete_q cq 
    join q_i_combo ic on cq.i_combo=ic.combo_code join q_ing on q_ing.concept_code=ic.concept_code
    join x_ing on q_code=ing.i_code
    left join ueds on drug_concept_code=ccs.concept_code and ingredient_concept_code=r_code and ingredient_vocab=nvl(r_vocab, ' ') 
    where cq.concept_class_id!='Clinical Drug Comp'
  ) 
  group by concept_code, concept_class_id
) using (concept_code)
union
-- Clin Drug Comp
select ea.concept_code, to_char(r_code) as i_combo, to_char(u.unum) as d_combo -- use ingredient instead of q_ds if missing
from extension_attribute ea
join complete_q cq on cq.concept_code=ea.concept_code
join x_ing on q_code=ccs.i_combo
join ueds u on u.drug_concept_code=ea.concept_code and u.ingredient_concept_code=r_code and u.ingredient_vocab=nvl(r_vocab, ' ') 
where ea.concept_class_id='Clinical Drug Comp'
;
commit;

-- Dedup and expand after normalizing the attributes
-- Create table of attributes that can collapse
drop table extension_dedup purge;
create table extension_dedup as
with def as (
  select concept_code, i_combo, d_combo, case nvl(quant, 0) when 0 then 0 else round(quant, 3-floor(log(10, quant))-1) end as quant, 
    df_code, dose_form_vocab, bn_code, brand_vocab, box_size, supplier_code, supplier_vocab
  from extension_attribute join extension_combo using (concept_code)
)
select * from (
  select 
    concept_code as from_code,
    first_value(concept_code) over (partition by i_combo, d_combo, case nvl(quant, 0) when 0 then 0 else round(quant, 3-floor(log(10, quant))-1) end, 
      df_code, dose_form_vocab, bn_code, brand_vocab, box_size, supplier_code, supplier_vocab) as to_code
  from def
  join (
    select i_combo, d_combo, quant, df_code, dose_form_vocab, bn_code, brand_vocab, box_size, supplier_code, supplier_vocab
    from def
    group by i_combo, d_combo, quant, df_code, dose_form_vocab, bn_code, brand_vocab, box_size, supplier_code, supplier_vocab
    having count(8)>1
  ) using (i_combo, d_combo, quant, df_code, dose_form_vocab, bn_code, brand_vocab, box_size, supplier_code, supplier_vocab)
) where from_code!=to_code
;
commit;

-- Clean out staging tables
-- delete from complete_q where concept_code in (select from_code from extension_dedup);
delete from extension_combo where concept_code in (select from_code from extension_dedup);
delete from extension_attribute where concept_code in (select from_code from extension_dedup);
update extension_ds set drug_concept_code=0 where drug_concept_code in (select from_code from extension_dedup);
update existing_to_complete set c_code=(select to_code from extension_dedup where c_code=from_code) where c_code in (select from_code from extension_dedup)
;
commit;

-- Expand missing combinations due to different translations of the same i, df, q_bn to Rx/E
drop table expand purge;
create table expand as
with e as (
  select distinct concept_code,
    ec.i_combo as i, ec.d_combo as d, 
    case ea.quant when 0 then 0 else round(ea.quant, 3-floor(log(10, ea.quant))-1) end as quant, ea.box_size as bs,
    ea.df_code as df, ea.dose_form_vocab as dv,
    c.df_code as cf, -- the original ambiguous dose form
    ea.bn_code as bn, brand_vocab as bv, 
    c.bn_code as cb, -- the original ambiguous brand 
    ea.supplier_code as mf, ea.supplier_vocab as mv,
    c.mf_code as cm, -- the original ambiguous supplier
    c.concept_class_id
  from complete_q c join extension_combo ec using (concept_code) join extension_attribute ea using (concept_code) 
), f as ( -- only the existing ones. Note. They are not distinct with their attributes, because more than one code can point to one c_code in existing_to_complete
  select * from e join existing_to_complete on concept_code=c_code 
)
select * from (  
  -- Marketed Product
  select f.i, f.d, f.quant, f.bs, f.df, f.dv, f.cf, f.bn, f.bv, f.cb, f.mf, f.mv, f.cm, 'Marketed Product' as concept_class_id
  from f
  where ' '!=all(f.i, f.d, f.df, f.mf)
  union
  -- q_quant Branded Box
  select f.i, f.d, f.quant, f.bs, f.df, f.dv, f.cf, f.bn, f.bv, f.cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Quant Branded Box' as concept_class_id
  from f
  where 0!=all(f.quant, f.bs) and ' '!=all(f.i, f.d, f.df, f.bn)
  union
  -- q_quant Clinical Box
  select f.i, f.d, f.quant, f.bs, f.df, f.dv, f.cf, ' ' as bn, ' ' as bv, ' ' as cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Quant Clinical Box' as concept_class_id
  from f
  where 0!=all(f.quant, f.bs) and ' '!=all(f.i, f.d, f.df)
  union
  -- Branded Drug Box
  select f.i, f.d, 0 as quant, f.bs, f.df, f.dv, f.cf, f.bn, f.bv, f.cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Branded Drug Box' as concept_class_id
  from f
  where f.bs!=0 and ' '!=all(f.i, f.d, f.df, f.bn)
  union
  -- Clinical Drug Box
  select f.i, f.d, 0 as quant, f.bs, f.df, f.dv, f.cf, ' ' as bn, ' ' as bv, ' ' as cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Clinical Drug Box' as concept_class_id
  from f
  where 0!=f.bs and ' '!=all(f.i, f.d, f.df)
  union
  -- q_quant Branded Drug
  select f.i, f.d, f.quant, 0 as bs, f.df, f.dv, f.cf, f.bn, f.bv, f.cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Quant Branded Drug' as concept_class_id
  from f
  where 0!=f.quant and ' '!=all(f.i, f.d, f.df, f.bn)
  union
  -- q_quant Clinical Drug
  select f.i, f.d, f.quant, 0 as bs, f.df, f.dv, f.cf, ' ' as bn, ' ' as bv, ' ' as cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Quant Clinical Drug' as concept_class_id
  from f
  where 0!=f.quant and ' '!=all(f.i, f.d, f.df)
  union
  -- Branded Drug
  select f.i, f.d, 0 as quant, 0 as bs, f.df, f.dv, f.cf, f.bn, f.bv, f.cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Branded Drug' as concept_class_id
  from f
  where ' '!=all(f.i, f.d, f.df, f.bn)
  union
  -- Clinical Drug
  select f.i, f.d, 0 as quant, 0 as bs, f.df, f.dv, f.cf, ' ' as bn, ' ' as bv, ' ' as cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Clinical Drug' as concept_class_id
  from f
  where ' '!=all(f.i, f.d, f.df)
  union
  -- Branded Drug Form
  select f.i, ' ' as d, 0 as quant, 0 as bs, f.df, f.dv, f.cf, f.bn, f.bv, f.cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Branded Drug Form' as concept_class_id
  from f
  where ' '!=all(f.i, f.df, f.bn)
  union
  -- Clinical Drug Form
  select f.i, ' ' as d, 0 as quant, 0 as bs, f.df, f.dv, f.cf, ' ' as bn, ' ' as bv, ' ' as cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Clinical Drug Form' as concept_class_id
  from f
  where ' '!=all(f.i, f.df)
  union
  -- Branded Drug Component
  select f.i, f.d, 0 as quant, 0 as bs, ' ' as df, ' ' as dv, ' ' as cf, f.bn, f.bv, f.cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Branded Drug Comp' as concept_class_id
  from f
  where ' '!=all(f.i, f.d, f.bn)
  union
  -- Clinical Drug Component - split i and d
  select * from (
    select 
      trim(regexp_substr(f.i, '[^\-]+', 1, levels.column_value)) as i,
      trim(regexp_substr(f.d, '[^\-]+', 1, levels.column_value)) as d,
      0 as quant, 0 as bs, ' ' as df, ' ' as dv, ' ' as cf, ' ' as bn, ' ' as bv, ' ' as cb, ' ' as mf, ' ' as mv, ' ' as cm, 'Clinical Drug Comp' as concept_class_id
    from f, table(cast(multiset(select level from dual connect by level <= length (regexp_replace(f.i, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
    where ' '!=all(f.i, f.d)
  ) where substr(d, 1, 1)!='i' -- don't create when the component is only an ingredient
) g
where not exists (
  select 1 from e h where g.i=h.i and g.d=h.d and g.quant=h.quant and g.bs=h.bs and g.df=h.df and g.dv=h.dv and g.bn=h.bn and g.bv=h.bv and g.mf=h.mf and g.mv=h.mv
    and g.concept_class_id=h.concept_class_id
)
;
commit;

-- Create missing extension
drop table extension_expand purge;
create table extension_expand as
-- create missing: Pull descreasing number of attributes
select 'XXX'||xxx_seq.nextval as concept_code, -- make sure xxx_seq is defined.
  c.*
from (select distinct i, d, quant, bs, df, dv, bn, bv, mf, mv, concept_class_id from expand) c
;
commit;


-- Add to the various tables
-- transfer q_to_r from alternative df, bn, q_mf and create q_to_r
drop table q_to_r purge;
create table q_to_r as
with et as (
  select distinct concept_code,
    ec.i_combo as i, ec.d_combo as d, 
    case ea.quant when 0 then 0 else round(ea.quant, 3-floor(log(10, ea.quant))-1) end as quant, ea.box_size as bs,
    ea.df_code as df, ea.dose_form_vocab as dv,
    c.df_code as cf, -- the original ambiguous dose form
    ea.bn_code as bn, brand_vocab as bv, 
    c.bn_code as cb, -- the original ambiguous brand 
    ea.supplier_code as mf, ea.supplier_vocab as mv,
    c.mf_code as cm, -- the original ambiguous supplier
    c.concept_class_id, 
    r_did
  from complete_q c join extension_combo ec using (concept_code) join extension_attribute ea using (concept_code) 
  join q_to_r on q_dcode=concept_code 
)
select ee.concept_code as q_dcode, r_did
from et
-- join through the original dose form code, brand code and supplier code
join expand ex on ex.i=et.i and ex.d=et.d and ex.quant=et.quant and ex.bs=et.bs and ex.cf=et.cf and ex.cb=et.cb and ex.cm=et.cm and ex.concept_class_id=et.concept_class_id
-- join to get the new concept_code
join extension_expand ee on ee.i=ex.i and ee.d=ex.d and ee.quant=ex.quant and ee.bs=ex.bs and ee.df=ex.df and ee.dv=ex.dv and ee.bn=ex.bn and ee.bv=ex.bv and ee.mf=ex.mf and ee.mv=ex.mv
  and ee.concept_class_id=ex.concept_class_id
-- add existing maps
union 
select * from q_to_r
;
commit;

insert into extension_attribute (concept_code, quant, df_code, dose_form_vocab, bn_code, brand_vocab, box_size, supplier_code, supplier_vocab, concept_class_id)
select concept_code, quant, df, dv, bn, bv, bs, mf, mv, concept_class_id
from extension_expand
;

insert into extension_ds (num, drug_concept_code, ingredient_concept_code, ingredient_vocab, amount_value, amount_unit_concept_id,
  numerator_value, numerator_unit_concept_id, denominator_value, denominator_unit_concept_id)
select
  rownum+(select max(num) from extension_ds) as num,
  concept_code as drug_concept_code, 
  ingredient_concept_code, ingredient_vocab, 
  amount_value, amount_unit_concept_id,
  numerator_value/nvl(denominator_value, 1)*case q_quant when 0 then 1 else q_quant end as numerator_value, numerator_unit_concept_id,
  case q_quant when 0 then null else q_quant end as denominator_value, denominator_unit_concept_id
from (
-- decompose d_combo
  select * from (
    select concept_code, quant,
    trim(regexp_substr(d, '[^\-]+', 1, levels.column_value)) as num
  from extension_expand, table(cast(multiset(select level from dual connect by level <= length (regexp_replace(d, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
  ) where substr(num, 1, 1)!='i' -- make sure tehre is no ingredient substitute for the q_ds
) ee
join extension_ds using(num)
;

insert into extension_combo (concept_code, i_combo, d_combo)
select concept_code, i, d from extension_expand
;

commit;

-- Auto-generate all names 
-- Create RxNorm-style units. UCUM units have no normalized abbreviation
drop table concept_to_rxnorm_unit purge;
create table concept_to_rxnorm_unit (rxn_unit varchar2(20), concept_id integer not null);
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('ORGANISMS', 45744815); -- Organisms
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('%', 8554);
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('ACTUAT', 45744809); -- actuation
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('AU', 45744811); -- allergenic unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('BAU', 45744810); -- bioequivalent allergenic unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('CELLS', 45744812); -- cells
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('CFU', 9278); -- colony forming unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('CU', 45744813); -- clinical unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('HR', 8505); -- hour
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('IU', 8718); -- International unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('LFU', 45744814); -- limit of flocculation unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('MCI', 44819154); -- millicurie
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('MEQ', 9551); -- milliequivalent
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('MG', 8576); -- milligram
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('MIN', 9367); -- minim
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('ML', 8587);
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('MMOL', 9573);
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('MU', 9439); -- mega-international unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('PFU', 9379); -- plaque forming unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('PNU', 45744816); -- protein nitrogen unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('SQCM', 9483); -- square centimeter
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('TCID', 9414); -- 50% tissue culture infectious dose
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('UNT', 8510); -- unit
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('IR', 9693); -- index of reactivity
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('X', 9325); -- Decimal potentiation of homeopathic drugs
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('C', 9324); -- Centesimal potentation of homoeopathic drugs
insert into concept_to_rxnorm_unit (rxn_unit, concept_id) values ('', 0); -- empty
commit;

-- collect statistics so Oracle does the following in a reasonable approach
exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'extension_attribute', estimate_percent  => null, cascade  => true);
exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'extension_ds', estimate_percent  => null, cascade  => true);

-- create components
drop table spelled_out purge;
create table spelled_out as
with pre_u as (
  select
    eds.drug_concept_code as concept_code, 
    de.rxn_unit as denominator_unit, -- for quant
    nvl(x.concept_name, i.q_name) as ing_name,
    case
      when nu.rxn_unit='%' then eds.numerator_value -- percent (gas in Rx)
      when eds.denominator_value is not null then eds.numerator_value/case eds.denominator_value when 0 then 1 else eds.denominator_value end -- concentration (liquid)
      when eds.numerator_value is not null then eds.numerator_value -- concentration (liquid)
      when eds.amount_value is not null then eds.amount_value -- absolute (solid)
      else null
    end as v,
    case
      when nu.rxn_unit='%' then '%' -- percent (gas in Rx)
      when eds.denominator_value is not null then nu.rxn_unit||'/'||de.rxn_unit -- concentration (liquid)
      when eds.numerator_value is not null then nu.rxn_unit||'/'||de.rxn_unit -- concentration (liquid)
      when eds.amount_value is not null then au.rxn_unit -- absolute (solid)
      else ''
    end as u
  from extension_ds eds
  left join concept_to_rxnorm_unit au on au.concept_id=eds.amount_unit_concept_id
  left join concept_to_rxnorm_unit nu on nu.concept_id=eds.numerator_unit_concept_id
  left join concept_to_rxnorm_unit de on de.concept_id=eds.denominator_unit_concept_id
  left join concept x on x.concept_code=eds.ingredient_concept_code and x.vocabulary_id=eds.ingredient_vocab -- join Rx ingredient
  left join x_ing i on i.r_code=eds.ingredient_concept_code and eds.ingredient_vocab=' ' -- join source ingredient
union all -- don't kill duplicates of the same ingredient
-- Add Drug Forms that are not in extension_ds
  select i.concept_code, 
    null as denominator_unit, -- for quant
    ing_name, -- Take Rx ingredient name, if possible, or name from source
    null as v, '' as u
  from (
    select 
      ea.concept_class_id, ec.concept_code, 
      trim(regexp_substr(ec.i_combo, '[^\-]+', 1, levels.column_value)) as i_code,
      trim(regexp_substr(ec.d_combo, '[^\-]+', 1, levels.column_value)) as ds_code
      from extension_combo ec, extension_attribute ea,
      table(cast(multiset(select level from dual connect by level <= length (regexp_replace(ec.i_combo, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
      where ea.concept_code=ec.concept_code 
  ) i
  join ( -- create unique ingredient records, which could be duplicate if so in the source data
    select distinct nvl(concept_name, q_name) as ing_name, r_code
    from x_ing
    left join concept x on x.concept_code=r_code and x.vocabulary_id=r_vocab
  ) on i.i_code=r_code
  where (i.concept_class_id like '%Form' or substr(i.ds_code, 2)=i.i_code)
),
-- Add a 0 before a leading dot and round
u as (
  select
    concept_code, denominator_unit,
    ing_name|| -- Take Rx ingredient name, if possible, or name from source
      case when v is null then null else ' '||regexp_replace(round(v, 3-floor(log(10, v))-1), '^\.', '0.') ||' '||u end 
    as comp_name
    from pre_u
)
-- build the entire component
select 
  c.concept_code, 
  case when c.quant=0 then '' else regexp_replace(round(c.quant, 3-floor(log(10, c.quant))-1), '^\.', '0.')||' '||first_value(comp.denominator_unit) ignore nulls over (partition by c.concept_code)||' ' end as quant,
  comp.comp_name,
  sum(comp.comp_len) over (partition by c.concept_code order by comp.comp_name rows between unbounded preceding and current row) as agg_len,
  case when c.df_code=' ' then '' else ' '||nvl(cdf.concept_name, x_df.q_name) end as df_name,
  case when c.bn_code=' ' then '' else ' ['||nvl(cbn.concept_name, x_bn.q_name)||']' end as bn_name,
  case when c.box_size=0 then '' else ' Box of '||c.box_size end as box,
  case when c.supplier_code=' ' then '' -- remove stop words
    else ' by '||replace(replace(replace(replace(replace(replace(replace(replace(nvl(cmf.concept_name, x_mf.q_name), ' Ltd'), ' Plc'), ' UK'), ' (UK)'), ' Pharmaceuticals'), ' Pharma'), ' GmbH'), 'Laboratories') 
  end as mf_name
from extension_attribute c
join (
  select concept_code, denominator_unit, comp_name, length(comp_name)+3 as comp_len -- length plus 3 characters for ' / '
  from u
) comp on comp.concept_code=c.concept_code
-- get dose form from Rx or source
left join concept cdf on cdf.concept_code=c.df_code and cdf.vocabulary_id=c.dose_form_vocab
left join x_df on x_df.r_code=c.df_code and c.dose_form_vocab=' ' and x_df.r_vocab is null
-- get brand name from Rx or source
left join concept cbn on cbn.concept_code=c.bn_code and cbn.vocabulary_id=c.brand_vocab
left join x_bn on x_bn.r_code=c.bn_code and c.brand_vocab=' ' and x_bn.r_vocab is null
-- get supplier
left join concept cmf on cmf.concept_code=c.supplier_code and cmf.vocabulary_id=c.supplier_vocab
left join x_mf on x_mf.r_code=c.supplier_code and c.supplier_vocab=' ' and x_mf.r_vocab is null
;

drop table extension_name purge;
create table extension_name (
  concept_code varchar2(50),
  concept_name varchar2(255)
);

-- Create names 
insert /*+ APPEND */ into extension_name
select
  concept_code,
-- count the cumulative length of the components. The tildas are to make sure the three dots are put at the end of the list
  replace(quant||listagg(comp_name, ' / ') within group (order by comp_name)||df_name||bn_name||box||mf_name, '~~~', '...') as concept_name
from (
-- keep only components where concatenation will leave enough space for the quant, dose form, brand name and box size
  select * from spelled_out s
  where s.agg_len<=255-(nvl(length(s.quant), 0)+nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+nvl(length(s.box), 0)+nvl(length(s.mf_name), 0)+3)
-- Add three dots if ingredients are to be cut
union
  select 
    concept_code,
    quant,
    '~~~' as comp_name, -- last ASCII character to make sure they get sorted towards the end.
    1 as agg_len,
    df_name,
    bn_name,
    box,
    mf_name
  from spelled_out s
  where s.agg_len>255-(nvl(length(s.quant), 0)+nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+nvl(length(s.box), 0)+nvl(length(s.mf_name), 0)+6)
  group by quant, concept_code, df_name, bn_name, box, mf_name 
)
group by quant, concept_code, df_name, bn_name, box, mf_name 
;
commit;

-- Temporary till q_to_r is stable. Currently, it misses alternative df/bn/mf

drop table namesmate purge;
create table namesmate as
select concept_name 
from (
  select concept_name, concept_code from extension_name where not exists (select 1 from q_to_r where q_dcode=concept_code)
)
join (
  select concept_name, concept_class_id from concept where concept.vocabulary_id like 'RxNorm%' and invalid_reason is null
) using(concept_name)
;

insert into q_to_r (q_dcode, r_did)
select cn.concept_code as q_dcode, c.concept_id as r_did
from namesmate
join extension_name cn using(concept_name)
join concept c using(concept_name)
where c.vocabulary_id in ('RxNorm', 'RxNorm Extension') and c.invalid_reason is null
;
commit;


-- Process Packs
-- create XXX type concept_codes for hte new ones
drop table pack_seq purge;
create table pack_seq as
select 
  'XXX'||xxx_seq.nextval as pack_concept_code, source_code from (
    select distinct pack_concept_code as source_code from pc_stage
  )
;
commit;

-- create an xxx version of the existing (later all) packs
drop table complete_pack purge;
create table complete_pack as
select distinct -- because the content in some packs, albeit different in drug_concept_stage, becomes identical after mapping
  pack_concept_code, drug_concept_code, drug_vocab, amount, box_size, bn_code, brand_vocab, supplier_code, supplier_vocab,
  case
    when supplier_code is not null then 'Marketed Product'
    when box_size is not null and bn_code is not null then 'Branded Pack Box'
    when box_size is not null then 'Clinical Pack Box'
    when bn_code is not null then 'Branded Pack'
    else 'Clinical Pack'
  end as concept_class_id
from pack_seq -- just the new concept_codes
join (
  select
    pcs.pack_concept_code as source_code,
    nvl(qr.concept_code, etc.c_code) as drug_concept_code,
    nvl(qr.vocabulary_id, 'RxNorm Extension') as drug_vocab,
    pcs.amount,
    pcs.box_size,
    q_bn.r_code as bn_code,
    case when q_bn.r_code is null then null else nvl(q_bn.r_vocab, 'RxNorm Extension') end as brand_vocab,
    q_mf.r_code as supplier_code,
    case when q_mf.r_code is null then null else nvl(q_mf.r_vocab, 'RxNorm Extension') end as supplier_vocab
  from pc_stage pcs
-- Component drug
  join existing_to_complete etc on etc.e_code=pcs.drug_concept_code -- only drugs that have sufficient definition, if not script will fail
  left join ( -- try translating the drug to Rx/E
    select q_dcode, c.concept_code, c.vocabulary_id
    from q_to_r join concept c on r_did=c.concept_id
  ) qr on qr.q_dcode=etc.c_code 
  left join ( -- Obtain Brand Name
    select concept_code_1, r_code, r_vocab from internal_relationship_stage join x_bn on q_code=concept_code_2
  ) q_bn on q_bn.concept_code_1=pcs.pack_concept_code
  left join ( -- Obtain Supplier
    select concept_code_1, r_code, r_vocab from internal_relationship_stage join x_mf on q_code=concept_code_2
  ) q_mf on q_mf.concept_code_1=pcs.pack_concept_code
) using (source_code)
;
commit;

-- Create new to existing based on components and their amount, but not box_size, brand name and supplier (see below)
drop table pack_q_to_r purge;
create table pack_q_to_r as
select * 
from (
  select distinct pp.pack_concept_code, pp.pack_concept_id as r_id,
    case 
      when nvl(cbn.concept_code, ' ')=nvl(cp.bn_code, ' ') and nvl(cbn.vocabulary_id, ' ')=nvl(cp.brand_vocab, ' ') -- RxNorm does only provide unreliable Brand Name info for Branded Drugs
        and nvl(cmf.concept_code, ' ')=nvl(cp.supplier_code, ' ') and nvl(cmf.vocabulary_id, ' ')=nvl(cp.supplier_vocab, ' ') then 'Marketed'
      when nvl(cbn.concept_code, ' ')=nvl(cp.bn_code, ' ') and nvl(cbn.vocabulary_id, ' ')=nvl(cp.brand_vocab, ' ') 
        and cmf.concept_code is null then 'Branded' 
      when nvl(cmf.concept_code, ' ')=nvl(cp.supplier_code, ' ') and nvl(cmf.vocabulary_id, ' ')=nvl(cp.supplier_vocab, ' ')
        and cbn.concept_code is null then 'Supplied'
      when nvl(cmf.concept_code, cbn.concept_code) is null then 'Clinical'
      else 'Neither'
    end as match
  from (
    select pack_concept_code, pack_concept_id, count(8) as cnt -- the number of content components and their amount per matching pack
-- get those pack/component combinations that are mappable and whose amount matches
    from (
      select * 
-- extract the translatable drug components per pack
      from (
        select pack_concept_code, concept_id as drug_concept_id, amount from complete_pack join concept on concept_code=drug_concept_code and vocabulary_id=drug_vocab
      )
-- extract the drug components per pack in RxE
      join ( -- from RxE
        select distinct pack_concept_id, drug_concept_id, amount from pack_content
      ) using (drug_concept_id, amount)
    ) p_p 
    group by pack_concept_code, pack_concept_id
  ) pp
  -- join to new with same number of components
  join (
    select pack_concept_code, count(8) as cnt from complete_pack group by pack_concept_code
  ) pq on pq.pack_concept_code=pp.pack_concept_code and pq.cnt=pp.cnt
  -- join to existing with same amount of components
  join (
    select pack_concept_id, count(8) as cnt from pack_content group by pack_concept_id
  ) pr on pr.pack_concept_id=pp.pack_concept_id and pr.cnt=pp.cnt
  join complete_pack cp on cp.pack_concept_code=pp.pack_concept_code
  -- find brand name in Rx/e and match
  join concept p on p.concept_id=pp.pack_concept_id -- to check whether it's a Branded Pack, which doesn't always have a relationship to a Brand Name
  left join concept_relationship rb on rb.concept_id_1=pp.pack_concept_id and rb.relationship_id='Has brand name' --!!! check for ingredients problems
  left join concept cbn on (cbn.concept_id=rb.concept_id_2 or cbn.concept_id=1 and (p.concept_class_id='Branded Pack' and p.vocabulary_id='RxNorm'))-- need to find out if RxNorm or existing RxNorm Extension
  -- find supplier in Rx/e and match
  left join concept_relationship rs on rs.concept_id_1=pp.pack_concept_id and rs.relationship_id='Has marketed form'
  left join concept cmf on cmf.concept_id=rs.concept_id_2 -- need to find out if RxNorm or RxNorm Extension
)
-- create 4 columns out of rows 
pivot (
  min(r_id) for match in ('Clinical' as clinical, 'Branded' as branded, 'Supplied' as supplied, 'Marketed' as marketed, 'Neither' as neither)
)
;
commit;

drop table pack_name purge;
create table pack_name as
-- Get the component parts
with c as (
  select 
    cp.pack_concept_code,
    case when cp.amount is null then '' else cp.amount||' ' end||'('||coalesce(cr.concept_name, en.concept_name) as content_name,
    case when cp.amount is null then 0 else length(cp.amount)+1 end as a_len, -- length of the amount
    length(coalesce(cr.concept_name, en.concept_name)) as n_len -- length of the concept_name
  from complete_pack cp
  left join concept cr on cr.concept_code=cp.drug_concept_code and cr.vocabulary_id=cp.drug_vocab
  left join extension_name en on en.concept_code=cp.drug_concept_code and cp.drug_vocab='RxNorm Extension'
--  left join drug_concept_stage cd on cd.concept_code=cp.drug_concept_code and cp.drug_vocab is null
),
-- Get the common part
pd as (
  select distinct
    cp.pack_concept_code, 
    case when cp.bn_code is null then '' else ' ['||nvl(br.concept_name, x_bn.q_name)||']' end as brand_name,
    case when cp.box_size is null then '' else ' box of '||box_size||' ' end as bs_name,
    case when cp.supplier_code is null then '' else ' by '||nvl(sr.concept_name, x_mf.q_name) end as supplier_name
  from complete_pack cp
  left join concept br on br.concept_code=cp.bn_code and br.vocabulary_id=cp.brand_vocab
  left join x_bn on x_bn.r_code=cp.bn_code and cp.brand_vocab='RxNorm Extension' and x_bn.r_vocab is null
  left join concept sr on sr.concept_code=cp.supplier_code and sr.vocabulary_id=cp.supplier_vocab
  left join x_mf on x_mf.r_code=cp.supplier_code and cp.supplier_vocab='RxNorm Extension' and x_mf.r_vocab is null
),
-- Calculate total length of everything if space weren't the issue, and then calculate the factor that each concept_name needs to be shortened by
p as (
  select 
    pd.pack_concept_code,
    pd.brand_name||pd.bs_name||pd.supplier_name as concept_name,
    nvl(length(pd.bs_name), 0)+nvl(length(pd.brand_name), 0)+nvl(length(pd.supplier_name), 0) as len -- length of the Brand Name of the Pack plus extra characters making up the name minus the ' / ' at the last component
    from pd
),
l as (
  select pack_concept_code, 
    (245-all_a_len-p.len)/all_n_len as factor -- 255-10 for common pack text (curly brackets, spaces)
  from (
    select distinct
      pack_concept_code,
      sum(n_len) over (partition by pack_concept_code) as all_n_len, -- 7: slashes, parentheses and spaces, minus the trailing ' / '
      sum(a_len+5) over (partition by pack_concept_code) -3 as all_a_len -- 7: slashes, parentheses and spaces, minus the trailing ' / '
    from c
  ) 
  join p using(pack_concept_code)
),
-- Cut the individual components by the factor and add ...
c_p as (
  select 
    pack_concept_code,
    case when l.factor<1 then substr(c.content_name, 1, c.n_len*l.factor-3)||'...' else c.content_name end as concept_name
  from l join c using(pack_concept_code)
)
select 
  pack_concept_code,
  '{'||listagg(c_p.concept_name, ') / ') within group (order by c_p.concept_name) ||') } Pack'||p.concept_name as concept_name
from c_p -- components, possibly trimmed
join p using(pack_concept_code) -- common part
group by pack_concept_code, p.concept_name -- aggregate within concept_code
;
commit;

/****************************
* 7. Write RxNorm Extension *
****************************/

-- Temporary till stable xxxxxxxxxxxxxxxxxx
insert into pack_q_to_r
select pn.pack_concept_code, c.concept_id as clinical, null as branded, null as supplied, null as marketed, null as neither
from pack_name pn join concept c using (concept_name) where c.vocabulary_id like 'RxNorm%' and invalid_reason is null 
and not exists ( select 1 from pack_q_to_r pqr where pn.pack_concept_code=pqr.pack_concept_code
);

-- Cut here after fixing q_to_r

truncate table concept_stage;
truncate table concept_relationship_stage;
truncate table drug_strength_stage;

-- Write RxNorm Extension into concept_stage
-- Write Ingredients that have no equivalent
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select 
  null as concept_id,
  dcs.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  'Ingredient' as concept_class_id,
  'S' as standard_concept,
  x_ing.r_code, -- XXX code, rather than original from dcs
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
  nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  null as invalid_reason
from drug_concept_stage dcs 
join x_ing on q_code=concept_code and r_vocab is null -- according to convention r_code has a new XXX code, but vocab=null indicates missing map
where dcs.invalid_reason is null and dcs.standard_concept='S' and nvl(dcs.domain_id, 'Drug')='Drug'
;
commit;

-- Write Dose Forms that have no equivalent
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select 
  null as concept_id, 
  dcs.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  'Dose Form' as concept_class_id,
  null as standard_concept,
  x_df.r_code,
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
  nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  null as invalid_reason
from drug_concept_stage dcs 
join x_df on q_code=concept_code and r_vocab is null
where dcs.invalid_reason is null and nvl(dcs.domain_id, 'Drug')='Drug'
;
commit;

-- Write Brand Name that have no equivalent
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select 
  null as concept_id, 
  dcs.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  'Brand Name' as concept_class_id,
  null as standard_concept,
  x_bn.r_code,
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
  nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  null as invalid_reason
from drug_concept_stage dcs 
join x_bn on q_code=concept_code and r_vocab is null
where dcs.invalid_reason is null and nvl(dcs.domain_id, 'Drug')='Drug'
;
commit;

-- Write Supplier that have no equivalent
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select 
  null as concept_id, 
  dcs.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  'Supplier' as concept_class_id,
  null as standard_concept,
  x_mf.r_code,
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
  nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  null as invalid_reason
from drug_concept_stage dcs 
join x_mf on q_code=concept_code and r_vocab is null
where dcs.invalid_reason is null and nvl(dcs.domain_id, 'Drug')='Drug'
;
commit;

-- Write concepts from extension_*
-- This will miss all those added through extension_expand, but it shouldn't matter 
-- because they only exist because of a low-level q_to_r connection picking something different than precedence 1
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select distinct
  null as concept_id,
  en.concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  ea.concept_class_id,
  'S' as standard_concept, -- Standard Concept 
  concept_code,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from extension_attribute ea
join extension_name en using(concept_code)
left join q_to_r qr on qr.q_dcode=concept_code
where qr.q_dcode is null -- concepts that cannot be mapped and therefore are standard
;
commit;

-- write RxNorm-like relationships between concepts of all classes except Drug Forms and Clinical Drug Component based on matching components
drop table rl purge;
create table rl (
concept_class_1 varchar2(20),
relationship_id varchar2(20),
concept_class_2 varchar2(20)
);
insert into rl
select 'Brand Name', 'Brand name of', 'Branded Drug Box' from dual union
select 'Brand Name', 'Brand name of', 'Branded Drug Comp' from dual union
select 'Brand Name', 'Brand name of', 'Branded Drug Form' from dual union
select 'Brand Name', 'Brand name of', 'Branded Drug' from dual union
select 'Brand Name', 'Brand name of', 'Branded Pack' from dual union
select 'Brand Name', 'Brand name of', 'Branded Pack Box' from dual union
select 'Brand Name', 'Brand name of', 'Marketed Product' from dual union
select 'Brand Name', 'Brand name of', 'Quant Branded Box' from dual union
select 'Brand Name', 'Brand name of', 'Quant Branded Drug' from dual union
select 'Branded Drug Box', 'Has marketed form', 'Marketed Product' from dual union
select 'Branded Drug Box', 'Has quantified form', 'Quant Branded Box' from dual union
select 'Branded Drug Comp', 'Constitutes', 'Branded Drug' from dual union
select 'Branded Drug Form', 'RxNorm inverse is a', 'Branded Drug' from dual union
select 'Branded Drug', 'Available as box', 'Branded Drug Box' from dual union
select 'Branded Drug', 'Has marketed form', 'Marketed Product' from dual union
select 'Branded Drug', 'Has quantified form', 'Quant Branded Drug' from dual union
select 'Clinical Drug Box', 'Has marketed form', 'Marketed Product' from dual union
select 'Clinical Drug Box', 'Has quantified form', 'Quant Clinical Box' from dual union
select 'Clinical Drug Box', 'Has tradename', 'Branded Drug Box' from dual union
select 'Clinical Drug Comp', 'Constitutes', 'Clinical Drug' from dual union
select 'Clinical Drug Comp', 'Has tradename', 'Branded Drug Comp' from dual union
select 'Clinical Drug Form', 'Has tradename', 'Branded Drug Form' from dual union
select 'Clinical Drug Form', 'RxNorm inverse is a', 'Clinical Drug' from dual union
select 'Clinical Drug', 'Available as box', 'Clinical Drug Box' from dual union
select 'Clinical Drug', 'Has marketed form', 'Marketed Product' from dual union
select 'Clinical Drug', 'Has quantified form', 'Quant Clinical Drug' from dual union
select 'Clinical Drug', 'Has tradename', 'Branded Drug' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Branded Drug Box' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Branded Drug Form' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Branded Drug' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Branded Pack' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Clinical Drug Box' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Clinical Drug Form' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Clinical Drug' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Clinical Pack' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Marketed Product' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Quant Branded Box' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Quant Branded Drug' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Quant Clinical Box' from dual union
select 'Dose Form', 'RxNorm dose form of', 'Quant Clinical Drug' from dual union
select 'Ingredient', 'Has brand name', 'Brand Name' from dual union
select 'Ingredient', 'RxNorm q_ing of', 'Clinical Drug Comp' from dual union
select 'Ingredient', 'RxNorm q_ing of', 'Clinical Drug Form' from dual union
select 'Marketed Product', 'Has Supplier', 'Supplier' from dual union 
select 'Supplier', 'Supplier of', 'Marketed Product' from dual union
select 'Quant Branded Box', 'Has marketed form', 'Marketed Product' from dual union
select 'Quant Branded Drug', 'Available as box', 'Quant Branded Box' from dual union
select 'Quant Branded Drug', 'Has marketed form', 'Marketed Product' from dual union
select 'Quant Clinical Box', 'Has marketed form', 'Marketed Product' from dual union
select 'Quant Clinical Box', 'Has tradename', 'Quant Branded Box' from dual union
select 'Quant Clinical Drug', 'Available as box', 'Quant Clinical Box' from dual union
select 'Quant Clinical Drug', 'Has marketed form', 'Marketed Product' from dual union
select 'Quant Clinical Drug', 'Has tradename', 'Quant Branded Drug' from dual
;
commit;

-- Write inner-RxNorm Extension relationships, mimicking RxNorm
-- Everything but the Drug Forms, Clinical Drug Comp and Marketed Products
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
with ex as ( -- create a complete_q in extension notation
  select * from extension_attribute join extension_combo using(concept_code)
)
select distinct -- because several of them can map to the same existing RxE creating duplicates
  nvl(ar.r_code, an.concept_code) as concept_code_1, 
  nvl(ar.r_vocab, 'RxNorm Extension') as vocabulary_id_1,
  nvl(dr.r_code, de.concept_code) as concept_code_2,
  nvl(dr.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex de
join rl on rl.concept_class_2=de.concept_class_id 
  and rl.concept_class_1 not in ('Clinical Drug Form', 'Branded Drug Form', 'Clinical Drug Comp') -- these have no valid d_combo, or the d_combo has to be decomposed
join ex an
  on rl.concept_class_1=an.concept_class_id
    and de.d_combo=an.d_combo -- the q_ds have to match completely
    and de.i_combo=an.i_combo -- adding ingredient combinations, becauser of "empty" q_ds may create false relationships through only ds_combo
    and de.quant=case an.quant when 0 then de.quant else an.quant end 
    and de.df_code=case an.df_code when ' ' then de.df_code else an.df_code end 
    and de.bn_code=case an.bn_code when ' ' then de.bn_code else an.bn_code end
    and de.box_size=case an.box_size when 0 then de.box_size else an.box_size end
    and de.concept_code!=an.concept_code 
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) ar on ar.q_dcode=an.concept_code
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) dr on dr.q_dcode=de.concept_code
where de.concept_class_id not in ('Clinical Drug Comp', 'Clinical Drug Form', 'Clinical Drug', 'Branded Drug Form', 'Marketed Product') 
;
commit;

-- Marketed Products: Everything has to agree except Supplier
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
with ex as ( -- create a complete_q in extension notation
  select * from extension_attribute join extension_combo using(concept_code)
)
select distinct
  nvl(ar.r_code, an.concept_code) as concept_code_1, 
  nvl(ar.r_vocab, 'RxNorm Extension') as vocabulary_id_1,
  nvl(dr.r_code, de.concept_code) as concept_code_2,
  nvl(dr.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex de 
join rl on rl.concept_class_2=de.concept_class_id and rl.concept_class_1!='Marketed Product' -- need to exclude otherwise it's linking Marketed to Marketed
join ex an
  on rl.concept_class_1=an.concept_class_id
    and de.d_combo=an.d_combo -- the q_ds have to match completely
    and de.i_combo=an.i_combo -- adding ingredient combinations, becauser of "empty" q_ds may create false relationships through only ds_combo
    and de.quant=an.quant
    and de.df_code=an.df_code
    and de.bn_code=an.bn_code
    and de.box_size=an.box_size
    and de.concept_code!=an.concept_code 
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) ar on ar.q_dcode=an.concept_code
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) dr on dr.q_dcode=de.concept_code
and de.concept_class_id ='Marketed Product'
;
commit;

-- Drug Forms: No ds_combo
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
with ex as ( -- create a complete_q in extension notation
  select * from extension_attribute join extension_combo using(concept_code)
)
select distinct
  nvl(ar.r_code, an.concept_code) as concept_code_1, 
  nvl(ar.r_vocab, 'RxNorm Extension') as vocabulary_id_1,
  nvl(dr.r_code, de.concept_code) as concept_code_2,
  nvl(dr.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ex de 
join rl on rl.concept_class_2=de.concept_class_id 
  and rl.concept_class_1 in ('Clinical Drug Form', 'Branded Drug Form') -- these have i_combo to share with their descendants
join ex an
  on rl.concept_class_1=an.concept_class_id
    and de.i_combo=an.i_combo -- the q_ds have to match completely
    and de.df_code=case an.df_code when ' ' then de.df_code else an.df_code end 
    and de.bn_code=case an.bn_code when ' ' then de.bn_code else an.bn_code end
    and de.concept_code!=an.concept_code
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) ar on ar.q_dcode=an.concept_code
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) dr on dr.q_dcode=de.concept_code
;
commit;

-- Clinical Drug Comp - ds_combo is really only singleton q_ds and needs be decomposed
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
with ex as ( -- create a complete_q in extension notation
  select * from extension_attribute join extension_combo using(concept_code)
)
select distinct
  nvl(ar.r_code, an.concept_code) as concept_code_1, 
  nvl(ar.r_vocab, 'RxNorm Extension') as vocabulary_id_1,
  nvl(dr.r_code, de.concept_code) as concept_code_2,
  nvl(dr.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ( -- Create de that has ds_code instead of d_combo by splitting them up
  select /*+no_merge */ distinct 
    concept_code, concept_class_id,
    trim(regexp_substr(d_combo, '[^\-]+', 1, levels.column_value)) as ds_code
  from ex, table(cast(multiset(select level from dual connect by level <= length (regexp_replace(d_combo, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
  where concept_class_id in ('Clinical Drug', 'Branded Drug Comp') -- the only concept class it connects to
) de 
join rl on rl.concept_class_2=de.concept_class_id 
  and rl.concept_class_1 in ('Clinical Drug Comp') -- d_combo needs to be broken down
-- connect the combined to the singletons by splitting d_combo
join ex an
  on rl.concept_class_1=an.concept_class_id
    and de.ds_code=an.d_combo -- the q_ds have to match completely
    and de.concept_code!=an.concept_code 
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) ar on ar.q_dcode=an.concept_code
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) dr on dr.q_dcode=de.concept_code
;
commit;

-- Ingredient to Clinical Drug Comp
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  ingredient_concept_code as concept_code_1, 
  case ingredient_vocab when ' ' then 'RxNorm Extension' else ingredient_vocab end as vocabulary_id_1,
  nvl(r_code, concept_code) as concept_code_2,
  nvl(r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from extension_attribute join extension_ds on concept_code=drug_concept_code  -- create a complete_q in extension notation
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) on q_dcode=concept_code
join rl on concept_class_2=concept_class_id and concept_class_1 in ('Ingredient')
where concept_class_id='Clinical Drug Comp'
;
commit;

-- Ingredients to Clinical Drug Form 
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  an.concept_code as concept_code_1, 
  an.vocabulary_id as vocabulary_id_1,
  de.concept_code as concept_code_2,
  de.vocabulary_id as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ( -- create a complete_q in extension notation and limit codes to what's in extension_*
  select nvl(r_code, concept_code) as concept_code, nvl(r_vocab, 'RxNorm Extension') as vocabulary_id, i_combo, concept_class_id
  from extension_attribute join extension_combo using(concept_code)
  left join ( -- use existing if possible
    select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
  ) on q_dcode=concept_code
  where concept_class_id='Clinical Drug Form'
) de
join rl on rl.concept_class_2=de.concept_class_id and rl.concept_class_1 in ('Ingredient')
join ( -- de already contains the ingredient, but they are combos and not in Rx notation when necessary
  select distinct
    r_code as concept_code, nvl(r_vocab, 'RxNorm Extension') as vocabulary_id, i_combo
  from x_ing, extension_combo, table(cast(multiset(select level from dual connect by level <= length (regexp_replace(i_combo, '[^\-]+'))  + 1) as sys.OdciNumberList)) levels
  where x_ing.r_code=trim(regexp_substr(i_combo, '[^\-]+', 1, levels.column_value))
) an on an.i_combo=de.i_combo
;
commit;

-- All Dose Forms
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  df_code as concept_code_1,
  case dose_form_vocab when ' ' then 'RxNorm Extension' else dose_form_vocab end as vocabulary_id_1,
  nvl(r_code, concept_code) as concept_code_2,
  nvl(r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from extension_attribute join rl on concept_class_1='Dose Form' and concept_class_2=concept_class_id
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) on q_dcode=concept_code
-- join concept_stage using(concept_code) -- only those we are actually writing out
where extension_attribute.df_code!=' '
;
commit;

-- All Brand Name 
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  extension_attribute.bn_code as concept_code_1,
  case brand_vocab when ' ' then 'RxNorm Extension' else brand_vocab end as vocabulary_id_1,
  nvl(r_code, concept_code) as concept_code_2,
  nvl(r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from extension_attribute join rl on concept_class_1='Brand Name' and concept_class_2=concept_class_id
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) on q_dcode=concept_code
-- join concept_stage using(concept_code) -- only those we are actually writing out
where extension_attribute.bn_code!=' '
;
commit;

-- All Suppliers
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  extension_attribute.supplier_code as concept_code_1,
  case supplier_vocab when ' ' then 'RxNorm Extension' else supplier_vocab end as vocabulary_id_1,
  nvl(r_code, concept_code) as concept_code_2,
  nvl(r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from extension_attribute join rl on concept_class_1='Supplier' and concept_class_2=concept_class_id
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) on q_dcode=concept_code
-- join concept_stage using(concept_code) -- only those we are actually writing out
where extension_attribute.supplier_code!=' '
;
commit;

-- Write relationships between Brand Name and Ingredient
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct 
  i.r_code as concept_code_1,
  nvl(i.r_vocab, 'RxNorm Extension') as vocabulary_id_1,
  b.r_code as concept_code_2,
  nvl(b.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from ( -- get the cross-section between brands and ingredients
  select i_code, bn_code from q_ing join q_bn using (concept_code)
) im
join x_ing i on i.q_code=im.i_code -- translate
join x_bn b on b.q_code=im.bn_code -- translate 
join rl on concept_class_1='Ingredient' and concept_class_2='Brand Name'
;
commit;

-- Write Packs
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select distinct -- because records duplicate due to components
  null as concept_id, 
  concept_name,
  'Drug' as domain_id,
  'RxNorm Extension' as vocabulary_id,
  concept_class_id,
  'S' as standard_concept, -- all non-existing packs are Standard
  cp.pack_concept_code as concept_code,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason -- if they are 'U' they get mapped using Maps to to RxNorm/E anyway
from complete_pack cp join pack_name pn on pn.pack_concept_code=cp.pack_concept_code
left join pack_q_to_r pqr on cp.pack_concept_code=pqr.pack_concept_code -- exclude those that can be fully mapped
where pqr.pack_concept_code is null
;
commit;

-- Write links between Packs and their containing Drugs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct -- because drugs can be in a pack in several components
  cp.pack_concept_code as concept_code_1,
  'RxNorm Extension' as vocabulary_id_1,
  cp.drug_concept_code as concept_code_2,
  cp.drug_vocab as vocabulary_id_2,
  'Contains' as relationship_id, -- the relationship_id is not taken from rl, but expicitly defined
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from complete_pack cp 
left join pack_q_to_r pqr on cp.pack_concept_code=pqr.pack_concept_code -- exclude those that can be fully mapped
where pqr.pack_concept_code is null
;
commit;

-- Write Brand Names for Packs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  cp.bn_code as concept_code_1,
  nvl(cp.brand_vocab, 'RxNorm Extension') as vocabulary_id_1,
  cp.pack_concept_code as concept_code_2,
  'RxNorm Extension' as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from complete_pack cp join rl on rl.concept_class_1='Brand Name' and rl.concept_class_2=cp.concept_class_id
left join pack_q_to_r pqr on cp.pack_concept_code=pqr.pack_concept_code -- exclude those that can be fully mapped
where pqr.pack_concept_code is null
and bn_code!=' '
;
commit;

-- Write Suppliers for Packs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct
  cp.supplier_code as concept_code_1,
  nvl(cp.supplier_vocab, 'RxNorm Extension') as vocabulary_id_1,
  cp.pack_concept_code as concept_code_2,
  'RxNorm Extension' as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from complete_pack cp join rl on rl.concept_class_1='Supplier' and rl.concept_class_2=cp.concept_class_id
left join pack_q_to_r pqr on cp.pack_concept_code=pqr.pack_concept_code -- exclude those that can be fully mapped
where pqr.pack_concept_code is null
and supplier_code!=' '
;
commit;

-- Remove all relationships where either side is RxNorm
delete from concept_relationship_stage where vocabulary_id_1='RxNorm' and vocabulary_id_2='RxNorm';

/************************
* 8. Write source vocab *
************************/

-- Write source drugs as non-standard
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select distinct
  null as concept_id, 
  concept_name,
  domain_id,
  vocabulary_id,
  nvl(source_concept_class_id, concept_class_id) as concept_class_id,
  null as standard_concept, -- Source Concept, no matter whether active or not
  concept_code,
  nvl(valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
  nvl(valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  case invalid_reason when 'U' then 'D' else invalid_reason end as invalid_reason -- if they are 'U' they get mapped using Maps to to RxNorm/E anyway
from drug_concept_stage
where concept_class_id in ('Ingredient', 'Drug Product', 'Supplier', 'Dose Form', 'Brand Name') -- but no Unit
  and nvl(domain_id, 'Drug')='Drug'
;
commit;

-- Write source devices as standard (unless deprecated)
insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select distinct
  null as concept_id, 
  concept_name,
  domain_id,
  vocabulary_id,
  nvl(source_concept_class_id, concept_class_id) as concept_class_id,
  case when invalid_reason is null then null else 'S' end as standard_concept, -- Devices are not mapped
  concept_code,
  nvl(valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
  nvl(valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
  invalid_reason -- if they are 'U' they get mapped using Maps to to RxNorm/E anyway
from drug_concept_stage
where domain_id='Device'
;
commit;

-- Write maps for drugs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from existing_to_complete etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;
    
-- Remove duplications occurring in case ds_stage has entries that are fully 0
-- delete from concept_relationship_stage where rowid not in (select max(rowid) from concept_relationship_stage group by concept_code_1, concept_code_2, relationship_id);

-- Write maps for upgraded drugs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct -- xxxxxxxxxxxxxxxxxxxxx
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join existing_to_complete etc on etc.e_code=u.concept_code
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
where dcs.concept_code not in (select concept_code_1 from concept_relationship_stage where relationship_id='Maps to')
;
commit;

-- Write maps for ill-formed drugs (attribute combination not in RxNorm/RxNorm Extenion) in the order Ingredient, Drug_strength, Dose Form, Brand Name, Quantity, Box Size, Supplier. 
-- Drop q_mfurer
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_df on q_df.concept_code=i.concept_code 
  join q_quant on q_quant.concept_code=i.concept_code
  join q_bn on q_bn.concept_code=i.concept_code
  join q_bs on q_bs.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=df.df_code and c.denominator_value=quant.denominator_value and c.bn_code=bn.bn_code and c.box_size=bs.box_size and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- Drop box size
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_df on q_df.concept_code=i.concept_code 
  join q_quant on q_quant.concept_code=i.concept_code
  join q_bn on q_bn.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=df.df_code and c.denominator_value=quant.denominator_value and c.bn_code=bn.bn_code and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop Quantity, leaving Branded Drug
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_df on q_df.concept_code=i.concept_code 
  join q_bn on q_bn.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=df.df_code and c.denominator_value=0 and c.bn_code=bn.bn_code and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop brand name, leaving Clinical Drug 
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_df on q_df.concept_code=i.concept_code 
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=df.df_code and c.denominator_value=0 and c.bn_code=' ' and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop dose form, but keep brand name, leaving Branded Drug Comp
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_combo d on d.concept_code=i.concept_code
  join q_bn on q_bn.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=d.combo_code and c.df_code=' ' and c.denominator_value=0 and c.bn_code=bn.bn_code and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop dose form and brand name, leaving Clinical Drug Comp
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_ing i -- single ingredient, not combo
  join q_ds d on i.concept_code=d.concept_code -- single q_ds entry
  join complete_q c 
    on c.i_combo=i.i_code and c.d_combo=d.ds_code and c.df_code=' ' and c.denominator_value=0 and c.bn_code=' ' and c.box_size=0 and c.mf_code=' '
  join drug_concept_stage dcs on dcs.concept_code=i.concept_code
  join extension_name en on en.concept_code=c.concept_code
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop drug_strength, leaving Branded Drug Form
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_df on q_df.concept_code=i.concept_code 
  join q_bn on q_bn.concept_code=i.concept_code
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=' ' and c.df_code=df.df_code and c.denominator_value=0 and c.bn_code=bn.bn_code and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- drop brand name, leaving Clinical Drug Form
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  etc.e_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(rx.concept_code, etc.c_code) as concept_code_2,
  nvl(rx.vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select i.concept_code as e_code, c.concept_code as c_code
  from q_i_combo i
  join q_df on q_df.concept_code=i.concept_code 
  join complete_q c 
    on c.i_combo=i.combo_code and c.d_combo=' ' and c.df_code=df.df_code and c.denominator_value=0 and c.bn_code=' ' and c.box_size=0 and c.mf_code=' '
  where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
) etc
left join q_to_r qr on qr.q_dcode=etc.c_code
left join concept rx on rx.concept_id=qr.r_did
;
commit;

-- Map the remaining hanging products to Ingredients
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select
  i.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_ing.r_code as concept_code_2,
  nvl(x_ing.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from q_ing i
join x_ing on x_ing.q_code=i.i_code 
where i.concept_code not in (select concept_code_1 from concept_relationship_stage)
;
commit;

-- Write maps for Ingredients
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  x_ing.q_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_ing.r_code as concept_code_2,
  nvl(x_ing.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from x_ing
where x_ing.q_code not in (select concept_code_1 from internal_relationship_stage) -- expecting that an ingredient will only be in concept_code_1 if it is upgraded
;
commit;

-- Write maps for deprecated Ingredients
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct -- xxxxxxxxxxxxxxxxxx doesn't have to be 
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_ing.r_code as concept_code_2,
  nvl(x_ing.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join x_ing on x_ing.q_code=u.concept_code
;
commit;

-- Write maps for Dose Forms
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  x_df.q_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_df.r_code as concept_code_2,
  nvl(x_df.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from x_df
where x_df.q_code not in (select concept_code_1 from internal_relationship_stage) -- expecting that an ingredient will only be in concept_code_1 if it is upgraded
;
commit;

-- Write maps for deprecated Dose Forms
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_df.r_code as concept_code_2,
  nvl(x_df.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
-- usual validity
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join x_df on x_df.q_code=u.concept_code
;
commit;

-- Write maps for Brand Names
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  x_bn.q_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_bn.r_code as concept_code_2,
  nvl(x_bn.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from x_bn
where x_bn.q_code not in (select concept_code_1 from internal_relationship_stage) -- expecting that an ingredient will only be in concept_code_1 if it is upgraded
;
commit;

-- Write maps for deprecated Brand Names
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_bn.r_code as concept_code_2,
  nvl(x_bn.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
-- usual validity
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join x_bn on x_bn.q_code=u.concept_code
;
commit;

-- Write maps for Suppliers
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  x_mf.q_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_mf.r_code as concept_code_2,
  nvl(x_mf.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from x_mf
where x_mf.q_code not in (select concept_code_1 from internal_relationship_stage) -- expecting that an ingredient will only be in concept_code_1 if it is upgraded
;
commit;

-- Write maps for deprecated Suppliers
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  dcs.concept_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  x_mf.r_code as concept_code_2,
  nvl(x_mf.r_vocab, 'RxNorm Extension') as vocabulary_id_2,
  'Source - RxNorm eq' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
-- usual validity
from drug_concept_stage dcs
join internal_relationship_stage irs on irs.concept_code_1=dcs.concept_code
join drug_concept_stage u on u.concept_code=irs.concept_code_2 and u.concept_class_id=dcs.concept_class_id
join x_mf on x_mf.q_code=u.concept_code
;
commit;

-- Write relationship to drug classes like ATC
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct 
  nvl(r_code, etc.c_code) as concept_code_1,
  nvl(r_vocab, 'RxNorm Extension') as vocabulary_id_1,
  dc.concept_code as concept_code_2,
  dc.vocabulary_id as vocabulary_id_2,
  'Drug has drug class' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from existing_to_complete etc
join r_to_c r on r.concept_code_1=etc.e_code 
join concept dc on dc.concept_id=r.concept_id_2
left join ( -- use existing if possible
  select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab from q_to_r qr join concept r on r.concept_id=qr.r_did
) on q_dcode=etc.c_code
where dc.vocabulary_id in (select distinct vocabulary_id from concept where domain_id='Drug' and standard_concept='C')
;
commit;

-- Write mappings for Packs
insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct -- because each pack has many drugs
  source_code as concept_code_1,
  (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
  nvl(concept_code, pack_concept_code) as concept_code_2,
  nvl(vocabulary_id, 'RxNorm Extension') as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from pack_seq
left join (
  select pack_concept_code, concept_code, vocabulary_id from pack_q_to_r join concept on concept_id=coalesce(marketed, supplied, branded, clinical, neither)
) using (pack_concept_code);

commit;

-- Build drug_strength_stage
insert into drug_strength_stage
select 
  drug_concept_code,
  'RxNorm Extension' as vocabulary_id_1,
  ingredient_concept_code,
  case ingredient_vocab when ' ' then 'RxNorm Extension' else ingredient_vocab end as vocabulary_id_2,
  amount_value, amount_unit_concept_id, numerator_value, numerator_unit_concept_id, denominator_value, denominator_unit_concept_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
  null as invalid_reason
from (
  select drug_concept_code, ingredient_concept_code, ingredient_vocab, 
  sum(amount_value) as amount_value, amount_unit_concept_id, 
  sum(numerator_value) as numerator_value, numerator_unit_concept_id, 
  denominator_value, denominator_unit_concept_id
  from extension_ds
  join concept_stage cs on cs.concept_code=drug_concept_code
  group by drug_concept_code, ingredient_concept_code, ingredient_vocab, amount_unit_concept_id, numerator_unit_concept_id, denominator_value, denominator_unit_concept_id
)
;
commit;

-- Build pack_content
drop table pack_content_stage;
create table pack_content_stage nologging as
select distinct 
  cp.pack_concept_code,
  'RxNorm Extension' as pack_vocabulary_id,
  cp.drug_concept_code,
  cp.drug_vocab as drug_vocabulary_id,
  cp.amount, cp.box_size
from complete_pack cp
left join pack_q_to_r pqr on pqr.pack_concept_code=cp.pack_concept_code
where pqr.pack_concept_code is null -- only those that have no translation.
;
commit;

/*************
* 9. Tidy up *
*************/

-- Replace concept_codes XXX123 with OMOP123
-- Create replacement map
drop table xxx_replace purge;
create table xxx_replace (
  xxx_code varchar2(50),
  omop_code varchar2(50)
);

drop sequence omop_seq; 

declare
 ex number;
begin
select max(iex)+1 into ex from (  
    select cast(substr(concept_code, 5) as integer) as iex from drug_concept_stage where concept_code like 'OMOP%' and concept_code not like '% %' -- Last valid value of the OMOP123-type codes
  union
    select cast(substr(concept_code, 5) as integer) as iex from concept where concept_code like 'OMOP%' and concept_code not like '% %'
);
  begin
    execute immediate 'create sequence omop_seq increment by 1 start with ' || ex || ' nocycle cache 20 noorder';
    exception
      when others then null;
  end;
end;
/
-- generate OMOP codes for new concepts
insert into xxx_replace
select concept_code as xxx_code, 'OMOP'||omop_seq.nextval as omop_code
from concept_stage 
where concept_code like 'XXX%' 
;
commit;

-- fast way to update codes require temporary tables. 
-- replace concept_stage
create table cs_rowid_update nologging as
select cs.rowid as irowid, xr.omop_code as concept_code from xxx_replace xr JOIN concept_stage cs ON cs.concept_code=xr.xxx_code;

merge into concept_stage cs
using (select * from cs_rowid_update) d on (d.irowid=cs.rowid)
when matched then update
  set cs.concept_code=d.concept_code;

drop table cs_rowid_update purge;

-- replace concept_relationship_stage
create table crs_rowid_update nologging as
select distinct crs.rowid as irowid, nvl(xr1.omop_code, crs.concept_code_1) as concept_code_1, nvl(xr2.omop_code, crs.concept_code_2) as concept_code_2 from concept_relationship_stage crs
left join xxx_replace xr1 ON xr1.xxx_code=crs.concept_code_1 
left join xxx_replace xr2 ON xr2.xxx_code=crs.concept_code_2
where xr1.omop_code is not null or xr2.omop_code is not null;

merge into concept_relationship_stage crs
using (select * from crs_rowid_update) d on (d.irowid=crs.rowid)
when matched then update
  set crs.concept_code_1=d.concept_code_1, crs.concept_code_2=d.concept_code_2;

drop table crs_rowid_update purge;

-- replace drugs in drug_strength
create table dss_rowid_update nologging as
select dss.rowid as irowid, xr.omop_code as drug_concept_code from xxx_replace xr JOIN drug_strength_stage dss ON dss.drug_concept_code=xr.xxx_code;

merge into drug_strength_stage dss
using (select * from dss_rowid_update) d on (d.irowid=dss.rowid)
when matched then update
  set dss.drug_concept_code=d.drug_concept_code;

drop table dss_rowid_update purge;

-- replace ingredients in drug_strength
create table dss_rowid_update nologging as
select dss.rowid as irowid, xr.omop_code as ingredient_concept_code from xxx_replace xr JOIN drug_strength_stage dss ON dss.ingredient_concept_code=xr.xxx_code;

merge into drug_strength_stage dss
using (select * from dss_rowid_update) d on (d.irowid=dss.rowid)
when matched then update
  set dss.ingredient_concept_code=d.ingredient_concept_code;

drop table dss_rowid_update purge;

-- replace packs in pack_content
create table pcs_rowid_update nologging as
select pcs.rowid as irowid, xr.omop_code as pack_concept_code from xxx_replace xr join pack_content_stage pcs on pcs.pack_concept_code=xr.xxx_code;

merge into pack_content_stage pcs
using (select * from pcs_rowid_update) d on (d.irowid=pcs.rowid)
when matched then update
  set pcs.pack_concept_code=d.pack_concept_code;

drop table pcs_rowid_update purge;

-- replace drugs in pack_content
create table pcs_rowid_update nologging as
select pcs.rowid as irowid, xr.omop_code as drug_concept_code from xxx_replace xr join pack_content_stage pcs on pcs.drug_concept_code=xr.xxx_code;

merge into pack_content_stage pcs
using (select * from pcs_rowid_update) d on (d.irowid=pcs.rowid)
when matched then update
  set pcs.drug_concept_code=d.drug_concept_code;

drop table pcs_rowid_update purge;

commit;

--get duplicates for some reason 
delete from concept_relationship_stage a where exists (select 1 from  (
  select concept_code_1,concept_code_2,relationship_id, max (rowid) as rid from concept_relationship_stage group by concept_code_1,concept_code_2,relationship_id having count ( 1) >1 ) x 
  where  a.concept_code_1= x.concept_code_1 and a.concept_code_2= x.concept_code_2 and a.relationship_id =x.relationship_id and x.rid = a.rowid)
;  
--6 Working with replacement mappings;
BEGIN
   DEVV5.VOCABULARY_PACK.CheckReplacementMappings;
END;
/
COMMIT;

--7 Deprecate 'Maps to' mappings to deprecated and upgraded concepts
BEGIN
   DEVV5.VOCABULARY_PACK.DeprecateWrongMAPSTO;
END;
/
COMMIT;

--8 Add mapping from deprecated to fresh concepts
BEGIN
   DEVV5.VOCABULARY_PACK.AddFreshMAPSTO;
END;
/
COMMIT;

--9 Delete ambiguous 'Maps to' mappings
BEGIN
   DEVV5.VOCABULARY_PACK.DeleteAmbiguousMAPSTO;
END;
/
COMMIT;
