/**************************************************************************
* Copyright 2016 Observational Health Data Sciences and Informatics (OHDSI)
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
* Authors: Christian Reich
* Date: 2016
**************************************************************************/

-- To do: Drug Classes, Ingredient to Brand Name (has brand name), product to Brand Name (has tradename), possible excipient, change in drug_strength table

/******************************************************************************
* This script creates a new drug vocabulary in the OMOP Standard Vocabularies *
* The new drug vocabulary must be provided in the format described in         *
* http://www.ohdsi.org/web/wiki/doku.php?id=documentation:international_drugs *
* The processing is also described there. The following tables are required:  *
* drug_concept_stage, internal_relationship_stage, relationship_to_concept,   *
* drug_strength_stage. Records that have no concept_code in the source should *
* receive autogenerated ones in the format 'OMOP' plus a running number.      *
* The running number should start were the last OMOPXXX number ended. The     *
* name of the sequence is new_vocab. The existing drug vocabularies should be *
* provided in concept, concept_relationship, concept_ancestor and             *
* drug_strength.                                                              *
*******************************************************************************/

/** IMPORTANT **/
/* Add the latest_udpate and vesion information to the VOCABULARY table **/

-- Create Sequences for new concepts
-- Create temporary for uniqe strength recordsdrop sequence ds_seq;
drop sequence ds_seq;
create sequence ds_seq increment by 1 start with 1 nocycle cache 20 noorder;

-- Create sequence for new OMOP-created standard concepts
-- drop sequence new_vocab;
drop sequence new_vocab;

/*
declare
 ex number;
begin
  select max(cast(substr(concept_code, 5) as integer))+1 into ex from devv5.concept where concept_code like 'OMOP%' and concept_code not like '% %'; -- Last valid value of the OMOP123-type codes
  begin
    execute immediate 'create sequence new_vocab increment by 1 start with ' || ex || ' nocycle cache 20 noorder';
    exception
      when others then null;
  end;
end;
*/
commit;

-- 1. Prepare drug components for new vocabularies: Create unique list and for each drug enumerate. This allows to create a single row for each drug.

-- Create distinct version of drug_strength (general version)
-- Replace nulls with 0 and ' '
drop table unique_ds purge;
create table unique_ds as
select ds_seq.nextval as ds_code, ds.* from (
  select distinct ingredient_concept_code, 
    nvl(amount_value, 0) as amount_value, nvl(amount_unit, ' ') as amount_unit, 
    case 
      when numerator_unit='%' then nvl(numerator_value, 0)
      when nvl(numerator_value, 0)=0 then 0 
-- round to 3 significant number of digits
      else round(nvl(numerator_value, 0)/nvl(denominator_value, 1), 3-floor(log(10, nvl(numerator_value, 0)/nvl(denominator_value, 1)))-1)
    end as numerator_value, 
    nvl(numerator_unit, ' ') as numerator_unit, 
    nvl(denominator_unit, ' ') as denominator_unit
  from drug_strength_stage
where coalesce(amount_unit, numerator_unit, denominator_unit) is not null -- needs to have at least one value and unit
) ds
;

-- Create table with all drug concept codes linked to the above unique components 
drop table ds purge;
create table ds as
select dss.drug_concept_code as concept_code, uds.ds_code
from drug_strength_stage dss
join unique_ds uds on uds.ingredient_concept_code=dss.ingredient_concept_code
  and uds.amount_value=nvl(dss.amount_value, 0) and uds.amount_unit=nvl(dss.amount_unit, ' ')
  and uds.numerator_value=
    case 
      when dss.numerator_unit='%' then nvl(dss.numerator_value, 0) 
      when nvl(dss.numerator_value, 0)=0 then 0 
-- compare to rounded to 3 significant number of digits
      else round(nvl(dss.numerator_value, 0)/nvl(dss.denominator_value, 1), 3-floor(log(10, nvl(dss.numerator_value, 0)/nvl(dss.denominator_value, 1)))-1)
    end 
  and uds.numerator_unit=nvl(dss.numerator_unit, ' ')
  and uds.denominator_unit=nvl(dss.denominator_unit, ' ')
;

-- Create table with the combination of components for each drug concept delimited by '-'
drop table ds_combo purge;
create table ds_combo as
select distinct concept_code, listagg(ds_code, '-') within group (order by ds_code) as combo_code
from ds
group by concept_code
;

-- Create table with all drug concept codes linked to the codes of the ingredients (rather than full dose components)
drop table ing purge;
create table ing as
select c.concept_code, i.concept_code as ing_code
from drug_concept_stage c
join internal_relationship_stage r on r.concept_code_1=c.concept_code
join drug_concept_stage i on i.concept_code=r.concept_code_2 and i.concept_class_id='Ingredient'
where (c.concept_class_id like '%Clinical%' or c.concept_class_id like '%Branded%') and c.domain_id='Drug';

-- Create table with the combination of ingredients for each drug concept delimited by '-'
drop table ing_combo purge;
create table ing_combo as
select distinct concept_code, listagg(ing_code, '-') within group (order by ing_code) as combo_code
from ing
group by concept_code
;

-- Create table to convert from ingredients to components
drop table ing_to_ds purge;
create table ing_to_ds as
select distinct i.combo_code as ing_combo_code, d.combo_code as ds_combo_code from ing_combo i join ds_combo d on d.concept_code=i.concept_code;

-- Create table with Quantity Factor information for each drug (if exists)
drop table quant purge;
create table quant as
select distinct drug_concept_code as concept_code, denominator_value
from drug_strength_stage
where denominator_value is not null and denominator_value!=0
;

-- Create table with Brand Name information for each drug (if exists)
drop table bn purge;
create table bn as
select distinct ir.concept_code_1 as concept_code, b.concept_code as brand_code -- distinct only because source contains duplicated maps
from internal_relationship_stage ir
join drug_concept_stage b on b.concept_code=ir.concept_code_2 and b.concept_class_id='Brand Name' and b.domain_id='Drug' -- Brand Name of a drug
;

-- Create table with Dose Form information for each drug (if exists)
drop table df purge;
create table df as
select distinct ir.concept_code_1 as concept_code, f.concept_code as dose_form_code -- distinct only because source contains duplicated maps
from internal_relationship_stage ir
join drug_concept_stage f on f.concept_code=ir.concept_code_2 and f.concept_class_id='Dose Form' and f.domain_id='Drug' -- Dose Form of a drug
;

-- Create table with Box Size information for each drug (if exists)
drop table bs purge;
create table bs as
select distinct drug_concept_code as concept_code, box_size 
from drug_strength_stage where box_size is not null;


-- 2. Create the list of all all existing product. 

-- Duplication rule 1: More than one definition per concept_code is illegal
-- Duplication rule 2: More than one concept_code per definition needs deprecation of the duplicates

-- Collect all input drugs
drop table existing_concept_stage purge;
create table existing_concept_stage as
-- Quant Branded Box
  select distinct 
    i.concept_code, quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, bs.box_size,
    'Quant Branded Box' as concept_class_id
  from ing_combo i
  join ds_combo d on d.concept_code=i.concept_code
  join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
  join bs on bs.concept_code=i.concept_code
union
-- Quant Clinical Box
  select distinct 
    i.concept_code, quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, bs.box_size,
    'Quant Clinical Box' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  left join bn on bn.concept_code=i.concept_code
  join bs on bs.concept_code=i.concept_code 
  where bn.concept_code is null
union
-- Branded Drug Box
  select distinct 
    i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, bs.box_size,
    'Branded Drug Box' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  left join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
  join bs on bs.concept_code=i.concept_code 
  where quant.concept_code is null 
union
-- Clinical Drug Box
  select distinct 
    i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, bs.box_size,
    'Clinical Drug Box' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  left join quant on quant.concept_code=d.concept_code
  join df on df.concept_code=d.concept_code
  left join bn on bn.concept_code=d.concept_code
  join bs on bs.concept_code=d.concept_code 
  where quant.concept_code is null and bn.concept_code is null 
union
-- Quant Branded Drug
  select distinct 
    i.concept_code, quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size,
    'Quant Branded Drug' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
  left join bs on bs.concept_code=i.concept_code 
  where bs.concept_code is null 
union
-- Quant Clinical Drug
  select distinct 
    i.concept_code, quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size,
    'Quant Clinical Drug' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  left join bn on bn.concept_code=i.concept_code
  left join bs on bs.concept_code=i.concept_code 
  where bn.concept_code is null and bs.concept_code is null 
union
-- Branded Drug
  select distinct 
    i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size,
    'Branded Drug' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  left join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
  left join bs on bs.concept_code=i.concept_code 
  where quant.concept_code is null and bs.concept_code is null 
union
-- Clinical Drug
  select distinct 
    i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size,
    'Clinical Drug' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  left join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  left join bn on bn.concept_code=i.concept_code
  left join bs on bs.concept_code=i.concept_code 
  where quant.concept_code is null and bn.concept_code is null and bs.concept_code is null
union
-- Branded Drug Form
  select distinct 
    i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, ' ' as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size,
    'Branded Drug Form' as concept_class_id
  from ing_combo i 
  left join ds_combo d on d.concept_code=i.concept_code
  left join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
  left join bs on bs.concept_code=i.concept_code 
  where quant.concept_code is null and d.concept_code is null and bs.concept_code is null
union
-- Clinical Drug Form
  select distinct 
    i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, ' ' as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size,
    'Clinical Drug Form' as concept_class_id
  from ing_combo i 
  left join ds_combo d on d.concept_code=i.concept_code
  left join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  left join bn on bn.concept_code=i.concept_code
  left join bs on bs.concept_code=i.concept_code 
  where quant.concept_code is null and d.concept_code is null and bn.concept_code is null and bs.concept_code is null
union
-- Branded Drug Component
  select distinct 
    i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, ' ' as dose_form_code, bn.brand_code, 0 as box_size,
    'Branded Drug Comp' as concept_class_id
  from ing_combo i
  join ds_combo d on d.concept_code=i.concept_code
  left join quant on quant.concept_code=i.concept_code
  left join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
  left join bs on bs.concept_code=i.concept_code 
  where quant.concept_code is null and df.concept_code is null and bs.concept_code is null
union
-- Clinical Drug Component 
  select distinct 
    i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size,
    'Clinical Drug Comp' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  left join quant on quant.concept_code=i.concept_code
  left join df on df.concept_code=i.concept_code
  left join bn on bn.concept_code=i.concept_code
  left join bs on bs.concept_code=i.concept_code 
  where quant.concept_code is null and df.concept_code is null and bn.concept_code is null and bs.concept_code is null
;

-- 3. Write all concept classes, whether existing or not from all possible combinations

drop table complete_concept_stage purge;
create table complete_concept_stage as
select distinct nvl(first_value(e.concept_code) over (partition by e.denominator_value, e.i_combo_code, e.d_combo_code, e.dose_form_code, e.brand_code, e.box_size order by concept_code desc), 0) as concept_code,
  c.*
from (
-- Quant Branded Box
  select distinct 
    quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, bs.box_size,
    'Quant Branded Box' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
  join bs on bs.concept_code=i.concept_code 
union
-- Quant Clinical Box
  select distinct 
    quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, bs.box_size,
    'Quant Clinical Box' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bs on bs.concept_code=i.concept_code 
union
-- Branded Drug Box
  select distinct 
    0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, bs.box_size,
    'Branded Drug Box' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
  join bs on bs.concept_code=i.concept_code 
union
-- Clinical Drug Box
  select distinct 
    0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, bs.box_size,
    'Clinical Drug Box' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join df on df.concept_code=d.concept_code
  join bs on bs.concept_code=d.concept_code 
union
-- Quant Branded Drug
  select distinct 
    quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size,
    'Quant Branded Drug' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
union
-- Quant Clinical Drug
  select distinct 
    quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size,
    'Quant Clinical Drug' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join quant on quant.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
union
-- Branded Drug
  select distinct 
    0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size,
    'Branded Drug' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
union
-- Clinical Drug
  select distinct 
    0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size,
    'Clinical Drug' as concept_class_id
  from ing_combo i 
  join ds_combo d on d.concept_code=i.concept_code
  join df on df.concept_code=i.concept_code
union
-- Branded Drug Form
  select distinct 
    0 as denominator_value, i.combo_code as i_combo_code, ' ' as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size,
    'Branded Drug Form' as concept_class_id
  from ing_combo i 
  join df on df.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
union
-- Clinical Drug Form
  select distinct 
    0 as denominator_value, i.combo_code as i_combo_code, ' ' as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size,
    'Clinical Drug Form' as concept_class_id
  from ing_combo i 
  join df on df.concept_code=i.concept_code
union
-- Branded Drug Component
  select distinct 
    0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, ' ' as dose_form_code, bn.brand_code, 0 as box_size,
    'Branded Drug Comp' as concept_class_id
  from ing_combo i
  join ds_combo d on d.concept_code=i.concept_code
  join bn on bn.concept_code=i.concept_code
union
-- Clinical Drug Component - they are unique per ingredients
  select distinct 
    0 as denominator_value, i.ing_code as i_combo_code, cast(d.ds_code as varchar(20)) as d_combo_code, ' ' as dose_form_code, ' ' as brand_code, 0 as box_size,
    'Clinical Drug Comp' as concept_class_id
  from ing i 
  join unique_ds d on i.ing_code=d.ingredient_concept_code 
) c
left join existing_concept_stage e on c.denominator_value=e.denominator_value and c.i_combo_code=e.i_combo_code and c.d_combo_code=e.d_combo_code 
  and c.dose_form_code=e.dose_form_code and c.brand_code=e.brand_code and c.box_size=e.box_size
;

-- Replace concept_code=0 with OMOP123 style concept codes. Use active sequence new_vocab
update complete_concept_stage ccs 
  set concept_code='OMOP'||new_vocab.nextval -- make sure new_vocab is defined.
where ccs.concept_code='0';

-- 4. Auto-generate all names unless a name is provided

-- create table with all names, later to be joined with complete_concept_stage
drop table complete_name;
create table complete_name (
  concept_code varchar2(50),
  concept_name varchar2(255)
);  

-- create names for everything but 'Clinical Drug Form', 'Branded Drug Form' (no drug_strength) and 'Clinical Drug Comp' (single ingredient)
insert into complete_name
with spelled_out as (
  select 
    c.concept_code,
    case when c.denominator_value=0 then '' else c.denominator_value||' '||d.denominator_unit||' ' end as quant,
    comp.comp_name,
    sum(comp.comp_len) over (partition by c.concept_code order by comp.comp_name rows between unbounded preceding and current row) as agg_len,
    case when df.concept_name is null then '' else ' '||df.concept_name end as df_name,
    case when bn.concept_name is null then '' else ' ['||bn.concept_name||']' end as bn_name,
    case when c.box_size=0 then '' else ' Box of '||c.box_size end as box
  from complete_concept_stage c
  -- get component names and lengths
  join (
    select combo_code, comp_name, length(comp_name)+3 as comp_len -- length plus 3 characters for ' / '
    from (
      select distinct dsc.combo_code, 
      i.concept_name||
        case 
          when u.amount_value=0 and u.numerator_unit='%' then ' '||u.numerator_value||'%' 
          when u.amount_value=0 and u.numerator_value!=0 then ' '||u.numerator_value||' '||u.numerator_unit||'/'||u.denominator_unit 
          when u.amount_value!=0 then ' '||u.amount_value||' '||u.amount_unit 
          else ''
        end as comp_name
      from ds_combo dsc join ds on ds.concept_code=dsc.concept_code join unique_ds u on u.ds_code=ds.ds_code
      join drug_concept_stage i on i.concept_code=u.ingredient_concept_code
    )
  ) comp on comp.combo_code=c.d_combo_code
  -- get denominator_unit from unique_ds
  left join (
    select distinct dsc.combo_code, u.denominator_unit
    from ds_combo dsc join ds on ds.concept_code=dsc.concept_code join unique_ds u on u.ds_code=ds.ds_code
  ) d on c.d_combo_code=d.combo_code
  -- get dose form
  left join drug_concept_stage df on df.concept_code=c.dose_form_code
  -- get brand name
  left join drug_concept_stage bn on bn.concept_code=c.brand_code
  where c.concept_class_id not in ('Clinical Drug Form', 'Branded Drug Form', 'Clinical Drug Comp')
)
select 
  concept_code,
-- count the cumulative length of the components. The tildas are to make sure the three dots are put at the end of the list
  replace(quant||listagg(comp_name, ' / ') within group (order by comp_name)||df_name||bn_name||box, '~~~', '...') as concept_name
from (
-- keep only components where concatenation will leave enough space for the quant, dose form, brand name and box size
  select * from spelled_out s
  where s.agg_len<=255-(nvl(length(s.quant), 0)+nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+nvl(length(s.box), 0)+3)
-- Add three dots if ingredients are to be cut
union
  select 
    concept_code,
    quant,
    '~~~' as comp_name, -- last ASCII character to make sure they get sorted towards the end.
    1 as agg_len,
    df_name,
    bn_name,
    box
  from spelled_out s
  where s.agg_len>255-(nvl(length(s.quant), 0)+nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+nvl(length(s.box), 0)+6)
  group by quant, concept_code, df_name, bn_name, box 
)
group by quant, concept_code, df_name, bn_name, box 
;

-- Add names for Clin Drug Comps (don't have combo ingredients)
insert into complete_name
select 
  c.concept_code,
  comp.comp_name
from complete_concept_stage c
-- get component name, length not needed
join (
  select combo_code, comp_name -- don't need length because only one ingredient in Clinial Drug Comps
  from (
    select distinct ds.ds_code as combo_code, 
    i.concept_name||
      case 
        when u.amount_value=0 and u.numerator_unit='%' then ' '||u.numerator_value||'%' 
        when u.amount_value=0 and u.numerator_value!=0 then ' '||u.numerator_value||' '||u.numerator_unit||'/'||u.denominator_unit 
        when u.amount_value!=0 then ' '||u.amount_value||' '||u.amount_unit 
        else ''
      end as comp_name
    from ds_combo dsc join ds on ds.concept_code=dsc.concept_code join unique_ds u on u.ds_code=ds.ds_code
    join drug_concept_stage i on i.concept_code=u.ingredient_concept_code
  )
) comp on comp.combo_code=c.d_combo_code
where c.concept_class_id = 'Clinical Drug Comp'
;

-- Drug Forms - which have no strength information
insert into complete_name
with spelled_out as (
  select 
    c.concept_code,
    comp.ing_name,
-- count the cumulative length of the ingredients
    sum(comp.comp_len) over (partition by c.concept_code order by comp.ing_name rows between unbounded preceding and current row) as agg_len,
    ' '||df.concept_name as df_name,
    case when bn.concept_name is null then '' else ' ['||bn.concept_name||']' end as bn_name
  from complete_concept_stage c
  -- get ingredient names and lengths
  join (
    select combo_code, ing_name, length(ing_name)+3 as comp_len -- length plus 3 characters for ' / '
    from (
      select distinct ic.combo_code, 
      i.concept_name as ing_name
      from ing_combo ic join ing on ic.concept_code=ing.concept_code 
      join drug_concept_stage i on i.concept_code=ing.ing_code
    )
  ) comp on comp.combo_code=c.i_combo_code
  -- get dose form
  left join drug_concept_stage df on df.concept_code=c.dose_form_code
  -- get brand name
  left join drug_concept_stage bn on bn.concept_code=c.brand_code
  where c.concept_class_id in ('Clinical Drug Form', 'Branded Drug Form')
)
select 
  concept_code,
  replace(listagg(ing_name, ' / ') within group (order by ing_name)||df_name||bn_name, '~~~', '...') as concept_name
from (
-- keep only components where concatenation will leave enough space for the quant, dose form, brand name and box size
  select * from spelled_out s
  where s.agg_len<=255-(nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+3)
-- Add three dots if ingredients are to be cut
union
  select 
    concept_code,
    '~~~' as ing_name, -- last ASCII character
    1 as agg_len,
    df_name,
    bn_name
  from spelled_out s
  where s.agg_len>255-(nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+6)
  group by concept_code, df_name, bn_name
)
group by concept_code, df_name, bn_name
;

commit;

-- Add Packs
insert into complete_concept_stage
select 
  concept_code,
  0 as denominator_value,
  ' ' as i_combo_code,
  ' ' as d_combo_code,
  ' ' as dose_form_code,
  ' ' as brand_code,
  0 as box_size,
  concept_class_id
from drug_concept_stage
where concept_class_id like '%Pack';


insert into complete_name
-- Get the component parts
with c as (
  select 
    pc.pack_concept_code as concept_code,
    case when pc.amount is null then '' else pc.amount||' ' end||'('||cn.concept_name as content_name,
    case when pc.amount is null then 0 else length(pc.amount)+1 end as a_len, -- length of the amount
    length(concept_name) as n_len -- length of the concept_name
  from pack_content pc
  join existing_concept_stage e on e.concept_code=pc.component_concept_code
  join complete_concept_stage c on c.denominator_value=e.denominator_value and c.i_combo_code=e.i_combo_code and c.d_combo_code=e.d_combo_code 
    and c.dose_form_code=e.dose_form_code and c.brand_code=e.brand_code and c.box_size=e.box_size
  join complete_name cn on cn.concept_code=c.concept_code
),
-- Get the common part
p as (
  select 
    concept_code, 
    concept_name, 
    length(concept_name) as len -- length of the Brand Name of the Pack plus extra characters making up the name minus the ' / ' at the last component
  from drug_concept_stage where concept_class_id like '%Pack%'
),
-- Calculate total length of everything if space weren't the issue, and then calculate the factor that each concept_name needs to be shortened by
l as (
  select concept_code, 
    (245-all_a_len-p.len)/all_n_len as factor -- 255-10 for common pack text (curly brackets, spaces)
  from (
    select distinct
      concept_code,
      sum(n_len) over (partition by concept_code) as all_n_len, -- 7: slashes, parentheses and spaces, minus the trailing ' / '
      sum(a_len+5) over (partition by concept_code) -3 as all_a_len -- 7: slashes, parentheses and spaces, minus the trailing ' / '
    from c
  ) 
  join p using(concept_code)
),
-- Cut the individual components by the factor and add ...
c_p as (
  select 
    concept_code,
    case when l.factor<1 then substr(c.content_name, 1, c.n_len*l.factor-3)||'...' else c.content_name end as concept_name
  from l join c using(concept_code)
-- where concept_code='2254581'
)
select 
  concept_code,
  '{'||listagg(c_p.concept_name, ') / ') within group (order by c_p.concept_name) ||') } Pack ['||p.concept_name||']' as concept_name
from c_p -- components, possibly trimmed
join p using(concept_code) -- common part
group by concept_code, p.concept_name -- aggregate within concept_code
;

-- 4. Compare new drug vocabulary q to existing one r

-- Create lookup tables for existing vocab r (RxNorm and new ones)
-- Create table containing ingredients for each drug
drop table r_drug_ing purge;
create table r_drug_ing as
  select de.concept_id as drug_id, an.concept_id as ing_id, de.concept_class_id
  from devv5.concept_ancestor a 
  join devv5.concept an on a.ancestor_concept_id=an.concept_id and an.concept_class_id='Ingredient' and an.vocabulary_id='RxNorm'
  join devv5.concept de on de.concept_id=a.descendant_concept_id and de.vocabulary_id='RxNorm'
;
-- Remove unparsable Albumin products that have no drug_strength entry: Albumin Human, USP 1 NS
delete from r_drug_ing where drug_id in (19094500, 19080557);

-- Count number of ingredients for each drug
drop table r_ing_count purge;
create table r_ing_count as
  select drug_id as did, count(*) as cnt from r_drug_ing group by drug_id
;

-- Create lookup table for query vocab q (new vocab)
drop table q_drug_ing purge;
create table q_drug_ing as
select distinct i.concept_code as drug_code, nvl(c.concept_id, 0) as ing_id, i.ing_code, i.concept_class_id -- if ingredient is not mapped use 0 to get the right count
from (
  select distinct css.concept_code, i.ing_code, css.concept_class_id from complete_concept_stage css
  join ing_combo ic on ic.combo_code=css.i_combo_code
  join ing i on i.concept_code=ic.concept_code
) i
left join relationship_to_concept r on r.concept_code_1=i.ing_code
left join devv5.concept c on c.concept_id=r.concept_id_2 -- link standard ingredients to existing ones
;
-- Count ingredients per drug
drop table q_ing_count purge;
create table q_ing_count as
  select drug_code as dcode, count(*) as cnt from q_drug_ing group by drug_code
;

-- Create table that lists for each ingredient all drugs containing it from q and r
drop table match purge;
create table match as
  select q.ing_id as r_iid, q.ing_code as q_icode, q.drug_code as q_dcode, r.drug_id as r_did
  from q_drug_ing q join r_drug_ing r on q.ing_id=r.ing_id and q.concept_class_id=r.concept_class_id-- match query and result drug on common ingredient
;
create index x_match on match(q_dcode, r_did);

-- Create table with all drugs in q and r and the number of ingredients they share
drop table shared_ing purge;
create table shared_ing as
select r_did, q_dcode, count(*) as cnt from match group by r_did, q_dcode
;

-- Create matching table for all drugs (q and r) that share ingredients and their total amount
drop table m purge;
create table m as 
select distinct m.*, rc.cnt as rc_cnt, r.precedence as i_prec
from match m
join q_ing_count qc on qc.dcode=m.q_dcode -- count number of ingredients on query (left side) drug
join r_ing_count rc on rc.did=m.r_did and qc.cnt=rc.cnt -- count number of ingredients on result (right side) drug. 
join shared_ing on shared_ing.r_did=m.r_did and shared_ing.q_dcode=m.q_dcode and shared_ing.cnt=qc.cnt -- and make sure the number of shared ingredients is the same as the total number of ingredients for both q and r
join relationship_to_concept r on r.concept_code_1=m.q_icode and r.concept_id_2=m.r_iid
;

-- Create table with Dose Forms for q
drop table q_df purge;
create table q_df as 
select css.concept_code as concept_code_1, 
  case when css.dose_form_code=' ' then 0 -- No Dose Form
    when m.concept_id_2 is null then 1 -- Dose Form, but not mapped
    else m.concept_id_2 
  end as concept_id_2, 
  nvl(m.precedence, 1) as precedence
from complete_concept_stage css
left join relationship_to_concept m on m.concept_code_1=css.dose_form_code
;

-- Create table with Dose Forms for r
drop table r_df purge;
create table r_df as 
select r.concept_id_1, r.concept_id_2 from devv5.concept_relationship r
join devv5.concept on concept_id=r.concept_id_2 and concept_class_id ='Dose Form' -- Dose Form of r
where r.invalid_reason is null and r.relationship_id='RxNorm has dose form'
;

-- Create table wiht Brand Names for q
drop table q_bn purge;
create table q_bn as
select css.concept_code as concept_code_1, 
  case when css.brand_code=' ' then 0 -- No Brand Name
    when m.concept_id_2 is null then 1 -- Brand Name, but not mapped
    else m.concept_id_2 
  end as concept_id_2, 
  nvl(m.precedence, 1) as precedence
from complete_concept_stage css
left join relationship_to_concept m on m.concept_code_1=css.brand_code 
;

-- Create table with Brand Names for r
drop table r_bn purge;
create table r_bn as
select r.concept_id_1, r.concept_id_2 
from devv5.concept_relationship r
join devv5.concept on concept_id=r.concept_id_2 and concept_class_id ='Brand Name'
where r.invalid_reason is null 
;

-- Create table that matches drugs q to r, based on Ingredient, Dose Form and Brand Name (if exist). Dose, box size or quantity are not yet compared
drop table q_to_r_anydose purge;
create table q_to_r_anydose as
-- create table with all query drug codes q_dcode mapped to standard drug concept ids r_did, irrespective of the correct dose
select distinct
  m.q_dcode, m.q_icode, m.r_did, m.r_iid, m.i_prec,
  q_df.precedence as df_prec, 
  q_bn.precedence as bn_prec,
  m.rc_cnt -- the number of ingredients in the r. 
from m
-- get the Dose Forms for each q and r
join q_df on q_df.concept_code_1=m.q_dcode 
left join r_df on r_df.concept_id_1=m.r_did -- RxNorm does not have Dose Forms for non-formed concept classes
-- get Brand Names for q and r
join q_bn on q_bn.concept_code_1=m.q_dcode
left join r_bn on r_bn.concept_id_1=m.r_did -- RxNorm does not have Brand Names for non-Branded drugs or concept_classes
-- get the quantity factor for q and r
join (
  select distinct concept_code as drug_concept_code, denominator_value as q_value from complete_concept_stage
) q_quant on q_quant.drug_concept_code=m.q_dcode
left join ( -- RxNorm might not have drug_strength for all concept_class_id
  select distinct drug_concept_id, nvl(denominator_value, 0) as q_value from devv5.drug_strength dss
) r_quant on r_quant.drug_concept_id=m.r_did
-- check for matching 
where q_df.concept_id_2=nvl(r_df.concept_id_2, 0) -- if no Dose Form match 0s
and q_bn.concept_id_2=nvl(r_bn.concept_id_2, 0) -- if no Brand Name match 0s
and q_quant.q_value=nvl(r_quant.q_value, 0) -- if no Quantity factors  match 0s
;

-- Add matching of dose and its units
drop table q_to_r_wdose purge;
create table q_to_r_wdose as
-- q component with drug_strength in RxNorm speak (ids instead of codes) (check out '3507130' for problems with 2 precedences in liquids)
with q as (
  select q_ds.drug_concept_code, q_ds.ingredient_concept_code, 
    q_ds.amount_value*nvl(q_ds_a.conversion_factor, 0) as amount_value, 
    q_ds_a.concept_id_2 as amount_unit_concept_id, 
    q_ds.numerator_value*nvl(q_ds_n.conversion_factor, 0) as numerator_value, 
    q_ds_n.concept_id_2 as numerator_unit_concept_id,
    nvl(q_ds.denominator_value, 1)*nvl(q_ds_d.conversion_factor, 1) as denominator_value, 
    q_ds_d.concept_id_2 as denominator_unit_concept_id,
    coalesce(q_ds_a.precedence, q_ds_n.precedence, q_ds_d.precedence) as u_prec
  from (
    select distinct css.concept_code as drug_concept_code, uds.ingredient_concept_code, uds.amount_value, uds.amount_unit, 
      uds.numerator_value*case css.denominator_value when 0 then 1 else denominator_value end as numerator_value, -- reconstitue full quantified 
      uds.numerator_unit, 
      case css.denominator_value when 0 then 1 else denominator_value end as denominator_value,
      uds.denominator_unit 
    from complete_concept_stage css join ds_combo dc on dc.combo_code=css.d_combo_code join ds on dc.concept_code=ds.concept_code join unique_ds uds on uds.ds_code=ds.ds_code
  ) q_ds
  left join relationship_to_concept q_ds_a on q_ds_a.concept_code_1=q_ds.amount_unit -- amount units
  left join relationship_to_concept q_ds_n on q_ds_n.concept_code_1=q_ds.numerator_unit -- numerator units
  left join relationship_to_concept q_ds_d on q_ds_d.concept_code_1=q_ds.denominator_unit -- denominator units
), r as (
-- drug_strength of r
  select distinct
    r_ds.drug_concept_id, r_ds.ingredient_concept_id, 
    r_ds.amount_value, r_ds.amount_unit_concept_id,
    r_ds.numerator_value, r_ds.numerator_unit_concept_id,
    nvl(r_ds.denominator_value, 1) as denominator_value, -- Quantified have a value in the denominator, the others haven't.
    r_ds.denominator_unit_concept_id
  from devv5.drug_strength r_ds 
)
select 
  q_dcode, q_icode, r_did, r_iid, nvl(df_prec, 100) as df_prec, nvl(bn_prec, 100) as bn_prec, nvl(u_prec, 100) as u_prec, i_prec,
  case when div>1 then 1/div else div end as div, -- the one the closest to 1 wins, but the range is 0-1, which is the opposite direction of the other ones
  unit as u_match, rc_cnt
from (
  select distinct m.*, case when r.drug_concept_id is null then 0 else q.u_prec end as u_prec,
    case
      when r.drug_concept_id is null then 1 -- if no drug_strength exist (Drug Forms etc.)
      when q.amount_value!=0 and r.amount_value is not null then q.amount_value/r.amount_value
      when q.numerator_unit_concept_id=8554 and r.numerator_unit_concept_id=8576 and r.denominator_unit_concept_id=8587 then (q.numerator_value*10)/(r.numerator_value/r.denominator_value) -- % vs mg/mL
      when q.numerator_unit_concept_id=8554 and r.numerator_unit_concept_id!=8554 then (q.numerator_value/100)/(r.numerator_value/r.denominator_value) -- % in one but not in the other
      when q.numerator_unit_concept_id!=8554 and r.numerator_unit_concept_id=8554 then (q.numerator_value/q.denominator_value)/(r.numerator_value/100) -- % in the other but not in one
      when q.numerator_value!=0 and r.numerator_value is not null then (q.numerator_value/q.denominator_value)/(r.numerator_value/r.denominator_value) -- denominator empty unless Quant
    else 0 end as div,
    case 
      when r.drug_concept_id is null then 1 -- if no drug_strength exist (Drug Forms etc.)
      when q.amount_unit_concept_id=r.amount_unit_concept_id then 1
      when q.numerator_unit_concept_id=8554 and r.numerator_unit_concept_id=8576 and r.denominator_unit_concept_id=8587 then 1 -- % vs mg/mL
      when q.numerator_unit_concept_id=8554 and r.numerator_unit_concept_id=r.denominator_unit_concept_id then 1 -- % vs mg/mg or mL/mL
      when q.numerator_unit_concept_id=q.denominator_unit_concept_id and r.numerator_unit_concept_id=8554 then 1 -- g/g, mg/mg or mL/mL vs %
      when q.numerator_unit_concept_id=r.numerator_unit_concept_id and q.denominator_unit_concept_id=r.denominator_unit_concept_id then 1
    else 0 end as unit
  from q_to_r_anydose m
  -- drug strength for each q ingredient
  left join q on q.drug_concept_code=m.q_dcode and q.ingredient_concept_code=m.q_icode
  -- drug strength for each r ingredient 
  left join r on r.drug_concept_id=m.r_did and r.ingredient_concept_id=m.r_iid
)
;

-- Remove all multiple mappings with close divs and keep the best
delete from q_to_r_wdose
where rowid in (
  select r from (
    select rowid as r,
      rank() over (partition by q_dcode, q_icode, df_prec, bn_prec, u_prec order by div desc, i_prec) as rn
    from q_to_r_wdose
  )
  where rn > 1    
)
;

-- Remove all those where not everything fits
drop table q_to_r purge;
-- table has to be created separately because both subsequent queries define one field as null
create table q_to_r as
select q_dcode, r_did, r_iid, bn_prec, df_prec, u_prec, rc_cnt from q_to_r_wdose
where 1=0;

insert into q_to_r
select 
  a.q_dcode, a.r_did, null as r_iid, a.bn_prec, a.df_prec, a.u_prec, a.rc_cnt
from ( -- take the distinct set of drug-drug pairs with the same Brand Name, Dose Form and unit precedence
-- only for those where multiple ingredients could be contained in the concept (everything but Ingredient and Clin Drug Comp)
  select q_dcode, r_did, bn_prec, df_prec, u_prec, rc_cnt, count(8) as cnt from q_to_r_wdose where nvl(rc_cnt, 0)>1 
  group by q_dcode, r_did, bn_prec, df_prec, u_prec, rc_cnt
) a
-- but make sure there are sufficient amount of components (ingredients) in each group
where a.cnt=a.rc_cnt
group by a.q_dcode, a.r_did, a.bn_prec, a.df_prec, a.u_prec, a.rc_cnt
-- not one of the components should miss the match
having not exists (
  select 1 
  from q_to_r_wdose m -- join the set of the same 
  where a.q_dcode=m.q_dcode and a.r_did=m.r_did
  and a.bn_prec=m.bn_prec and a.df_prec=m.df_prec and a.u_prec=m.u_prec
-- Change the factor closer to 1 if matching should be tighter. Currently, anything within 10% amount will be considered a match.
  and (m.div<0.9 or m.u_match=0)
)
;

-- Second step add Ingredients and the correct Clinical Drug Components
insert into q_to_r
select distinct q_dcode, r_did, r_iid, bn_prec, df_prec, u_prec, null as rc_cnt
from q_to_r_wdose
where nvl(rc_cnt, 1)=1 -- process only those that don't have combinations (Ingredients and Clin Drug Components)
and div>=0.9 and u_match=1
;

commit; 

-- 5. Write out result tables

-- Write Ingredients, Brand Names, Dose Forms
insert into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select 
  null as concept_id, 
  dcs.concept_name, -- take concept_name from equivalent 
  'Drug' as domain_id,
  dcs.vocabulary_id,
  dcs.concept_class_id,
  null as standard_concept, -- DA_France ingreidents are not standard, unless they are not mapped
  dcs.concept_code,
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
  nvl(dcs.valid_end_date, '31-Dec-2099') as valid_end_date,
  null as invalid_reason
from drug_concept_stage dcs where dcs.concept_class_id in ('Ingredient', 'Dose Form', 'Brand Name') and dcs.domain_id='Drug';

commit;

-- Promote non-mapped Ingredients to Standard
update concept_stage set standard_concept='S' where concept_code not in (select concept_code_1 from relationship_to_concept) and concept_class_id='Ingredient';

-- Write concepts from complete_concept_stage
insert into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select distinct
  null as concept_id, 
  cn.concept_name,
  'Drug' as domain_id,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id,
  css.concept_class_id,
  case when qr.q_dcode is null then 'S' else null end as standard_concept, -- Standard Concept unless there is a map to RxNorm 
  css.concept_code,
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
  nvl(dcs.valid_end_date, '31-Dec-2099') as valid_end_date,
  null as invalid_reason
from complete_concept_stage css
join complete_name cn on cn.concept_code=css.concept_code
left join drug_concept_stage dcs on dcs.concept_code=css.concept_code
left join q_to_r qr on qr.q_dcode=css.concept_code
;

commit;

-- Write equivalents from q to r Ingredients
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct 
  concept_code_1,
  q.vocabulary_id,
  first_value(r.concept_code) over (partition by concept_code_1 order by nvl(precedence, 1)) as concept_code_2, -- pick the one wiht the best precedence
  first_value(r.vocabulary_id) over (partition by concept_code_1 order by nvl(precedence, 1)) as vocabulary_id_2,
  'Has standard ing' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from drug_concept_stage q
join relationship_to_concept on concept_code_1=q.concept_code
join devv5.concept r on r.concept_id=concept_id_2
where q.concept_class_id = 'Ingredient' and q.domain_id='Drug'
;

-- Write equivalents from q to r Brand Name
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct 
  concept_code_1,
  q.vocabulary_id,
  first_value(r.concept_code) over (partition by concept_code_1 order by nvl(precedence, 1)) as concept_code_2, -- pick the one with the best precedence
  first_value(r.vocabulary_id) over (partition by concept_code_1 order by nvl(precedence, 1)) as vocabulary_id_2,
  'Has standard brand' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from drug_concept_stage q
join relationship_to_concept on concept_code_1=q.concept_code
join devv5.concept r on r.concept_id=concept_id_2
where q.concept_class_id = 'Brand Name' and q.domain_id='Drug'
;

-- Write equivalents from q to r Dose Form
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select distinct 
  concept_code_1,
  q.vocabulary_id,
  first_value(r.concept_code) over (partition by concept_code_1 order by nvl(precedence, 1)) as concept_code_2,
  first_value(r.vocabulary_id) over (partition by concept_code_1 order by nvl(precedence, 1)) as vocabulary_id_2,
  'Has standard form' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from drug_concept_stage q
join relationship_to_concept on concept_code_1=q.concept_code
join devv5.concept r on r.concept_id=concept_id_2
where q.concept_class_id = 'Dose Form' and q.domain_id='Drug'
;

-- Write maps from complete_concept_stage to RxNorm
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  qr.q_dcode as concept_code_1,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_1,
  c.concept_code concept_code_2,
  c.vocabulary_id as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
-- usual validity
from q_to_r qr
join complete_concept_stage ccs on ccs.concept_code=qr.q_dcode
join devv5.concept c on c.concept_id=qr.r_did
;

-- write RxNorm-like relationships between concepts of all classes except Drug Forms and Clinical Drug Component based on matching components
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
with rl as (
-- Pull relationship_id between concept classes from existing RxNorm
  select distinct c1.concept_class_id as concept_class_id_1, r.relationship_id, c2.concept_class_id as concept_class_id_2
  from devv5.concept c1
  join devv5.concept_relationship r on r.concept_id_1=c1.concept_id and r.invalid_reason is null 
    and relationship_id not in ('Precise ing of', 'Reformulated in', 'RxNorm replaces', 'Maps to', 'Concept replaces', 'Has precise ing', 'Mapped from', 'Reformulation of', 'RxNorm replaced by', 'Concept replaced by', 'Contained in')
  join devv5.relationship rl on rl.relationship_id=r.relationship_id and rl.defines_ancestry=1
  join devv5.concept c2 on c2.concept_id=r.concept_id_2
  where c1.vocabulary_id='RxNorm' and c2.vocabulary_id='RxNorm'
    and c1.concept_class_id not in ('Brand Name', 'Dose Form', 'Ingredient', 'Clinical Drug Form', 'Branded Drug Form', 'Clinical Drug Comp') 
-- Add non-RxNorm concept_classes
union
  select 'Branded Drug Box', 'Has quantified form', 'Quant Branded Box' from dual
union
  select 'Clinical Drug Box', 'Has quantified form', 'Quant Clinical Box' from dual
union
  select 'Clinical Drug Box', 'Has tradename', 'Branded Drug Box' from dual
union
  select 'Quant Clinical Box', 'Has tradename', 'Quant Branded Box' from dual
union
  select 'Clinical Drug', 'Available as box', 'Clinical Drug Box' from dual
union
  select 'Branded Drug', 'Available as box', 'Branded Drug Box' from dual
union
  select 'Quant Clinical Drug', 'Available as box', 'Quant Clinical Box' from dual
union
  select 'Quant Branded Drug', 'Available as box', 'Quant Branded Box' from dual
)
select 
  an.concept_code as concept_code_1,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_1,
  de.concept_code as concept_code_2,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from complete_concept_stage de
join rl on rl.concept_class_id_2=de.concept_class_id
join (
  select concept_code, 
    case denominator_value when 0 then null else denominator_value end as denominator_value, 
    d_combo_code, 
    case dose_form_code when ' ' then null else dose_form_code end as dose_form_code, 
    case brand_code when ' ' then null else brand_code end as brand_code, 
    case box_size when 0 then null else box_size end as box_size,
    concept_class_id
  from complete_concept_stage
) an on rl.concept_class_id_1=an.concept_class_id and de.d_combo_code=an.d_combo_code
where de.denominator_value=coalesce(an.denominator_value, de.denominator_value, 0) 
  and de.dose_form_code=coalesce(an.dose_form_code, de.dose_form_code, ' ') 
  and de.brand_code=coalesce(an.brand_code, de.brand_code, ' ') and de.box_size=coalesce(an.box_size, de.box_size, 0)
  and de.concept_code!=an.concept_code
;

-- For speed up pull out indexed table
drop table an purge;
create table an as
select concept_code, 
  i_combo_code,
  d_combo_code,
  replace (dose_form_code, ' ', '') as dose_form_code, 
  replace (brand_code, ' ', '') as brand_code, 
  concept_class_id
from complete_concept_stage
;
create index x_an on an(i_combo_code);

-- Write RxNorm-like relationships for Clinical Drug Forms (matching ingredient combinations)
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
-- Pull relationship_id between concept classes from existing RxNorm
with rl as (
  select distinct c1.concept_class_id as concept_class_id_1, r.relationship_id, c2.concept_class_id as concept_class_id_2
  from devv5.concept c1
  join devv5.concept_relationship r on r.concept_id_1=c1.concept_id and r.invalid_reason is null 
    and relationship_id not in ('Precise ing of', 'Reformulated in', 'RxNorm replaces', 'Maps to', 'Concept replaces', 'Has precise ing', 'Mapped from', 'Reformulation of', 'RxNorm replaced by', 'Concept replaced by', 'Contained in')
  join devv5.relationship rl on rl.relationship_id=r.relationship_id and rl.defines_ancestry=1
  join devv5.concept c2 on c2.concept_id=r.concept_id_2
  where c1.vocabulary_id='RxNorm' and c2.vocabulary_id='RxNorm'
    and c1.concept_class_id = 'Clinical Drug Form'
) 
select 
  an.concept_code as concept_code_1,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_1,
  de.concept_code as concept_code_2,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from complete_concept_stage de
join an on de.i_combo_code=an.i_combo_code and an.concept_code!=de.concept_code and an.concept_class_id='Clinical Drug Form'
join rl on rl.concept_class_id_2=de.concept_class_id 
where de.dose_form_code=coalesce(an.dose_form_code, de.dose_form_code, ' ') 
;

-- write RxNorm-like relationships for Branded Drug Forms (matching ingredient combinations)
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  an.concept_code as concept_code_1,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_1,
  de.concept_code as concept_code_2,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_2,
  'RxNorm inverse is a' as relationship_id, -- Need to take RxNorm out of these
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from complete_concept_stage de
join an on de.i_combo_code=an.i_combo_code and an.concept_code!=de.concept_code and an.concept_class_id='Branded Drug Form'
where de.concept_class_id in ('Branded Drug', 'Quant Branded Drug')
  and de.dose_form_code=coalesce(an.dose_form_code, de.dose_form_code, ' ')
  and de.brand_code=an.brand_code
;

-- Write relationship between Clinical Drug Comp (single Ingredient)
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
-- Pull relationship_id between concept classes from existing RxNorm
with rl as (
  select distinct c1.concept_class_id as concept_class_id_1, r.relationship_id, c2.concept_class_id as concept_class_id_2
  from devv5.concept c1
  join devv5.concept_relationship r on r.concept_id_1=c1.concept_id and r.invalid_reason is null 
    and relationship_id not in ('Precise ing of', 'Reformulated in', 'RxNorm replaces', 'Maps to', 'Concept replaces', 'Has precise ing', 'Mapped from', 'Reformulation of', 'RxNorm replaced by', 'Concept replaced by', 'Contained in')
  join devv5.relationship rl on rl.relationship_id=r.relationship_id and rl.defines_ancestry=1
  join devv5.concept c2 on c2.concept_id=r.concept_id_2
  where c1.vocabulary_id='RxNorm' and c2.vocabulary_id='RxNorm'
    and c1.concept_class_id = 'Clinical Drug Comp'
) 
select 
  an.concept_code as concept_code_1,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_1,
  de.concept_code as concept_code_2,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_2,
  rl.relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from complete_concept_stage de
join (
  select distinct dc.combo_code, ds.ds_code
  from ds_combo dc join ds on ds.concept_code=dc.concept_code
) d on de.d_combo_code=d.combo_code
join an on d.ds_code=an.d_combo_code and an.concept_code!=de.concept_code and an.concept_class_id='Clinical Drug Comp'
join rl on rl.concept_class_id_2=de.concept_class_id 
;

-- Write relationships between Ingredients and Clinical Drug Form and Clinical Drug Component (no Ingredient combinations)
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  i.concept_code as concept_code_1,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_1,
  ccs.concept_code as concept_code_2,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_2,
  'RxNorm ing of' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from complete_concept_stage ccs
join (
  select distinct ic.combo_code, ing.ing_code as concept_code 
  from ing_combo ic join ing on ing.concept_code=ic.concept_code
) i on ccs.i_combo_code=i.combo_code
where ccs.concept_class_id in ('Clinical Drug Form', 'Clinical Drug Comp')
;

-- Write relationships between all of them and Dose Form
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  ccs.concept_code as concept_code_1,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_1,
  ccs.dose_form_code as concept_code_2,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_2,
  'RxNorm has dose form' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from complete_concept_stage ccs
where ccs.dose_form_code is not null
;

-- Write relationships between Ingredients and Clinical Drug Form and Clinical Drug Component (no Ingredient combinations)
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  ccs.concept_code as concept_code_1,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_1,
  ccs.brand_code as concept_code_2,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_2,
  'RxNorm has ing' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from complete_concept_stage ccs
where ccs.brand_code is not null
;

-- Write maps from drugs that didn't make it into complete_concept_stage but have drug strength (duplicates)
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  e.concept_code as concept_code_1,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_1,
  c.concept_code concept_code_2,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id_2,
  'Maps to' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from existing_concept_stage e 
join complete_concept_stage c on c.denominator_value=e.denominator_value and c.i_combo_code=e.i_combo_code and c.d_combo_code=e.d_combo_code 
and c.dose_form_code=e.dose_form_code and c.brand_code=e.brand_code and c.box_size=e.box_size
where e.concept_code!=c.concept_code;

-- Write missing drugs that never made it into complete_concept_stage but have drug_strength (duplicates)
insert into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select 
  null as concept_id, 
  cn.concept_name, -- take concept_name from equivalent 
  'Drug' as domain_id,
  (select distinct vocabulary_id from drug_concept_stage) as vocabulary_id,
  e.concept_class_id,
  null as standard_concept,
  e.concept_code,
  nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from existing_concept_stage e 
join complete_concept_stage c on c.denominator_value=e.denominator_value and c.i_combo_code=e.i_combo_code and c.d_combo_code=e.d_combo_code 
  and c.dose_form_code=e.dose_form_code and c.brand_code=e.brand_code and c.box_size=e.box_size
join complete_name cn on cn.concept_code=c.concept_code
join drug_concept_stage dcs on dcs.concept_code=e.concept_code
where e.concept_code!=c.concept_code;

commit;

-- Write links to Ingredients for drugs not covered by drug_strength (added next)
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  m.concept_code as concept_code_1,
  dcs.vocabulary_id as vocabulary_id_1,
  dcs.concept_code as concept_code_2,
  dcs.vocabulary_id as vocabulary_id_2,
  'RxNorm has ing' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from (
  select concept_code from drug_concept_stage where (concept_class_id like '%Branded%' or concept_class_id like '%Clinical%') and domain_id='Drug'
  minus
  select concept_code from concept_stage 
) m
join internal_relationship_stage r on r.concept_code_1=m.concept_code
join drug_concept_stage dcs on dcs.concept_code=r.concept_code_2 and dcs.concept_class_id='Ingredient'
;

-- Write links to Dose Forms for drugs not covered by drug_strength (added next)
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  m.concept_code as concept_code_1,
  dcs.vocabulary_id as vocabulary_id_1,
  dcs.concept_code as concept_code_2,
  dcs.vocabulary_id as vocabulary_id_2,
  'RxNorm has dose form' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from (
  select concept_code from drug_concept_stage where (concept_class_id like '%Branded%' or concept_class_id like '%Clinical%') and domain_id='Drug'
  minus
  select concept_code from concept_stage 
) m
join internal_relationship_stage r on r.concept_code_1=m.concept_code
join drug_concept_stage dcs on dcs.concept_code=r.concept_code_2 and dcs.concept_class_id='Dose Form'
;

-- Write links to Brand Names for drugs not covered by drug_strength (added next)
insert into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
select 
  m.concept_code as concept_code_1,
  dcs.vocabulary_id as vocabulary_id_1,
  dcs.concept_code as concept_code_2,
  dcs.vocabulary_id as vocabulary_id_2,
  'RxNorm has ing' as relationship_id,
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from (
  select concept_code from drug_concept_stage where (concept_class_id like '%Branded%' or concept_class_id like '%Clinical%') and domain_id='Drug'
  minus
  select concept_code from concept_stage 
) m
join internal_relationship_stage r on r.concept_code_1=m.concept_code
join drug_concept_stage dcs on dcs.concept_code=r.concept_code_2 and dcs.concept_class_id='Brand Name'
;

commit;

-- Write drugs not covered by drug_strength
insert into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select 
  null as concept_id, 
  c.concept_name, -- take concept_name from equivalent 
  'Drug' as domain_id,
  c.vocabulary_id,
  c.concept_class_id,
  'S' as standard_concept,
  c.concept_code,
  nvl(c.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from (
  select concept_code from drug_concept_stage where (concept_class_id like '%Branded%' or concept_class_id like '%Clinical%') and domain_id='Drug'
  minus
  select concept_code from concept_stage 
) m
join drug_concept_stage c on c.concept_code=m.concept_code;

commit;

-- non drugs
insert into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
select
  null as concept_id,
  concept_name,
  domain_id,
  vocabulary_id,
  concept_class_id,
  'S' as standard_concept,
  concept_code,
--   nvl(valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date, 
  (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
  '31-Dec-2099' as valid_end_date,
  null as invalid_reason
from non_drug
; 

commit;


/*
-- 7. Create DRUG_STRENGTH from unique_ds
delete from drug_strength where rowid in (
  select ds.rowid from drug_strength ds join concept d on d.concept_id=drug_concept_id and d.vocabulary_id=(select distinct vocabulary_id from drug_concept_stage) 
);

/* pick the mapped ingredient */
-- insert into drug_strength
select
  ds.drug_concept_code, d.vocabulary_id as drug_vocabulary_id,
  nvl(i.concept_code, ds.ingredient_concept_code) as ingredient_concept_code, nvl(i.vocabulary_id, d.vocabulary_id) as ingredient_vocabulary_id,
  case ds.amount_value when 0 then null else ds.amount_value end as amount_value, ds.amount_unit_concept_id,
  case ds.numerator_value when 0 then null else ds.numerator_value end as numerator_value, ds.numerator_unit_concept_id,
  case ds.denominator_value when 0 then null else ds.denominator_value end as denominator_value, ds.denominator_unit_concept_id
from (
  select q_ds.drug_concept_code, q_ds.ingredient_concept_code, 
    q_ds.amount_value*q_ds_a.conversion_factor as amount_value, 
    q_ds_a.concept_id_2 as amount_unit_concept_id, 
    q_ds.numerator_value*q_ds_n.conversion_factor as numerator_value, 
    q_ds_n.concept_id_2 as numerator_unit_concept_id,
    nvl(q_ds.denominator_value, 1)*q_ds_d.conversion_factor as denominator_value, 
    q_ds_d.concept_id_2 as denominator_unit_concept_id
  from (
    select distinct css.concept_code as drug_concept_code,
      uds.ingredient_concept_code, uds.amount_value, uds.amount_unit, 
      uds.numerator_value*case css.denominator_value when 0 then 1 else denominator_value end as numerator_value, -- reconstitue full quantified 
      uds.numerator_unit, 
      css.denominator_value, uds.denominator_unit 
    from unique_ds uds join ds on uds.ds_code=ds.ds_code join ds_combo dc on dc.concept_code=ds.concept_code 
    join complete_concept_stage css on css.d_combo_code=dc.combo_code and css.concept_class_id!='Clinical Drug Comp' -- in Clinical Drug Comp no combinations of ds_codes
  union
    select distinct css.concept_code as drug_concept_code,
      uds.ingredient_concept_code, uds.amount_value, uds.amount_unit, 
      uds.numerator_value, uds.numerator_unit, 
      null as denominator_value, uds.denominator_unit 
    from unique_ds uds join ds on uds.ds_code=ds.ds_code join ds_combo dc on dc.concept_code=ds.concept_code 
    join complete_concept_stage css on css.d_combo_code=ds.ds_code and css.concept_class_id='Clinical Drug Comp' -- in Clinical Drug Comp no combinations of ds_codes
   ) q_ds
  left join relationship_to_concept q_ds_a on q_ds_a.concept_code_1=q_ds.amount_unit -- amount units
  left join relationship_to_concept q_ds_n on q_ds_n.concept_code_1=q_ds.numerator_unit -- numerator units
  left join relationship_to_concept q_ds_d on q_ds_d.concept_code_1=q_ds.denominator_unit -- denominator units
  where nvl(q_ds_a.precedence, 1)=1 and nvl(q_ds_n.precedence, 1)=1 and nvl(q_ds_d.precedence, 1)=1
) ds
join drug_concept_stage d on d.concept_code=ds.drug_concept_code
left join relationship_to_concept r on r.concept_code_1=ds.ingredient_concept_code
left join concept i on i.concept_id=r.concept_id_2
;
*/
